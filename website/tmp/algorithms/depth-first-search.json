{
  "slug": "depth-first-search",
  "name": "Depth First Search",
  "categories": ["graphs"],
  "body": {},
  "implementations": {
    "python": {
      "dir": "graphs/depth_first_search.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/graphs/depth_first_search.py",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;Non recursive implementation of a DFS algorithm.&quot;&quot;&quot;</span>\n\n<span class=\"hljs-keyword\">from</span> __future__ <span class=\"hljs-keyword\">import</span> annotations\n\n<span class=\"hljs-keyword\">from</span> typing <span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">Set</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">depth_first_search</span>(<span class=\"hljs-params\">graph: <span class=\"hljs-built_in\">dict</span>, start: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-type\">Set</span>[<span class=\"hljs-built_in\">str</span>]:\n    <span class=\"hljs-string\">&quot;&quot;&quot;Depth First Search on Graph\n    :param graph: directed graph in dictionary format\n    :param start: starting vertex as a string\n    :returns: the trace of the search\n    &gt;&gt;&gt; input_G = { &quot;A&quot;: [&quot;B&quot;, &quot;C&quot;, &quot;D&quot;], &quot;B&quot;: [&quot;A&quot;, &quot;D&quot;, &quot;E&quot;],\n    ... &quot;C&quot;: [&quot;A&quot;, &quot;F&quot;], &quot;D&quot;: [&quot;B&quot;, &quot;D&quot;], &quot;E&quot;: [&quot;B&quot;, &quot;F&quot;],\n    ... &quot;F&quot;: [&quot;C&quot;, &quot;E&quot;, &quot;G&quot;], &quot;G&quot;: [&quot;F&quot;] }\n    &gt;&gt;&gt; output_G = list({&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;})\n    &gt;&gt;&gt; all(x in output_G for x in list(depth_first_search(input_G, &quot;A&quot;)))\n    True\n    &gt;&gt;&gt; all(x in output_G for x in list(depth_first_search(input_G, &quot;G&quot;)))\n    True\n    &quot;&quot;&quot;</span>\n    explored, stack = <span class=\"hljs-built_in\">set</span>(start), [start]\n\n    <span class=\"hljs-keyword\">while</span> stack:\n        v = stack.pop()\n        explored.add(v)\n        <span class=\"hljs-comment\"># Differences from BFS:</span>\n        <span class=\"hljs-comment\"># 1) pop last element instead of first one</span>\n        <span class=\"hljs-comment\"># 2) add adjacent elements to stack without exploring them</span>\n        <span class=\"hljs-keyword\">for</span> adj <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">reversed</span>(graph[v]):\n            <span class=\"hljs-keyword\">if</span> adj <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> explored:\n                stack.append(adj)\n    <span class=\"hljs-keyword\">return</span> explored\n\n\nG = {\n    <span class=\"hljs-string\">&quot;A&quot;</span>: [<span class=\"hljs-string\">&quot;B&quot;</span>, <span class=\"hljs-string\">&quot;C&quot;</span>, <span class=\"hljs-string\">&quot;D&quot;</span>],\n    <span class=\"hljs-string\">&quot;B&quot;</span>: [<span class=\"hljs-string\">&quot;A&quot;</span>, <span class=\"hljs-string\">&quot;D&quot;</span>, <span class=\"hljs-string\">&quot;E&quot;</span>],\n    <span class=\"hljs-string\">&quot;C&quot;</span>: [<span class=\"hljs-string\">&quot;A&quot;</span>, <span class=\"hljs-string\">&quot;F&quot;</span>],\n    <span class=\"hljs-string\">&quot;D&quot;</span>: [<span class=\"hljs-string\">&quot;B&quot;</span>, <span class=\"hljs-string\">&quot;D&quot;</span>],\n    <span class=\"hljs-string\">&quot;E&quot;</span>: [<span class=\"hljs-string\">&quot;B&quot;</span>, <span class=\"hljs-string\">&quot;F&quot;</span>],\n    <span class=\"hljs-string\">&quot;F&quot;</span>: [<span class=\"hljs-string\">&quot;C&quot;</span>, <span class=\"hljs-string\">&quot;E&quot;</span>, <span class=\"hljs-string\">&quot;G&quot;</span>],\n    <span class=\"hljs-string\">&quot;G&quot;</span>: [<span class=\"hljs-string\">&quot;F&quot;</span>],\n}\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    <span class=\"hljs-keyword\">import</span> doctest\n\n    doctest.testmod()\n    <span class=\"hljs-built_in\">print</span>(depth_first_search(G, <span class=\"hljs-string\">&quot;A&quot;</span>))\n"
    },
    "javascript": {
      "dir": "Trees/DepthFirstSearch.js",
      "url": "https://github.com/TheAlgorithms/javascript/tree/master/Trees/DepthFirstSearch.js",
      "code": "<span class=\"hljs-comment\">/*\n * Author: Surendra Kumar\n * DFS Algorithm implementation in JavaScript\n * DFS Algorithm for traversing or searching graph data structures.\n*/</span>\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">traverseDFS</span> (root) {\n  <span class=\"hljs-keyword\">const</span> stack = [root]\n  <span class=\"hljs-keyword\">const</span> res = []\n\n  <span class=\"hljs-keyword\">while</span> (stack.<span class=\"hljs-property\">length</span>) {\n    <span class=\"hljs-keyword\">const</span> curr = stack.<span class=\"hljs-title function_\">pop</span>()\n    res.<span class=\"hljs-title function_\">push</span>(curr.<span class=\"hljs-property\">key</span>)\n\n    <span class=\"hljs-keyword\">if</span> (curr.<span class=\"hljs-property\">right</span>) {\n      stack.<span class=\"hljs-title function_\">push</span>(curr.<span class=\"hljs-property\">right</span>)\n    }\n\n    <span class=\"hljs-keyword\">if</span> (curr.<span class=\"hljs-property\">left</span>) {\n      stack.<span class=\"hljs-title function_\">push</span>(curr.<span class=\"hljs-property\">left</span>)\n    }\n  }\n\n  <span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-title function_\">reverse</span>()\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">searchDFS</span> (tree, value) {\n  <span class=\"hljs-keyword\">const</span> stack = []\n\n  stack.<span class=\"hljs-title function_\">push</span>(tree[<span class=\"hljs-number\">0</span>])\n\n  <span class=\"hljs-keyword\">while</span> (stack.<span class=\"hljs-property\">length</span> !== <span class=\"hljs-number\">0</span>) {\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; stack.<span class=\"hljs-property\">length</span>; i++) {\n      <span class=\"hljs-keyword\">const</span> node = stack.<span class=\"hljs-title function_\">pop</span>()\n\n      <span class=\"hljs-keyword\">if</span> (node.<span class=\"hljs-property\">value</span> === value) {\n        <span class=\"hljs-keyword\">return</span> node\n      }\n      <span class=\"hljs-keyword\">if</span> (node.<span class=\"hljs-property\">right</span>) {\n        stack.<span class=\"hljs-title function_\">push</span>(tree[node.<span class=\"hljs-property\">right</span>])\n      }\n      <span class=\"hljs-keyword\">if</span> (node.<span class=\"hljs-property\">left</span>) {\n        stack.<span class=\"hljs-title function_\">push</span>(tree[node.<span class=\"hljs-property\">left</span>])\n      }\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>\n}\n\n<span class=\"hljs-keyword\">const</span> tree = [\n  { <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">6</span>, <span class=\"hljs-attr\">left</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">right</span>: <span class=\"hljs-number\">2</span> },\n  { <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">5</span>, <span class=\"hljs-attr\">left</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">right</span>: <span class=\"hljs-number\">4</span> },\n  { <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">7</span>, <span class=\"hljs-attr\">left</span>: <span class=\"hljs-literal\">null</span>, <span class=\"hljs-attr\">right</span>: <span class=\"hljs-number\">5</span> },\n  { <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">left</span>: <span class=\"hljs-number\">6</span>, <span class=\"hljs-attr\">right</span>: <span class=\"hljs-literal\">null</span> },\n  { <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">4</span>, <span class=\"hljs-attr\">left</span>: <span class=\"hljs-literal\">null</span>, <span class=\"hljs-attr\">right</span>: <span class=\"hljs-literal\">null</span> },\n  { <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">9</span>, <span class=\"hljs-attr\">left</span>: <span class=\"hljs-number\">7</span>, <span class=\"hljs-attr\">right</span>: <span class=\"hljs-number\">8</span> },\n  { <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">left</span>: <span class=\"hljs-number\">9</span>, <span class=\"hljs-attr\">right</span>: <span class=\"hljs-literal\">null</span> },\n  { <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">8</span>, <span class=\"hljs-attr\">left</span>: <span class=\"hljs-literal\">null</span>, <span class=\"hljs-attr\">right</span>: <span class=\"hljs-literal\">null</span> },\n  { <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">10</span>, <span class=\"hljs-attr\">left</span>: <span class=\"hljs-literal\">null</span>, <span class=\"hljs-attr\">right</span>: <span class=\"hljs-literal\">null</span> },\n  { <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">left</span>: <span class=\"hljs-literal\">null</span>, <span class=\"hljs-attr\">right</span>: <span class=\"hljs-literal\">null</span> }\n]\n\n<span class=\"hljs-title function_\">searchDFS</span>(tree, <span class=\"hljs-number\">9</span>)\n<span class=\"hljs-title function_\">searchDFS</span>(tree, <span class=\"hljs-number\">10</span>)\n\n<span class=\"hljs-title function_\">traverseDFS</span>(<span class=\"hljs-number\">6</span>)\n\n<span class=\"hljs-comment\">//            6</span>\n<span class=\"hljs-comment\">//           / \\</span>\n<span class=\"hljs-comment\">//          5   7</span>\n<span class=\"hljs-comment\">//         / \\   \\</span>\n<span class=\"hljs-comment\">//        3   4   9</span>\n<span class=\"hljs-comment\">//       /       / \\</span>\n<span class=\"hljs-comment\">//      2       8   10</span>\n<span class=\"hljs-comment\">//     /</span>\n<span class=\"hljs-comment\">//    1</span>\n"
    },
    "c-plus-plus": {
      "dir": "graph/depth_first_search.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph/depth_first_search.cpp",
      "code": "<span class=\"hljs-comment\">/**\n *\n * \\file\n * \\brief [Depth First Search Algorithm\n * (Depth First Search)](https://en.wikipedia.org/wiki/Depth-first_search)\n *\n * \\author [Ayaan Khan](http://github.com/ayaankhan98)\n *\n * \\details\n * Depth First Search also quoted as DFS is a Graph Traversal Algorithm.\n * Time Complexity O(|V| + |E|) where V is number of vertices and E\n * is number of edges in graph.\n *\n * Application of Depth First Search are\n *\n * 1. Finding connected components\n * 2. Finding 2-(edge or vertex)-connected components.\n * 3. Finding 3-(edge or vertex)-connected components.\n * 4. Finding the bridges of a graph.\n * 5. Generating words in order to plot the limit set of a group.\n * 6. Finding strongly connected components.\n *\n * And there are many more...\n *\n * &lt;h4&gt;Working&lt;/h4&gt;\n * 1. Mark all vertices as unvisited first\n * 2. start exploring from some starting vertex.\n *\n *      While exploring vertex we mark the vertex as visited\n *      and start exploring the vertices connected to this\n *      vertex in recursive way.\n *\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\n\n<span class=\"hljs-comment\">/**\n *\n * \\namespace graph\n * \\brief Graph Algorithms\n *\n */</span>\n<span class=\"hljs-keyword\">namespace</span> graph {\n<span class=\"hljs-comment\">/**\n * \\brief\n * Adds and edge between two vertices of graph say u and v in this\n * case.\n *\n * @param adj Adjacency list representation of graph\n * @param u first vertex\n * @param v second vertex\n *\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addEdge</span><span class=\"hljs-params\">(std::vector&lt;std::vector&lt;<span class=\"hljs-type\">size_t</span>&gt;&gt; *adj, <span class=\"hljs-type\">size_t</span> u, <span class=\"hljs-type\">size_t</span> v)</span> </span>{\n    <span class=\"hljs-comment\">/*\n     *\n     * Here we are considering undirected graph that&#x27;s the\n     * reason we are adding v to the adjacency list representation of u\n     * and also adding u to the adjacency list representation of v\n     *\n     */</span>\n    (*adj)[u - <span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">push_back</span>(v - <span class=\"hljs-number\">1</span>);\n    (*adj)[v - <span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">push_back</span>(u - <span class=\"hljs-number\">1</span>);\n}\n\n<span class=\"hljs-comment\">/**\n *\n * \\brief\n * Explores the given vertex, exploring a vertex means traversing\n * over all the vertices which are connected to the vertex that is\n * currently being explored.\n *\n * @param adj garph\n * @param v vertex to be explored\n * @param visited already visited vertices\n *\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">explore</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::vector&lt;std::vector&lt;<span class=\"hljs-type\">size_t</span>&gt;&gt; &amp;adj, <span class=\"hljs-type\">size_t</span> v,\n             std::vector&lt;<span class=\"hljs-type\">bool</span>&gt; *visited)</span> </span>{\n    std::cout &lt;&lt; v + <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;\n    (*visited)[v] = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> x : adj[v]) {\n        <span class=\"hljs-keyword\">if</span> (!(*visited)[x]) {\n            <span class=\"hljs-built_in\">explore</span>(adj, x, visited);\n        }\n    }\n}\n\n<span class=\"hljs-comment\">/**\n * \\brief\n * initiates depth first search algorithm.\n *\n * @param adj adjacency list of graph\n * @param start vertex from where DFS starts traversing.\n *\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">depth_first_search</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::vector&lt;std::vector&lt;<span class=\"hljs-type\">size_t</span>&gt;&gt; &amp;adj,\n                        <span class=\"hljs-type\">size_t</span> start)</span> </span>{\n    <span class=\"hljs-type\">size_t</span> vertices = adj.<span class=\"hljs-built_in\">size</span>();\n\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">bool</span>&gt; <span class=\"hljs-title\">visited</span><span class=\"hljs-params\">(vertices, <span class=\"hljs-literal\">false</span>)</span></span>;\n    <span class=\"hljs-built_in\">explore</span>(adj, start, &amp;visited);\n}\n}  <span class=\"hljs-comment\">// namespace graph</span>\n\n<span class=\"hljs-comment\">/** Main function */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-type\">size_t</span> vertices = <span class=\"hljs-number\">0</span>, edges = <span class=\"hljs-number\">0</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the Vertices : &quot;</span>;\n    std::cin &gt;&gt; vertices;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the Edges : &quot;</span>;\n    std::cin &gt;&gt; edges;\n\n    <span class=\"hljs-comment\">/// creating graph</span>\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">size_t</span>&gt;&gt; <span class=\"hljs-built_in\">adj</span>(vertices, std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">size_t</span>&gt;());\n\n    <span class=\"hljs-comment\">/// taking input for edges</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the vertices which have edges between them : &quot;</span>\n              &lt;&lt; std::endl;\n    <span class=\"hljs-keyword\">while</span> (edges--) {\n        <span class=\"hljs-type\">size_t</span> u = <span class=\"hljs-number\">0</span>, v = <span class=\"hljs-number\">0</span>;\n        std::cin &gt;&gt; u &gt;&gt; v;\n        graph::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj, u, v);\n    }\n\n    <span class=\"hljs-comment\">/// running depth first search over graph</span>\n    graph::<span class=\"hljs-built_in\">depth_first_search</span>(adj, <span class=\"hljs-number\">2</span>);\n\n    std::cout &lt;&lt; std::endl;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "go": {
      "dir": "graphs/depthfirstsearch/depthfirstsearch.go",
      "url": "https://github.com/TheAlgorithms/go/tree/master/graphs/depthfirstsearch/depthfirstsearch.go",
      "code": "<span class=\"hljs-keyword\">package</span> depthfirstsearch\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">GetIdx</span><span class=\"hljs-params\">(target <span class=\"hljs-keyword\">int</span>, nodes []<span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">int</span></span> {\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(nodes); i++ {\n\t\t<span class=\"hljs-keyword\">if</span> nodes[i] == target {\n\t\t\t<span class=\"hljs-keyword\">return</span> i\n\t\t}\n\t}\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NotExist</span><span class=\"hljs-params\">(target <span class=\"hljs-keyword\">int</span>, slice []<span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(slice); i++ {\n\t\t<span class=\"hljs-keyword\">if</span> slice[i] == target {\n\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n\t\t}\n\t}\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Dfs</span><span class=\"hljs-params\">(start, end <span class=\"hljs-keyword\">int</span>, nodes []<span class=\"hljs-keyword\">int</span>, edges [][]<span class=\"hljs-keyword\">bool</span>)</span> <span class=\"hljs-params\">([]<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">bool</span>)</span></span> {\n\t<span class=\"hljs-keyword\">var</span> route []<span class=\"hljs-keyword\">int</span>\n\t<span class=\"hljs-keyword\">var</span> stack []<span class=\"hljs-keyword\">int</span>\n\tstartIdx := GetIdx(start, nodes)\n\tstack = <span class=\"hljs-built_in\">append</span>(stack, startIdx)\n\t<span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">len</span>(stack) &gt; <span class=\"hljs-number\">0</span> {\n\t\tnow := stack[<span class=\"hljs-built_in\">len</span>(stack)<span class=\"hljs-number\">-1</span>]\n\t\troute = <span class=\"hljs-built_in\">append</span>(route, nodes[now])\n\t\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(stack) &gt; <span class=\"hljs-number\">1</span> {\n\t\t\tstack = stack[:<span class=\"hljs-built_in\">len</span>(stack)<span class=\"hljs-number\">-1</span>]\n\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\tstack = stack[:<span class=\"hljs-built_in\">len</span>(stack)<span class=\"hljs-number\">-1</span>]\n\t\t}\n\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(edges[now]); i++ {\n\t\t\t<span class=\"hljs-keyword\">if</span> edges[now][i] &amp;&amp; NotExist(i, stack) {\n\t\t\t\tstack = <span class=\"hljs-built_in\">append</span>(stack, i)\n\t\t\t}\n\t\t\tedges[now][i] = <span class=\"hljs-literal\">false</span>\n\t\t\tedges[i][now] = <span class=\"hljs-literal\">false</span>\n\t\t}\n\t\t<span class=\"hljs-keyword\">if</span> route[<span class=\"hljs-built_in\">len</span>(route)<span class=\"hljs-number\">-1</span>] == end {\n\t\t\t<span class=\"hljs-keyword\">return</span> route, <span class=\"hljs-literal\">true</span>\n\t\t}\n\t}\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, <span class=\"hljs-literal\">false</span>\n}\n\n<span class=\"hljs-comment\">// func main() {</span>\n<span class=\"hljs-comment\">// \tnodes := []int{</span>\n<span class=\"hljs-comment\">// \t\t1, 2, 3, 4, 5, 6,</span>\n<span class=\"hljs-comment\">// \t}</span>\n<span class=\"hljs-comment\">// \t/*</span>\n<span class=\"hljs-comment\">// \t\tsample graph</span>\n<span class=\"hljs-comment\">// \t\t①-②</span>\n<span class=\"hljs-comment\">// \t\t|  |</span>\n<span class=\"hljs-comment\">// \t\t③-④-⑤-⑥</span>\n<span class=\"hljs-comment\">// \t*/</span>\n<span class=\"hljs-comment\">// \tedges := [][]bool{</span>\n<span class=\"hljs-comment\">// \t\t{false, true, true, false, false, false},</span>\n<span class=\"hljs-comment\">// \t\t{true, false, false, true, false, false},</span>\n<span class=\"hljs-comment\">// \t\t{true, false, false, true, false, false},</span>\n<span class=\"hljs-comment\">// \t\t{false, true, true, false, true, false},</span>\n<span class=\"hljs-comment\">// \t\t{false, false, false, true, false, true},</span>\n<span class=\"hljs-comment\">// \t\t{false, false, false, false, true, false},</span>\n<span class=\"hljs-comment\">// \t}</span>\n<span class=\"hljs-comment\">// \tstart := 1</span>\n<span class=\"hljs-comment\">// \tend := 6</span>\n<span class=\"hljs-comment\">// \troute, _ := dfs(start, end, nodes, edges)</span>\n<span class=\"hljs-comment\">// \tfmt.Println(route)</span>\n<span class=\"hljs-comment\">// }</span>\n"
    },
    "dart": {
      "dir": "graphs/depth_first_search.dart",
      "url": "https://github.com/TheAlgorithms/dart/tree/master/graphs/depth_first_search.dart",
      "code": "<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;dart:collection&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;package:test/test.dart&#x27;</span>;\n\n<span class=\"hljs-comment\">/// <span class=\"language-markdown\">Implementation of Depth First Search</span></span>\n<span class=\"hljs-comment\">/// <span class=\"language-markdown\">https://en.wikipedia.org/wiki/Depth-first<span class=\"hljs-emphasis\">_search</span></span></span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Graph</span> </span>{\n  <span class=\"hljs-comment\">/// <span class=\"language-markdown\"><span class=\"hljs-emphasis\">Adjacency List representation using dynamic list and HashMap</span></span></span>\n  HashMap graph = <span class=\"hljs-keyword\">new</span> HashMap&lt;<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">dynamic</span>&gt;&gt;();\n  <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; nodes;\n\n  <span class=\"hljs-keyword\">void</span> makeGraph() {\n    <span class=\"hljs-comment\">/// <span class=\"language-markdown\"><span class=\"hljs-emphasis\">initialise all nodes with empty lists.</span></span></span>\n    <span class=\"hljs-comment\">/// <span class=\"language-markdown\"><span class=\"hljs-emphasis\">each node will have a list as value which stores</span></span></span>\n    <span class=\"hljs-comment\">/// <span class=\"language-markdown\"><span class=\"hljs-emphasis\">the nodes to which it is connected to</span></span></span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-keyword\">this</span>.nodes.length; i++) {\n      <span class=\"hljs-keyword\">this</span>.graph[nodes[i]] = <span class=\"hljs-built_in\">List</span>();\n    }\n  }\n\n  Graph(<span class=\"hljs-keyword\">this</span>.nodes) {\n    <span class=\"hljs-keyword\">this</span>.makeGraph();\n  }\n\n  <span class=\"hljs-built_in\">int</span> <span class=\"hljs-keyword\">get</span> numberOfNodesInGraph {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.nodes.length;\n  }\n\n  HashMap <span class=\"hljs-keyword\">get</span> graphDataStructure {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.graph;\n  }\n\n  <span class=\"hljs-keyword\">void</span> addNodes(<span class=\"hljs-built_in\">int</span> newNode) {\n    <span class=\"hljs-keyword\">this</span>.nodes.add(newNode);\n    <span class=\"hljs-keyword\">this</span>.graph[newNode] = <span class=\"hljs-built_in\">List</span>();\n  }\n\n  <span class=\"hljs-keyword\">void</span> addEdges(<span class=\"hljs-built_in\">int</span> start, <span class=\"hljs-built_in\">int</span> end) {\n    <span class=\"hljs-keyword\">this</span>.graph[start].add(end);\n  }\n}\n\n<span class=\"hljs-keyword\">void</span> depthFirstSearchHelper(graph, visitedNodes, node, answer) {\n  <span class=\"hljs-keyword\">if</span> (visitedNodes[node]) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n  }\n  visitedNodes[node] = <span class=\"hljs-keyword\">true</span>;\n  answer.add(node);\n  <span class=\"hljs-keyword\">if</span> (graph.containsKey(node)) {\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> child <span class=\"hljs-keyword\">in</span> graph[node]) {\n      <span class=\"hljs-keyword\">if</span> (!visitedNodes[child]) {\n        depthFirstSearchHelper(graph, visitedNodes, child, answer);\n      }\n    }\n  }\n}\n\n<span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; depthFirstSearch(Graph graph, <span class=\"hljs-built_in\">int</span> numberOfNodes, <span class=\"hljs-built_in\">int</span> startNode) {\n  <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">bool</span>&gt; visitedNodes =\n      <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">bool</span>&gt;.generate(numberOfNodes, (index) =&gt; <span class=\"hljs-keyword\">false</span>);\n\n  <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; answer = <span class=\"hljs-built_in\">List</span>();\n  depthFirstSearchHelper(graph.graph, visitedNodes, startNode, answer);\n  <span class=\"hljs-keyword\">return</span> answer;\n}\n\n<span class=\"hljs-keyword\">void</span> main() {\n  test((<span class=\"hljs-string\">&#x27;Test case 1:&#x27;</span>), () {\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; nodes = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n    <span class=\"hljs-built_in\">int</span> numberOfEdges = <span class=\"hljs-number\">3</span>;\n\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt;&gt; edges = [\n      [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>],\n      [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>],\n      [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>]\n    ];\n    Graph graph = Graph(nodes);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; numberOfEdges; i++) {\n      <span class=\"hljs-built_in\">int</span> start = edges[i][<span class=\"hljs-number\">0</span>];\n      <span class=\"hljs-built_in\">int</span> end = edges[i][<span class=\"hljs-number\">1</span>];\n      graph.addEdges(start, end);\n    }\n    <span class=\"hljs-built_in\">int</span> startNode = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; answer =\n        depthFirstSearch(graph, graph.numberOfNodesInGraph, startNode);\n    expect(answer, equals([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]));\n  });\n\n  test((<span class=\"hljs-string\">&#x27;Test case 2:&#x27;</span>), () {\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; nodes = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];\n    <span class=\"hljs-built_in\">int</span> numberOfEdges = <span class=\"hljs-number\">4</span>;\n\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt;&gt; edges = [\n      [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>],\n      [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>],\n      [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>],\n      [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>]\n    ];\n    Graph graph = Graph(nodes);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; numberOfEdges; i++) {\n      <span class=\"hljs-built_in\">int</span> start = edges[i][<span class=\"hljs-number\">0</span>];\n      <span class=\"hljs-built_in\">int</span> end = edges[i][<span class=\"hljs-number\">1</span>];\n      graph.addEdges(start, end);\n    }\n    <span class=\"hljs-built_in\">int</span> startNode = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; answer =\n        depthFirstSearch(graph, graph.numberOfNodesInGraph, startNode);\n    expect(answer, equals([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>]));\n  });\n}\n"
    },
    "ruby": {
      "dir": "searches/depth_first_search.rb",
      "url": "https://github.com/TheAlgorithms/ruby/tree/master/searches/depth_first_search.rb",
      "code": "<span class=\"hljs-comment\"># <span class=\"hljs-doctag\">@param</span> [Integer] start</span>\n<span class=\"hljs-comment\"># <span class=\"hljs-doctag\">@param</span> [Integer] target</span>\n<span class=\"hljs-comment\"># <span class=\"hljs-doctag\">@param</span> [Array] adjacency_list</span>\n<span class=\"hljs-comment\"># <span class=\"hljs-doctag\">@return</span> [Array] routes</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(start, target, adjacency_list)</span></span>\n  is_visited = Hash.new(<span class=\"hljs-literal\">false</span>)\n  parent = {}\n  stack = [start]\n  loop <span class=\"hljs-keyword\">do</span>\n    <span class=\"hljs-keyword\">break</span> <span class=\"hljs-keyword\">if</span> stack.empty?\n\n    current_node = stack.pop\n    is_visited[current_node] = <span class=\"hljs-literal\">true</span>\n\n    <span class=\"hljs-keyword\">return</span> get_path(parent, target) <span class=\"hljs-keyword\">if</span> current_node == target\n\n    adjacency_list[current_node].each <span class=\"hljs-keyword\">do</span> <span class=\"hljs-params\">|neighbor|</span>\n      <span class=\"hljs-keyword\">next</span> <span class=\"hljs-keyword\">if</span> is_visited[neighbor]\n\n      stack &lt;&lt; neighbor\n      is_visited[neighbor] = <span class=\"hljs-literal\">true</span>\n      parent[neighbor] = current_node\n    <span class=\"hljs-keyword\">end</span>\n  <span class=\"hljs-keyword\">end</span>\n  []\n<span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-comment\"># <span class=\"hljs-doctag\">@param</span> [Hash] parent</span>\n<span class=\"hljs-comment\"># <span class=\"hljs-doctag\">@param</span> [Integer] dest</span>\n<span class=\"hljs-comment\"># <span class=\"hljs-doctag\">@return</span> [Array] path</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">get_path</span><span class=\"hljs-params\">(parent, dest)</span></span>\n  iterator = dest\n  path = [dest]\n  <span class=\"hljs-keyword\">while</span> parent.has_key?(iterator)\n    path &lt;&lt; parent[iterator]\n    iterator = parent[iterator]\n  <span class=\"hljs-keyword\">end</span>\n  path.reverse\n<span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">main</span></span>\n  adjacency_list = [\n    [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>], <span class=\"hljs-comment\"># 0</span>\n    [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>], <span class=\"hljs-comment\"># 1</span>\n    [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>], <span class=\"hljs-comment\"># 2</span>\n    [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>], <span class=\"hljs-comment\"># 3</span>\n    [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>], <span class=\"hljs-comment\"># 4</span>\n    [<span class=\"hljs-number\">4</span>] <span class=\"hljs-comment\"># 5</span>\n  ]\n  p dfs(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">5</span>, adjacency_list)\n<span class=\"hljs-keyword\">end</span>\n\nmain\n"
    }
  },
  "contributors": [
    {
      "name": "Vitor Oliveira",
      "email": "vbrazo@gmail.com",
      "commits": 1
    },
    {
      "name": "AlexDvorak",
      "email": "opti.jawsome@gmail.com",
      "commits": 1
    },
    {
      "name": "Taj",
      "email": "tjgurwara99@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Dandy Naufaldi",
      "email": "dandy.naufaldi@gmail.com",
      "commits": 1
    },
    {
      "name": "Rak Laptudirm",
      "email": "68542775+raklaptudirm@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "hasan",
      "email": "hasanuli10@gmail.com",
      "commits": 1
    },
    {
      "name": "ParthS007",
      "email": "parth1989shandilya@gmail.com",
      "commits": 1
    },
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 1
    },
    {
      "name": "Marcos Cannabrava",
      "email": "54267712+marcoscannabrava@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Sanders Lin",
      "email": "45224617+SandersLin@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "cclauss",
      "email": "cclauss@bluewin.ch",
      "commits": 1
    },
    {
      "name": "97arushisharma",
      "email": "97arushisharma@gmail.com",
      "commits": 1
    },
    {
      "name": "rxaru",
      "email": "ai.kanaria.ai@gmail.com",
      "commits": 2
    },
    {
      "name": "Akash G Krishnan",
      "email": "krishnanag1996@gmail.com",
      "commits": 2
    },
    {
      "name": "shellhub",
      "email": "shellhub.me@gmail.com",
      "commits": 2
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 6
    }
  ],
  "explanationUrl": {}
}
