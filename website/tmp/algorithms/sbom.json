{
  "slug": "sbom",
  "name": "Sbom",
  "categories": [
    "strings",
    "multiplestringmatching",
    "setbackwardoraclematching"
  ],
  "body": {},
  "implementations": {
    "go": {
      "dir": "strings/multiple-string-matching/sbom/sbom.go",
      "url": "https://github.com/TheAlgorithms/go/tree/master/strings/multiple-string-matching/sbom/sbom.go",
      "code": "<span class=\"hljs-keyword\">package</span> sbom\n\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">&quot;fmt&quot;</span>\n\t<span class=\"hljs-string\">&quot;strings&quot;</span>\n\t<span class=\"hljs-string\">&quot;time&quot;</span>\n)\n\n<span class=\"hljs-keyword\">type</span> Result <span class=\"hljs-keyword\">struct</span> {\n\toccurrences <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>][]<span class=\"hljs-keyword\">int</span>\n}\n\n<span class=\"hljs-comment\">// Implementation of Set Backward Oracle Matching algorithm (Factor based).</span>\n<span class=\"hljs-comment\">// Searches for a set of strings (in &#x27;patterns.txt&#x27;) in text.txt.</span>\n<span class=\"hljs-comment\">// func main() {</span>\n<span class=\"hljs-comment\">// \tpatFile, err := ioutil.ReadFile(&quot;../patterns.txt&quot;)</span>\n<span class=\"hljs-comment\">// \tif err != nil {</span>\n<span class=\"hljs-comment\">// \t\tlog.Fatal(err)</span>\n<span class=\"hljs-comment\">// \t}</span>\n<span class=\"hljs-comment\">// \ttextFile, err := ioutil.ReadFile(&quot;../text.txt&quot;)</span>\n<span class=\"hljs-comment\">// \tif err != nil {</span>\n<span class=\"hljs-comment\">// \t\tlog.Fatal(err)</span>\n<span class=\"hljs-comment\">// \t}</span>\n<span class=\"hljs-comment\">// \tpatterns := strings.Split(string(patFile), &quot; &quot;)</span>\n<span class=\"hljs-comment\">// \tfmt.Printf(&quot;\\nRunning: Set Backward Oracle Matching algorithm.\\n\\n&quot;)</span>\n<span class=\"hljs-comment\">// \tif debugMode {</span>\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot;Searching for %d patterns/words:\\n&quot;, len(patterns))</span>\n<span class=\"hljs-comment\">// \t}</span>\n<span class=\"hljs-comment\">// \tfor i := 0; i &lt; len(patterns); i++ {</span>\n<span class=\"hljs-comment\">// \t\tif len(patterns[i]) &gt; len(textFile) {</span>\n<span class=\"hljs-comment\">// \t\t\tlog.Fatal(&quot;There is a pattern that is longer than text! Pattern number:&quot;, i+1)</span>\n<span class=\"hljs-comment\">// \t\t}</span>\n<span class=\"hljs-comment\">// \t\tif debugMode {</span>\n<span class=\"hljs-comment\">// \t\t\tfmt.Printf(&quot;%q &quot;, patterns[i])</span>\n<span class=\"hljs-comment\">// \t\t}</span>\n<span class=\"hljs-comment\">// \t}</span>\n<span class=\"hljs-comment\">// \tif debugMode {</span>\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot;\\n\\nIn text (%d chars long): \\n%q\\n\\n&quot;, len(textFile), textFile)</span>\n<span class=\"hljs-comment\">// \t}</span>\n<span class=\"hljs-comment\">// \tr := sbom(string(textFile), patterns)</span>\n<span class=\"hljs-comment\">// \tfor key, value := range r.occurrences { //prints all occurrences of each pattern (if there was at least one)</span>\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot;\\nThere were %d occurrences for word: %q at positions: &quot;, len(value), key)</span>\n<span class=\"hljs-comment\">// \t\tfor i := range value {</span>\n<span class=\"hljs-comment\">// \t\t\tfmt.Printf(&quot;%d&quot;, value[i])</span>\n<span class=\"hljs-comment\">// \t\t\tif i != len(value)-1 {</span>\n<span class=\"hljs-comment\">// \t\t\t\tfmt.Printf(&quot;, &quot;)</span>\n<span class=\"hljs-comment\">// \t\t\t}</span>\n<span class=\"hljs-comment\">// \t\t}</span>\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot;.&quot;)</span>\n<span class=\"hljs-comment\">// \t}</span>\n\n<span class=\"hljs-comment\">// }</span>\n\n<span class=\"hljs-comment\">// Sbom Function sbom performing the Set Backward Oracle Matching algorithm.</span>\n<span class=\"hljs-comment\">// Finds and prints occurrences of each pattern.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Sbom</span><span class=\"hljs-params\">(t <span class=\"hljs-keyword\">string</span>, p []<span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-title\">Result</span></span> {\n\tstartTime := time.Now()\n\toccurrences := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">int</span>][]<span class=\"hljs-keyword\">int</span>)\n\tlmin := computeMinLength(p)\n\tor, f := buildOracleMultiple(reverseAll(trimToLength(p, lmin)))\n\tpos := <span class=\"hljs-number\">0</span>\n\t<span class=\"hljs-keyword\">for</span> pos &lt;= <span class=\"hljs-built_in\">len</span>(t)-lmin {\n\t\tcurrent := <span class=\"hljs-number\">0</span>\n\t\tj := lmin\n\t\t<span class=\"hljs-keyword\">for</span> j &gt;= <span class=\"hljs-number\">1</span> &amp;&amp; stateExists(current, or) {\n\t\t\tcurrent = getTransition(current, t[pos+j<span class=\"hljs-number\">-1</span>], or)\n\t\t\tj--\n\t\t}\n\t\tword := getWord(pos, pos+lmin<span class=\"hljs-number\">-1</span>, t)\n\t\t<span class=\"hljs-keyword\">if</span> stateExists(current, or) &amp;&amp; j == <span class=\"hljs-number\">0</span> &amp;&amp; strings.HasPrefix(word, getCommonPrefix(p, f[current], lmin)) { <span class=\"hljs-comment\">//check for prefix match</span>\n\t\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">range</span> f[current] {\n\t\t\t\t<span class=\"hljs-keyword\">if</span> p[f[current][i]] == getWord(pos, pos<span class=\"hljs-number\">-1</span>+<span class=\"hljs-built_in\">len</span>(p[f[current][i]]), t) { <span class=\"hljs-comment\">//check for word match</span>\n\t\t\t\t\tnewOccurrences := intArrayCapUp(occurrences[f[current][i]])\n\t\t\t\t\toccurrences[f[current][i]] = newOccurrences\n\t\t\t\t\toccurrences[f[current][i]][<span class=\"hljs-built_in\">len</span>(newOccurrences)<span class=\"hljs-number\">-1</span>] = pos\n\t\t\t\t}\n\t\t\t}\n\t\t\tj = <span class=\"hljs-number\">0</span>\n\t\t}\n\t\tpos = pos + j + <span class=\"hljs-number\">1</span>\n\t}\n\telapsed := time.Since(startTime)\n\tfmt.Printf(<span class=\"hljs-string\">&quot;\\n\\nElapsed %f secs\\n&quot;</span>, elapsed.Seconds())\n\t<span class=\"hljs-keyword\">var</span> resultOccurrences = <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>][]<span class=\"hljs-keyword\">int</span>)\n\t<span class=\"hljs-keyword\">for</span> key, value := <span class=\"hljs-keyword\">range</span> occurrences {\n\t\tresultOccurrences[p[key]] = value\n\t}\n\n\t<span class=\"hljs-keyword\">return</span> Result{\n\t\tresultOccurrences,\n\t}\n}\n\n<span class=\"hljs-comment\">// Function that builds factor oracle.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">buildOracleMultiple</span><span class=\"hljs-params\">(p []<span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-params\">(orToReturn <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">int</span>]<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">uint8</span>]<span class=\"hljs-keyword\">int</span>, f <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">int</span>][]<span class=\"hljs-keyword\">int</span>)</span></span> {\n\torTrie, stateIsTerminal, f := constructTrie(p)\n\ts := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-built_in\">len</span>(stateIsTerminal)) <span class=\"hljs-comment\">//supply function</span>\n\ti := <span class=\"hljs-number\">0</span>                                 <span class=\"hljs-comment\">//root of trie</span>\n\torToReturn = orTrie\n\ts[i] = <span class=\"hljs-number\">-1</span>\n\t<span class=\"hljs-keyword\">for</span> current := <span class=\"hljs-number\">1</span>; current &lt; <span class=\"hljs-built_in\">len</span>(stateIsTerminal); current++ {\n\t\to, parent := getParent(current, orTrie)\n\t\tdown := s[parent]\n\t\t<span class=\"hljs-keyword\">for</span> stateExists(down, orToReturn) &amp;&amp; getTransition(down, o, orToReturn) == <span class=\"hljs-number\">-1</span> {\n\t\t\tcreateTransition(down, o, current, orToReturn)\n\t\t\tdown = s[down]\n\t\t}\n\t\t<span class=\"hljs-keyword\">if</span> stateExists(down, orToReturn) {\n\t\t\ts[current] = getTransition(down, o, orToReturn)\n\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\ts[current] = i\n\t\t}\n\t}\n\t<span class=\"hljs-keyword\">return</span> orToReturn, f\n}\n\n<span class=\"hljs-comment\">// Function that constructs Trie as an automaton for a set of reversed &amp; trimmed strings.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">constructTrie</span><span class=\"hljs-params\">(p []<span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-params\">(trie <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">int</span>]<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">uint8</span>]<span class=\"hljs-keyword\">int</span>, stateIsTerminal []<span class=\"hljs-keyword\">bool</span>, f <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">int</span>][]<span class=\"hljs-keyword\">int</span>)</span></span> {\n\ttrie = <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">int</span>]<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">uint8</span>]<span class=\"hljs-keyword\">int</span>)\n\tstateIsTerminal = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">bool</span>, <span class=\"hljs-number\">1</span>)\n\tf = <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">int</span>][]<span class=\"hljs-keyword\">int</span>)\n\tstate := <span class=\"hljs-number\">1</span>\n\tcreateNewState(<span class=\"hljs-number\">0</span>, trie)\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(p); i++ {\n\t\tcurrent := <span class=\"hljs-number\">0</span>\n\t\tj := <span class=\"hljs-number\">0</span>\n\t\t<span class=\"hljs-keyword\">for</span> j &lt; <span class=\"hljs-built_in\">len</span>(p[i]) &amp;&amp; getTransition(current, p[i][j], trie) != <span class=\"hljs-number\">-1</span> {\n\t\t\tcurrent = getTransition(current, p[i][j], trie)\n\t\t\tj++\n\t\t}\n\t\t<span class=\"hljs-keyword\">for</span> j &lt; <span class=\"hljs-built_in\">len</span>(p[i]) {\n\t\t\tstateIsTerminal = boolArrayCapUp(stateIsTerminal)\n\t\t\tcreateNewState(state, trie)\n\t\t\tstateIsTerminal[state] = <span class=\"hljs-literal\">false</span>\n\t\t\tcreateTransition(current, p[i][j], state, trie)\n\t\t\tcurrent = state\n\t\t\tj++\n\t\t\tstate++\n\t\t}\n\t\t<span class=\"hljs-keyword\">if</span> stateIsTerminal[current] {\n\t\t\tnewArray := intArrayCapUp(f[current])\n\t\t\tnewArray[<span class=\"hljs-built_in\">len</span>(newArray)<span class=\"hljs-number\">-1</span>] = i\n\t\t\tf[current] = newArray <span class=\"hljs-comment\">//F(Current) &lt;- F(Current) union {i}</span>\n\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\tstateIsTerminal[current] = <span class=\"hljs-literal\">true</span>\n\t\t\tf[current] = []<span class=\"hljs-keyword\">int</span>{i} <span class=\"hljs-comment\">//F(Current) &lt;- {i}</span>\n\t\t}\n\t}\n\t<span class=\"hljs-keyword\">return</span> trie, stateIsTerminal, f\n}\n\n<span class=\"hljs-comment\">// Dynamically increases an array size of int&#x27;s by 1.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">intArrayCapUp</span><span class=\"hljs-params\">(old []<span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-params\">(<span class=\"hljs-built_in\">new</span> []<span class=\"hljs-keyword\">int</span>)</span></span> {\n\t<span class=\"hljs-built_in\">new</span> = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-built_in\">cap</span>(old)+<span class=\"hljs-number\">1</span>)\n\t<span class=\"hljs-built_in\">copy</span>(<span class=\"hljs-built_in\">new</span>, old) <span class=\"hljs-comment\">//copy(dst,src)</span>\n\t<span class=\"hljs-comment\">// old = new</span>\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">new</span>\n}\n\n<span class=\"hljs-comment\">// Dynamically increases an array size of bool&#x27;s by 1.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">boolArrayCapUp</span><span class=\"hljs-params\">(old []<span class=\"hljs-keyword\">bool</span>)</span> <span class=\"hljs-params\">(<span class=\"hljs-built_in\">new</span> []<span class=\"hljs-keyword\">bool</span>)</span></span> {\n\t<span class=\"hljs-built_in\">new</span> = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">bool</span>, <span class=\"hljs-built_in\">cap</span>(old)+<span class=\"hljs-number\">1</span>)\n\t<span class=\"hljs-built_in\">copy</span>(<span class=\"hljs-built_in\">new</span>, old)\n\t<span class=\"hljs-comment\">// old = new</span>\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">new</span>\n}\n\n<span class=\"hljs-comment\">// Function that takes an array of strings and reverses it.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">reverseAll</span><span class=\"hljs-params\">(s []<span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-params\">(reversed []<span class=\"hljs-keyword\">string</span>)</span></span> {\n\treversed = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">string</span>, <span class=\"hljs-built_in\">len</span>(s))\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(s); i++ {\n\t\treversed[i] = reverse(s[i])\n\t}\n\t<span class=\"hljs-keyword\">return</span> reversed\n}\n\n<span class=\"hljs-comment\">// Function that takes a single string and reverses it.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">reverse</span><span class=\"hljs-params\">(s <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-title\">string</span></span> {\n\tl := <span class=\"hljs-built_in\">len</span>(s)\n\tm := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">rune</span>, l)\n\t<span class=\"hljs-keyword\">for</span> _, c := <span class=\"hljs-keyword\">range</span> s {\n\t\tl--\n\t\tm[l] = c\n\t}\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">string</span>(m)\n}\n\n<span class=\"hljs-comment\">// Returns a prefix size &#x27;lmin&#x27; for one string &#x27;p&#x27; of first index found in &#x27;f&#x27;.</span>\n<span class=\"hljs-comment\">// It is not needed to compare all the strings from &#x27;p&#x27; indexed in &#x27;f&#x27;,</span>\n<span class=\"hljs-comment\">// thanks to the konwledge of &#x27;lmin&#x27;.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getCommonPrefix</span><span class=\"hljs-params\">(p []<span class=\"hljs-keyword\">string</span>, f []<span class=\"hljs-keyword\">int</span>, lmin <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">string</span></span> {\n\tr := []<span class=\"hljs-keyword\">rune</span>(p[f[<span class=\"hljs-number\">0</span>]])\n\tnewR := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">rune</span>, lmin)\n\t<span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; lmin; j++ {\n\t\tnewR[j] = r[j]\n\t}\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">string</span>(newR)\n}\n\n<span class=\"hljs-comment\">// Function that takes a set of strings &#x27;p&#x27; and their wanted &#x27;length&#x27;</span>\n<span class=\"hljs-comment\">// and then trims each string in that set to have desired &#x27;length&#x27;.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">trimToLength</span><span class=\"hljs-params\">(p []<span class=\"hljs-keyword\">string</span>, length <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-params\">(trimmedP []<span class=\"hljs-keyword\">string</span>)</span></span> {\n\ttrimmedP = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">string</span>, <span class=\"hljs-built_in\">len</span>(p))\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">range</span> p {\n\t\tr := []<span class=\"hljs-keyword\">rune</span>(p[i])\n\t\tnewR := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">rune</span>, length)\n\t\t<span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; length; j++ {\n\t\t\tnewR[j] = r[j]\n\t\t}\n\t\ttrimmedP[i] = <span class=\"hljs-keyword\">string</span>(newR)\n\t}\n\t<span class=\"hljs-keyword\">return</span> trimmedP\n}\n\n<span class=\"hljs-comment\">// Function that returns word found in text &#x27;t&#x27; at position range &#x27;begin&#x27; to &#x27;end&#x27;.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getWord</span><span class=\"hljs-params\">(begin, end <span class=\"hljs-keyword\">int</span>, t <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-title\">string</span></span> {\n\t<span class=\"hljs-keyword\">for</span> end &gt;= <span class=\"hljs-built_in\">len</span>(t) {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>\n\t}\n\td := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">uint8</span>, end-begin+<span class=\"hljs-number\">1</span>)\n\t<span class=\"hljs-keyword\">for</span> j, i := <span class=\"hljs-number\">0</span>, begin; i &lt;= end; i, j = i+<span class=\"hljs-number\">1</span>, j+<span class=\"hljs-number\">1</span> {\n\t\td[j] = t[i]\n\t}\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">string</span>(d)\n}\n\n<span class=\"hljs-comment\">// Function that computes minimal length string in a set of strings.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">computeMinLength</span><span class=\"hljs-params\">(p []<span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-params\">(lmin <span class=\"hljs-keyword\">int</span>)</span></span> {\n\tlmin = <span class=\"hljs-built_in\">len</span>(p[<span class=\"hljs-number\">0</span>])\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt; <span class=\"hljs-built_in\">len</span>(p); i++ {\n\t\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(p[i]) &lt; lmin {\n\t\t\tlmin = <span class=\"hljs-built_in\">len</span>(p[i])\n\t\t}\n\t}\n\t<span class=\"hljs-keyword\">return</span> lmin\n}\n\n<span class=\"hljs-comment\">// Function that finds the first previous state of a state and returns it.</span>\n<span class=\"hljs-comment\">// Used for trie where there is only one parent.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getParent</span><span class=\"hljs-params\">(state <span class=\"hljs-keyword\">int</span>, at <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">int</span>]<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">uint8</span>]<span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">uint8</span>, <span class=\"hljs-keyword\">int</span>)</span></span> {\n\t<span class=\"hljs-keyword\">for</span> beginState, transitions := <span class=\"hljs-keyword\">range</span> at {\n\t\t<span class=\"hljs-keyword\">for</span> c, endState := <span class=\"hljs-keyword\">range</span> transitions {\n\t\t\t<span class=\"hljs-keyword\">if</span> endState == state {\n\t\t\t\t<span class=\"hljs-keyword\">return</span> c, beginState\n\t\t\t}\n\t\t}\n\t}\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">//unreachable</span>\n}\n\n<span class=\"hljs-comment\">// Automaton function for creating a new state &#x27;state&#x27;.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">createNewState</span><span class=\"hljs-params\">(state <span class=\"hljs-keyword\">int</span>, at <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">int</span>]<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">uint8</span>]<span class=\"hljs-keyword\">int</span>)</span></span> {\n\tat[state] = <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">uint8</span>]<span class=\"hljs-keyword\">int</span>)\n}\n\n<span class=\"hljs-comment\">// Creates a transition for function σ(state,letter) = end.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">createTransition</span><span class=\"hljs-params\">(fromState <span class=\"hljs-keyword\">int</span>, overChar <span class=\"hljs-keyword\">uint8</span>, toState <span class=\"hljs-keyword\">int</span>, at <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">int</span>]<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">uint8</span>]<span class=\"hljs-keyword\">int</span>)</span></span> {\n\tat[fromState][overChar] = toState\n}\n\n<span class=\"hljs-comment\">// Returns ending state for transition σ(fromState,overChar), &#x27;-1&#x27; if there is none.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getTransition</span><span class=\"hljs-params\">(fromState <span class=\"hljs-keyword\">int</span>, overChar <span class=\"hljs-keyword\">uint8</span>, at <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">int</span>]<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">uint8</span>]<span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-params\">(toState <span class=\"hljs-keyword\">int</span>)</span></span> {\n\t<span class=\"hljs-keyword\">if</span> !stateExists(fromState, at) {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>\n\t}\n\ttoState, ok := at[fromState][overChar]\n\t<span class=\"hljs-keyword\">if</span> ok {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>\n\t}\n\t<span class=\"hljs-keyword\">return</span> toState\n}\n\n<span class=\"hljs-comment\">// Checks if state &#x27;state&#x27; exists. Returns &#x27;true&#x27; if it does, &#x27;false&#x27; otherwise.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">stateExists</span><span class=\"hljs-params\">(state <span class=\"hljs-keyword\">int</span>, at <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">int</span>]<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">uint8</span>]<span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n\t_, ok := at[state]\n\t<span class=\"hljs-keyword\">if</span> !ok || state == <span class=\"hljs-number\">-1</span> || at[state] == <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n\t}\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n}\n"
    }
  },
  "contributors": [
    {
      "name": "halafi",
      "email": "filiphalas74@gmail.com",
      "commits": 1
    },
    {
      "name": "Taj",
      "email": "tjgurwara99@users.noreply.github.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}
