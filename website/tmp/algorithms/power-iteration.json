{
  "slug": "power-iteration",
  "name": "Power Iteration",
  "categories": ["linearalgebra", "src"],
  "body": {},
  "implementations": {
    "python": {
      "dir": "linear_algebra/src/power_iteration.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/linear_algebra/src/power_iteration.py",
      "code": "<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">power_iteration</span>(<span class=\"hljs-params\">\n    input_matrix: np.ndarray,\n    vector: np.ndarray,\n    error_tol: <span class=\"hljs-built_in\">float</span> = <span class=\"hljs-number\">1e-12</span>,\n    max_iterations: <span class=\"hljs-built_in\">int</span> = <span class=\"hljs-number\">100</span>,\n</span>) -&gt; <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">float</span>, np.ndarray]:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Power Iteration.\n    Find the largest eignevalue and corresponding eigenvector\n    of matrix input_matrix given a random vector in the same space.\n    Will work so long as vector has component of largest eigenvector.\n    input_matrix must be symmetric.\n\n    Input\n    input_matrix: input matrix whose largest eigenvalue we will find.\n    Numpy array. np.shape(input_matrix) == (N,N).\n    vector: random initial vector in same space as matrix.\n    Numpy array. np.shape(vector) == (N,) or (N,1)\n\n    Output\n    largest_eigenvalue: largest eigenvalue of the matrix input_matrix.\n    Float. Scalar.\n    largest_eigenvector: eigenvector corresponding to largest_eigenvalue.\n    Numpy array. np.shape(largest_eigenvector) == (N,) or (N,1).\n\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; input_matrix = np.array([\n    ... [41,  4, 20],\n    ... [ 4, 26, 30],\n    ... [20, 30, 50]\n    ... ])\n    &gt;&gt;&gt; vector = np.array([41,4,20])\n    &gt;&gt;&gt; power_iteration(input_matrix,vector)\n    (79.66086378788381, array([0.44472726, 0.46209842, 0.76725662]))\n    &quot;&quot;&quot;</span>\n\n    <span class=\"hljs-comment\"># Ensure matrix is square.</span>\n    <span class=\"hljs-keyword\">assert</span> np.shape(input_matrix)[<span class=\"hljs-number\">0</span>] == np.shape(input_matrix)[<span class=\"hljs-number\">1</span>]\n    <span class=\"hljs-comment\"># Ensure proper dimensionality.</span>\n    <span class=\"hljs-keyword\">assert</span> np.shape(input_matrix)[<span class=\"hljs-number\">0</span>] == np.shape(vector)[<span class=\"hljs-number\">0</span>]\n\n    <span class=\"hljs-comment\"># Set convergence to False. Will define convergence when we exceed max_iterations</span>\n    <span class=\"hljs-comment\"># or when we have small changes from one iteration to next.</span>\n\n    convergence = <span class=\"hljs-literal\">False</span>\n    lamda_previous = <span class=\"hljs-number\">0</span>\n    iterations = <span class=\"hljs-number\">0</span>\n    error = <span class=\"hljs-number\">1e12</span>\n\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">not</span> convergence:\n        <span class=\"hljs-comment\"># Multiple matrix by the vector.</span>\n        w = np.dot(input_matrix, vector)\n        <span class=\"hljs-comment\"># Normalize the resulting output vector.</span>\n        vector = w / np.linalg.norm(w)\n        <span class=\"hljs-comment\"># Find rayleigh quotient</span>\n        <span class=\"hljs-comment\"># (faster than usual b/c we know vector is normalized already)</span>\n        lamda = np.dot(vector.T, np.dot(input_matrix, vector))\n\n        <span class=\"hljs-comment\"># Check convergence.</span>\n        error = np.<span class=\"hljs-built_in\">abs</span>(lamda - lamda_previous) / lamda\n        iterations += <span class=\"hljs-number\">1</span>\n\n        <span class=\"hljs-keyword\">if</span> error &lt;= error_tol <span class=\"hljs-keyword\">or</span> iterations &gt;= max_iterations:\n            convergence = <span class=\"hljs-literal\">True</span>\n\n        lamda_previous = lamda\n\n    <span class=\"hljs-keyword\">return</span> lamda, vector\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">test_power_iteration</span>() -&gt; <span class=\"hljs-literal\">None</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    &gt;&gt;&gt; test_power_iteration()  # self running tests\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-comment\"># Our implementation.</span>\n    input_matrix = np.array([[<span class=\"hljs-number\">41</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">20</span>], [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">26</span>, <span class=\"hljs-number\">30</span>], [<span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">50</span>]])\n    vector = np.array([<span class=\"hljs-number\">41</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">20</span>])\n    eigen_value, eigen_vector = power_iteration(input_matrix, vector)\n\n    <span class=\"hljs-comment\"># Numpy implementation.</span>\n\n    <span class=\"hljs-comment\"># Get eigen values and eigen vectors using built in numpy</span>\n    <span class=\"hljs-comment\"># eigh (eigh used for symmetric or hermetian matrices).</span>\n    eigen_values, eigen_vectors = np.linalg.eigh(input_matrix)\n    <span class=\"hljs-comment\"># Last eigen value is the maximum one.</span>\n    eigen_value_max = eigen_values[-<span class=\"hljs-number\">1</span>]\n    <span class=\"hljs-comment\"># Last column in this matrix is eigen vector corresponding to largest eigen value.</span>\n    eigen_vector_max = eigen_vectors[:, -<span class=\"hljs-number\">1</span>]\n\n    <span class=\"hljs-comment\"># Check our implementation and numpy gives close answers.</span>\n    <span class=\"hljs-keyword\">assert</span> np.<span class=\"hljs-built_in\">abs</span>(eigen_value - eigen_value_max) &lt;= <span class=\"hljs-number\">1e-6</span>\n    <span class=\"hljs-comment\"># Take absolute values element wise of each eigenvector.</span>\n    <span class=\"hljs-comment\"># as they are only unique to a minus sign.</span>\n    <span class=\"hljs-keyword\">assert</span> np.linalg.norm(np.<span class=\"hljs-built_in\">abs</span>(eigen_vector) - np.<span class=\"hljs-built_in\">abs</span>(eigen_vector_max)) &lt;= <span class=\"hljs-number\">1e-6</span>\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    <span class=\"hljs-keyword\">import</span> doctest\n\n    doctest.testmod()\n    test_power_iteration()\n"
    },
    "c-sharp": {
      "dir": "Algorithms/LinearAlgebra/Eigenvalue/PowerIteration.cs",
      "url": "https://github.com/TheAlgorithms/C-Sharp/blob/master/Algorithms/LinearAlgebra/Eigenvalue/PowerIteration.cs",
      "code": "<span class=\"hljs-keyword\">using</span> System;\n<span class=\"hljs-keyword\">using</span> System.Linq;\n<span class=\"hljs-keyword\">using</span> Utilities.Extensions;\n\n<span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">Algorithms.LinearAlgebra.Eigenvalue</span>\n{\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Power iteration method - eigenvalue numeric algorithm, based on recurrent relation:</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Li+1 = (A * Li) / || A * Li ||, where Li - eigenvector approximation.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PowerIteration</span>\n    {\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Returns approximation of the dominant eigenvalue and eigenvector of <span class=\"hljs-doctag\">&lt;paramref name=&quot;source&quot; /&gt;</span> matrix.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;list type=&quot;bullet&quot;&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;item&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         <span class=\"hljs-doctag\">&lt;description&gt;</span>The algorithm will not converge if the start vector is orthogonal to the eigenvector.<span class=\"hljs-doctag\">&lt;/description&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;/item&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;item&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         <span class=\"hljs-doctag\">&lt;description&gt;</span>The <span class=\"hljs-doctag\">&lt;paramref name=&quot;source&quot; /&gt;</span> matrix must be square-shaped.<span class=\"hljs-doctag\">&lt;/description&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;/item&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/list&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;source&quot;&gt;</span>Source square-shaped matrix.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;startVector&quot;&gt;</span>Start vector.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;error&quot;&gt;</span>Accuracy of the result.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Dominant eigenvalue and eigenvector pair.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;exception cref=&quot;ArgumentException&quot;&gt;</span>The <span class=\"hljs-doctag\">&lt;paramref name=&quot;source&quot; /&gt;</span> matrix is not square-shaped.<span class=\"hljs-doctag\">&lt;/exception&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;exception cref=&quot;ArgumentException&quot;&gt;</span>The length of the start vector doesn&#x27;t equal the size of the source matrix.<span class=\"hljs-doctag\">&lt;/exception&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> (<span class=\"hljs-params\"><span class=\"hljs-built_in\">double</span> eigenvalue, <span class=\"hljs-built_in\">double</span>[] eigenvector</span>) <span class=\"hljs-title\">Dominant</span>(<span class=\"hljs-params\">\n            <span class=\"hljs-built_in\">double</span>[,] source,\n            <span class=\"hljs-built_in\">double</span>[] startVector,\n            <span class=\"hljs-built_in\">double</span> error = <span class=\"hljs-number\">0.00001</span></span>)</span>\n        {\n            <span class=\"hljs-keyword\">if</span> (source.GetLength(<span class=\"hljs-number\">0</span>) != source.GetLength(<span class=\"hljs-number\">1</span>))\n            {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ArgumentException(<span class=\"hljs-string\">&quot;The source matrix is not square-shaped.&quot;</span>);\n            }\n\n            <span class=\"hljs-keyword\">if</span> (source.GetLength(<span class=\"hljs-number\">0</span>) != startVector.Length)\n            {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ArgumentException(\n                    <span class=\"hljs-string\">&quot;The length of the start vector doesn&#x27;t equal the size of the source matrix.&quot;</span>);\n            }\n\n            <span class=\"hljs-built_in\">double</span> eigenNorm;\n            <span class=\"hljs-built_in\">double</span>[] previousEigenVector;\n            <span class=\"hljs-built_in\">double</span>[] currentEigenVector = startVector;\n\n            <span class=\"hljs-keyword\">do</span>\n            {\n                previousEigenVector = currentEigenVector;\n                currentEigenVector = source.Multiply(\n                        previousEigenVector.ToColumnVector())\n                    .ToRowVector();\n\n                eigenNorm = currentEigenVector.Magnitude();\n                currentEigenVector = currentEigenVector.Select(x =&gt; x / eigenNorm).ToArray();\n            }\n            <span class=\"hljs-keyword\">while</span> (Math.Abs(currentEigenVector.Dot(previousEigenVector)) &lt; <span class=\"hljs-number\">1.0</span> - error);\n\n            <span class=\"hljs-keyword\">var</span> eigenvalue = source.Multiply(currentEigenVector.ToColumnVector()).ToRowVector().Magnitude();\n\n            <span class=\"hljs-keyword\">return</span> (eigenvalue, eigenvector: currentEigenVector);\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Returns approximation of the dominant eigenvalue and eigenvector of <span class=\"hljs-doctag\">&lt;paramref name=&quot;source&quot; /&gt;</span> matrix.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Random normalized vector is used as the start vector to decrease chance of orthogonality to the eigenvector.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;list type=&quot;bullet&quot;&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;item&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         <span class=\"hljs-doctag\">&lt;description&gt;</span>The algorithm will not converge if the start vector is orthogonal to the eigenvector.<span class=\"hljs-doctag\">&lt;/description&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;/item&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;item&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         <span class=\"hljs-doctag\">&lt;description&gt;</span>The <span class=\"hljs-doctag\">&lt;paramref name=&quot;source&quot; /&gt;</span> matrix should be square-shaped.<span class=\"hljs-doctag\">&lt;/description&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;/item&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/list&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;source&quot;&gt;</span>Source square-shaped matrix.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;error&quot;&gt;</span>Accuracy of the result.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Dominant eigenvalue and eigenvector pair.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;exception cref=&quot;ArgumentException&quot;&gt;</span>The <span class=\"hljs-doctag\">&lt;paramref name=&quot;source&quot; /&gt;</span> matrix is not square-shaped.<span class=\"hljs-doctag\">&lt;/exception&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;exception cref=&quot;ArgumentException&quot;&gt;</span>The length of the start vector doesn&#x27;t equal the size of the source matrix.<span class=\"hljs-doctag\">&lt;/exception&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> (<span class=\"hljs-params\"><span class=\"hljs-built_in\">double</span> eigenvalue, <span class=\"hljs-built_in\">double</span>[] eigenvector</span>) <span class=\"hljs-title\">Dominant</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">double</span>[,] source, <span class=\"hljs-built_in\">double</span> error = <span class=\"hljs-number\">0.00001</span></span>)</span> =&gt;\n            Dominant(source, <span class=\"hljs-keyword\">new</span> Random().NextVector(source.GetLength(<span class=\"hljs-number\">1</span>)), error);\n    }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Anton Kozyriev",
      "email": "sonara4mus@gmail.com",
      "commits": 1
    },
    {
      "name": "Dhruv Manilawala",
      "email": "dhruvmanila@gmail.com",
      "commits": 1
    },
    {
      "name": "zakademic",
      "email": "67771932+zakademic@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Andrii Siriak",
      "email": "siryaka@gmail.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}
