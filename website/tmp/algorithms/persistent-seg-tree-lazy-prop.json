{
  "slug": "persistent-seg-tree-lazy-prop",
  "name": "Persistent Seg Tree Lazy Prop",
  "categories": ["rangequeries"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "range_queries/persistent_seg_tree_lazy_prop.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/range_queries/persistent_seg_tree_lazy_prop.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * @brief [Persistent segment tree with range updates (lazy\n * propagation)](https://en.wikipedia.org/wiki/Persistent_data_structure)\n *\n * @details\n * A normal segment tree facilitates making point updates and range queries in\n * logarithmic time. Lazy propagation preserves the logarithmic time with range\n * updates. So, a segment tree with lazy propagation enables doing range updates\n * and range queries in logarithmic time, but it doesn&#x27;t save any information\n * about itself before the last update. A persistent data structure always\n * preserves the previous version of itself when it is modified. That is, a new\n * version of the segment tree is generated after every update. It saves all\n * previous versions of itself (before every update) to facilitate doing range\n * queries in any version. More memory is used ,but the logarithmic time is\n * preserved because the new version points to the same nodes, that the previous\n * version points to, that are not affected by the update. That is, only the\n * nodes that are affected by the update and their ancestors are copied. The\n * rest is copied using lazy propagation in the next queries. Thus preserving\n * the logarithmic time because the number of nodes copied after any update is\n * logarithmic.\n *\n * @author [Magdy Sedra](https://github.com/MSedra)\n */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>  <span class=\"hljs-comment\">/// for IO operations</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;memory&gt;</span>    <span class=\"hljs-comment\">/// to manage dynamic memory</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>    <span class=\"hljs-comment\">/// for std::vector</span></span>\n\n<span class=\"hljs-comment\">/**\n * @namespace range_queries\n * @brief Range queries algorithms\n */</span>\n<span class=\"hljs-keyword\">namespace</span> range_queries {\n\n<span class=\"hljs-comment\">/**\n * @brief Range query here is range sum, but the code can be modified to make\n * different queries like range max or min.\n */</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">perSegTree</span> {\n <span class=\"hljs-keyword\">private</span>:\n    <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Node</span> {\n     <span class=\"hljs-keyword\">public</span>:\n        std::shared_ptr&lt;Node&gt; left = <span class=\"hljs-literal\">nullptr</span>;   <span class=\"hljs-comment\">/// pointer to the left node</span>\n        std::shared_ptr&lt;Node&gt; right = <span class=\"hljs-literal\">nullptr</span>;  <span class=\"hljs-comment\">/// pointer to the right node</span>\n        <span class=\"hljs-type\">int64_t</span> val = <span class=\"hljs-number\">0</span>,\n                prop = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">/// val is the value of the node (here equals to the</span>\n                           <span class=\"hljs-comment\">/// sum of the leaf nodes children of that node),</span>\n                           <span class=\"hljs-comment\">/// prop is the value to be propagated/added to all</span>\n                           <span class=\"hljs-comment\">/// the leaf nodes children of that node</span>\n    };\n\n    <span class=\"hljs-type\">uint32_t</span> n = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">/// number of elements/leaf nodes in the segment tree</span>\n    std::vector&lt;std::shared_ptr&lt;Node&gt;&gt;\n        ptrs{};  <span class=\"hljs-comment\">/// ptrs[i] holds a root pointer to the segment tree after the</span>\n                 <span class=\"hljs-comment\">/// ith update. ptrs[0] holds a root pointer to the segment</span>\n                 <span class=\"hljs-comment\">/// tree before any updates</span>\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; vec{};  <span class=\"hljs-comment\">/// values of the leaf nodes that the segment</span>\n                                 <span class=\"hljs-comment\">/// tree will be constructed with</span>\n\n    <span class=\"hljs-comment\">/**\n     * @brief Creating a new node with the same values of curr node\n     * @param curr node that would be copied\n     * @returns the new node\n     */</span>\n    <span class=\"hljs-function\">std::shared_ptr&lt;Node&gt; <span class=\"hljs-title\">newKid</span><span class=\"hljs-params\">(std::shared_ptr&lt;Node&gt; <span class=\"hljs-keyword\">const</span> &amp;curr)</span> </span>{\n        <span class=\"hljs-keyword\">auto</span> newNode = std::<span class=\"hljs-built_in\">make_shared</span>&lt;Node&gt;(<span class=\"hljs-built_in\">Node</span>());\n        newNode-&gt;left = curr-&gt;left;\n        newNode-&gt;right = curr-&gt;right;\n        newNode-&gt;prop = curr-&gt;prop;\n        newNode-&gt;val = curr-&gt;val;\n        <span class=\"hljs-keyword\">return</span> newNode;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief If there is some value to be propagated to the passed node, value\n     * is added to the node and the children of the node, if exist, are copied\n     * and the propagated value is also added to them\n     * @param i the left index of the range that the passed node holds its sum\n     * @param j the right index of the range that the passed node holds its sum\n     * @param curr pointer to the node to be propagated\n     * @returns void\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">lazy</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;i, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;j,\n              std::shared_ptr&lt;Node&gt; <span class=\"hljs-keyword\">const</span> &amp;curr)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (!curr-&gt;prop) {\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        curr-&gt;val += (j - i + <span class=\"hljs-number\">1</span>) * curr-&gt;prop;\n        <span class=\"hljs-keyword\">if</span> (i != j) {\n            curr-&gt;left = <span class=\"hljs-built_in\">newKid</span>(curr-&gt;left);\n            curr-&gt;right = <span class=\"hljs-built_in\">newKid</span>(curr-&gt;right);\n            curr-&gt;left-&gt;prop += curr-&gt;prop;\n            curr-&gt;right-&gt;prop += curr-&gt;prop;\n        }\n        curr-&gt;prop = <span class=\"hljs-number\">0</span>;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Constructing the segment tree with the early passed vector. Every\n     * call creates a node to hold the sum of the given range, set its pointers\n     * to the children, and set its value to the sum of the children&#x27;s values\n     * @param i the left index of the range that the created node holds its sum\n     * @param j the right index of the range that the created node holds its sum\n     * @returns pointer to the newly created node\n     */</span>\n    <span class=\"hljs-function\">std::shared_ptr&lt;Node&gt; <span class=\"hljs-title\">construct</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;i, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;j)</span> </span>{\n        <span class=\"hljs-keyword\">auto</span> newNode = std::<span class=\"hljs-built_in\">make_shared</span>&lt;Node&gt;(<span class=\"hljs-built_in\">Node</span>());\n        <span class=\"hljs-keyword\">if</span> (i == j) {\n            newNode-&gt;val = vec[i];\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-type\">uint32_t</span> mid = i + (j - i) / <span class=\"hljs-number\">2</span>;\n            <span class=\"hljs-keyword\">auto</span> leftt = <span class=\"hljs-built_in\">construct</span>(i, mid);\n            <span class=\"hljs-keyword\">auto</span> right = <span class=\"hljs-built_in\">construct</span>(mid + <span class=\"hljs-number\">1</span>, j);\n            newNode-&gt;val = leftt-&gt;val + right-&gt;val;\n            newNode-&gt;left = leftt;\n            newNode-&gt;right = right;\n        }\n        <span class=\"hljs-keyword\">return</span> newNode;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Doing range update, checking at every node if it has some value to\n     * be propagated. All nodes affected by the update are copied and\n     * propagation value is added to the leaf of them\n     * @param i the left index of the range that the passed node holds its sum\n     * @param j the right index of the range that the passed node holds its sum\n     * @param l the left index of the range to be updated\n     * @param r the right index of the range to be updated\n     * @param value the value to be added to every element whose index x\n     * satisfies l&lt;=x&lt;=r\n     * @param curr pointer to the current node, which has value = the sum of\n     * elements whose index x satisfies i&lt;=x&lt;=j\n     * @returns pointer to the current newly created node\n     */</span>\n    <span class=\"hljs-function\">std::shared_ptr&lt;Node&gt; <span class=\"hljs-title\">update</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;i, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;j,\n                                 <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;l, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;r,\n                                 <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int64_t</span> &amp;value,\n                                 std::shared_ptr&lt;Node&gt; <span class=\"hljs-keyword\">const</span> &amp;curr)</span> </span>{\n        <span class=\"hljs-built_in\">lazy</span>(i, j, curr);\n        <span class=\"hljs-keyword\">if</span> (i &gt;= l &amp;&amp; j &lt;= r) {\n            std::shared_ptr&lt;Node&gt; newNode = <span class=\"hljs-built_in\">newKid</span>(curr);\n            newNode-&gt;prop += value;\n            <span class=\"hljs-built_in\">lazy</span>(i, j, newNode);\n            <span class=\"hljs-keyword\">return</span> newNode;\n        }\n        <span class=\"hljs-keyword\">if</span> (i &gt; r || j &lt; l) {\n            <span class=\"hljs-keyword\">return</span> curr;\n        }\n        <span class=\"hljs-keyword\">auto</span> newNode = std::<span class=\"hljs-built_in\">make_shared</span>&lt;Node&gt;(<span class=\"hljs-built_in\">Node</span>());\n        <span class=\"hljs-type\">uint32_t</span> mid = i + (j - i) / <span class=\"hljs-number\">2</span>;\n        newNode-&gt;left = <span class=\"hljs-built_in\">update</span>(i, mid, l, r, value, curr-&gt;left);\n        newNode-&gt;right = <span class=\"hljs-built_in\">update</span>(mid + <span class=\"hljs-number\">1</span>, j, l, r, value, curr-&gt;right);\n        newNode-&gt;val = newNode-&gt;left-&gt;val + newNode-&gt;right-&gt;val;\n        <span class=\"hljs-keyword\">return</span> newNode;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Querying the range from index l to index r, checking at every node\n     * if it has some value to be propagated. Current node&#x27;s value is returned\n     * if its range is completely inside the wanted range, else 0 is returned\n     * @param i the left index of the range that the passed node holds its sum\n     * @param j the right index of the range that the passed node holds its sum\n     * @param l the left index of the range whose sum should be returned as a\n     * result\n     * @param r the right index of the range whose sum should be returned as a\n     * result\n     * @param curr pointer to the current node, which has value = the sum of\n     * elements whose index x satisfies i&lt;=x&lt;=j\n     * @returns sum of elements whose index x satisfies l&lt;=x&lt;=r\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title\">query</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;i, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;j, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;l,\n                  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;r, std::shared_ptr&lt;Node&gt; <span class=\"hljs-keyword\">const</span> &amp;curr)</span> </span>{\n        <span class=\"hljs-built_in\">lazy</span>(i, j, curr);\n        <span class=\"hljs-keyword\">if</span> (j &lt; l || r &lt; i) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n        }\n        <span class=\"hljs-keyword\">if</span> (i &gt;= l &amp;&amp; j &lt;= r) {\n            <span class=\"hljs-keyword\">return</span> curr-&gt;val;\n        }\n        <span class=\"hljs-type\">uint32_t</span> mid = i + (j - i) / <span class=\"hljs-number\">2</span>;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">query</span>(i, mid, l, r, curr-&gt;left) +\n               <span class=\"hljs-built_in\">query</span>(mid + <span class=\"hljs-number\">1</span>, j, l, r, curr-&gt;right);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * public methods that can be used directly from outside the class. They\n     * call the private functions that do all the work\n     */</span>\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-comment\">/**\n     * @brief Constructing the segment tree with the values in the passed\n     * vector. Returned root pointer is pushed in the pointers vector to have\n     * access to the original version if the segment tree is updated\n     * @param vec vector whose values will be used to build the segment tree\n     * @returns void\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">construct</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt;\n                       &amp;vec)</span>  <span class=\"hljs-comment\">// the segment tree will be built from the values</span>\n                              <span class=\"hljs-comment\">// in &quot;vec&quot;, &quot;vec&quot; is 0 indexed</span>\n    </span>{\n        <span class=\"hljs-keyword\">if</span> (vec.<span class=\"hljs-built_in\">empty</span>()) {\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        n = vec.<span class=\"hljs-built_in\">size</span>();\n        <span class=\"hljs-keyword\">this</span>-&gt;vec = vec;\n        <span class=\"hljs-keyword\">auto</span> root = <span class=\"hljs-built_in\">construct</span>(<span class=\"hljs-number\">0</span>, n - <span class=\"hljs-number\">1</span>);\n        ptrs.<span class=\"hljs-built_in\">push_back</span>(root);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Doing range update by passing the left and right indexes of the\n     * range as well as the value to be added.\n     * @param l the left index of the range to be updated\n     * @param r the right index of the range to be updated\n     * @param value the value to be added to every element whose index x\n     * satisfies l&lt;=x&lt;=r\n     * @returns void\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">update</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;l, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;r,\n                <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int64_t</span>\n                    &amp;value)</span>  <span class=\"hljs-comment\">// all elements from index &quot;l&quot; to index &quot;r&quot; would</span>\n                             <span class=\"hljs-comment\">// by updated by &quot;value&quot;, &quot;l&quot; and &quot;r&quot; are 0 indexed</span>\n    </span>{\n        ptrs.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-built_in\">update</span>(\n            <span class=\"hljs-number\">0</span>, n - <span class=\"hljs-number\">1</span>, l, r, value,\n            ptrs[ptrs.<span class=\"hljs-built_in\">size</span>() -\n                 <span class=\"hljs-number\">1</span>]));  <span class=\"hljs-comment\">// saving the root pointer to the new segment tree</span>\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Querying the range from index l to index r, getting the sum of the\n     * elements whose index x satisfies l&lt;=x&lt;=r\n     * @param l the left index of the range whose sum should be returned as a\n     * result\n     * @param r the right index of the range whose sum should be returned as a\n     * result\n     * @param version the version to query on. If equals to 0, the original\n     * segment tree will be queried\n     * @returns sum of elements whose index x satisfies l&lt;=x&lt;=r\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title\">query</span><span class=\"hljs-params\">(\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;l, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">uint32_t</span> &amp;r,\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">uint32_t</span>\n            &amp;version)</span>  <span class=\"hljs-comment\">// querying the range from &quot;l&quot; to &quot;r&quot; in a segment tree</span>\n                       <span class=\"hljs-comment\">// after &quot;version&quot; updates, &quot;l&quot; and &quot;r&quot; are 0 indexed</span>\n    </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">query</span>(<span class=\"hljs-number\">0</span>, n - <span class=\"hljs-number\">1</span>, l, r, ptrs[version]);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Getting the number of versions after updates so far which is equal\n     * to the size of the pointers vector\n     * @returns the number of versions\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span>  <span class=\"hljs-comment\">// returns the number of segment trees (versions) , the</span>\n                     <span class=\"hljs-comment\">// number of updates done so far = returned value - 1</span>\n                     <span class=\"hljs-comment\">// ,because one of the trees is the original segment tree</span>\n    </span>{\n        <span class=\"hljs-keyword\">return</span> ptrs.<span class=\"hljs-built_in\">size</span>();\n    }\n};\n}  <span class=\"hljs-comment\">// namespace range_queries</span>\n\n<span class=\"hljs-comment\">/**\n * @brief Test implementations\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; arr = {<span class=\"hljs-number\">-5</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">-2</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>};\n    range_queries::perSegTree tree;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Elements before any updates are {&quot;</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.<span class=\"hljs-built_in\">size</span>(); ++i) {\n        std::cout &lt;&lt; arr[i];\n        <span class=\"hljs-keyword\">if</span> (i != arr.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>) {\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span>;\n        }\n    }\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;}\\n&quot;</span>;\n    tree.<span class=\"hljs-built_in\">construct</span>(\n        arr);  <span class=\"hljs-comment\">// constructing the original segment tree (version = 0)</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Querying range sum on version 0 from index 2 to 4 = 3+11-2 = &quot;</span>\n              &lt;&lt; tree.<span class=\"hljs-built_in\">query</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>) &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;\n    std::cout\n        &lt;&lt; <span class=\"hljs-string\">&quot;Subtract 7 from all elements from index 1 to index 5 inclusive\\n&quot;</span>;\n    tree.<span class=\"hljs-built_in\">update</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">-7</span>);  <span class=\"hljs-comment\">// subtracting 7 from index 1 to index 5</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Elements of the segment tree whose version = 1 (after 1 &quot;</span>\n                 <span class=\"hljs-string\">&quot;update) are {&quot;</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.<span class=\"hljs-built_in\">size</span>(); ++i) {\n        std::cout &lt;&lt; tree.<span class=\"hljs-built_in\">query</span>(i, i, <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-keyword\">if</span> (i != arr.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>) {\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span>;\n        }\n    }\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;}\\n&quot;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Add 10 to all elements from index 0 to index 7 inclusive\\n&quot;</span>;\n    tree.<span class=\"hljs-built_in\">update</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">10</span>);  <span class=\"hljs-comment\">// adding 10 to all elements</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Elements of the segment tree whose version = 2 (after 2 &quot;</span>\n                 <span class=\"hljs-string\">&quot;updates) are {&quot;</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.<span class=\"hljs-built_in\">size</span>(); ++i) {\n        std::cout &lt;&lt; tree.<span class=\"hljs-built_in\">query</span>(i, i, <span class=\"hljs-number\">2</span>);\n        <span class=\"hljs-keyword\">if</span> (i != arr.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>) {\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span>;\n        }\n    }\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;}\\n&quot;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Number of segment trees (versions) now = &quot;</span> &lt;&lt; tree.<span class=\"hljs-built_in\">size</span>()\n              &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Querying range sum on version 0 from index 3 to 5 = 11-2+7 = &quot;</span>\n              &lt;&lt; tree.<span class=\"hljs-built_in\">query</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">0</span>) &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Querying range sum on version 1 from index 3 to 5 = 4-9+0 = &quot;</span>\n              &lt;&lt; tree.<span class=\"hljs-built_in\">query</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">1</span>) &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Main function\n * @returns 0 on exit\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">// run self-test implementations</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Magdy Sedra",
      "email": "62825437+MSedra@users.noreply.github.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}
