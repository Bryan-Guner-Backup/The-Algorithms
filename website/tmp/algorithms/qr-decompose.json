{
  "slug": "qr-decompose",
  "name": "Qr Decompose",
  "categories": ["numericalmethods"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "numerical_methods/qr_decompose.h",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/numerical_methods/qr_decompose.h",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * \\brief Library functions to compute [QR\n * decomposition](https://en.wikipedia.org/wiki/QR_decomposition) of a given\n * matrix.\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> NUMERICAL_METHODS_QR_DECOMPOSE_H_</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> NUMERICAL_METHODS_QR_DECOMPOSE_H_</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdlib&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iomanip&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;limits&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;numeric&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;valarray&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;omp.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n<span class=\"hljs-comment\">/** \\namespace qr_algorithm\n * \\brief Functions to compute [QR\n * decomposition](https://en.wikipedia.org/wiki/QR_decomposition) of any\n * rectangular matrix\n */</span>\n<span class=\"hljs-keyword\">namespace</span> qr_algorithm {\n<span class=\"hljs-comment\">/**\n * operator to print a matrix\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::ostream &amp;<span class=\"hljs-keyword\">operator</span>&lt;&lt;(std::ostream &amp;out,\n                         std::valarray&lt;std::valarray&lt;T&gt;&gt; <span class=\"hljs-keyword\">const</span> &amp;v) {\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> width = <span class=\"hljs-number\">12</span>;\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> separator = <span class=\"hljs-string\">&#x27; &#x27;</span>;\n\n    out.<span class=\"hljs-built_in\">precision</span>(<span class=\"hljs-number\">4</span>);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row = <span class=\"hljs-number\">0</span>; row &lt; v.<span class=\"hljs-built_in\">size</span>(); row++) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> col = <span class=\"hljs-number\">0</span>; col &lt; v[row].<span class=\"hljs-built_in\">size</span>(); col++)\n            out &lt;&lt; std::right &lt;&lt; std::<span class=\"hljs-built_in\">setw</span>(width) &lt;&lt; std::<span class=\"hljs-built_in\">setfill</span>(separator)\n                &lt;&lt; v[row][col];\n        out &lt;&lt; std::endl;\n    }\n\n    <span class=\"hljs-keyword\">return</span> out;\n}\n\n<span class=\"hljs-comment\">/**\n * operator to print a vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::ostream &amp;<span class=\"hljs-keyword\">operator</span>&lt;&lt;(std::ostream &amp;out, std::valarray&lt;T&gt; <span class=\"hljs-keyword\">const</span> &amp;v) {\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> width = <span class=\"hljs-number\">10</span>;\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> separator = <span class=\"hljs-string\">&#x27; &#x27;</span>;\n\n    out.<span class=\"hljs-built_in\">precision</span>(<span class=\"hljs-number\">4</span>);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row = <span class=\"hljs-number\">0</span>; row &lt; v.<span class=\"hljs-built_in\">size</span>(); row++) {\n        out &lt;&lt; std::right &lt;&lt; std::<span class=\"hljs-built_in\">setw</span>(width) &lt;&lt; std::<span class=\"hljs-built_in\">setfill</span>(separator)\n            &lt;&lt; v[row];\n    }\n\n    <span class=\"hljs-keyword\">return</span> out;\n}\n\n<span class=\"hljs-comment\">/**\n * Compute dot product of two vectors of equal lengths\n *\n * If \\f$\\vec{a}=\\left[a_0,a_1,a_2,...,a_L\\right]\\f$ and\n * \\f$\\vec{b}=\\left[b_0,b_1,b_1,...,b_L\\right]\\f$ then\n * \\f$\\vec{a}\\cdot\\vec{b}=\\displaystyle\\sum_{i=0}^L a_i\\times b_i\\f$\n *\n * \\returns \\f$\\vec{a}\\cdot\\vec{b}\\f$\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title\">vector_dot</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::valarray&lt;T&gt; &amp;a, <span class=\"hljs-keyword\">const</span> std::valarray&lt;T&gt; &amp;b)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> (a * b).<span class=\"hljs-built_in\">sum</span>();\n    <span class=\"hljs-comment\">// could also use following</span>\n    <span class=\"hljs-comment\">// return std::inner_product(std::begin(a), std::end(a), std::begin(b),</span>\n    <span class=\"hljs-comment\">// 0.f);</span>\n}\n\n<span class=\"hljs-comment\">/**\n * Compute magnitude of vector.\n *\n * If \\f$\\vec{a}=\\left[a_0,a_1,a_2,...,a_L\\right]\\f$ then\n * \\f$\\left|\\vec{a}\\right|=\\sqrt{\\displaystyle\\sum_{i=0}^L a_i^2}\\f$\n *\n * \\returns \\f$\\left|\\vec{a}\\right|\\f$\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title\">vector_mag</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::valarray&lt;T&gt; &amp;a)</span> </span>{\n    <span class=\"hljs-type\">double</span> dot = <span class=\"hljs-built_in\">vector_dot</span>(a, a);\n    <span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">sqrt</span>(dot);\n}\n\n<span class=\"hljs-comment\">/**\n * Compute projection of vector \\f$\\vec{a}\\f$ on \\f$\\vec{b}\\f$ defined as\n * \\f[\\text{proj}_\\vec{b}\\vec{a}=\\frac{\\vec{a}\\cdot\\vec{b}}{\\left|\\vec{b}\\right|^2}\\vec{b}\\f]\n *\n * \\returns NULL if error, otherwise pointer to output\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n<span class=\"hljs-function\">std::valarray&lt;T&gt; <span class=\"hljs-title\">vector_proj</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::valarray&lt;T&gt; &amp;a,\n                             <span class=\"hljs-keyword\">const</span> std::valarray&lt;T&gt; &amp;b)</span> </span>{\n    <span class=\"hljs-type\">double</span> num = <span class=\"hljs-built_in\">vector_dot</span>(a, b);\n    <span class=\"hljs-type\">double</span> deno = <span class=\"hljs-built_in\">vector_dot</span>(b, b);\n\n    <span class=\"hljs-comment\">/*! check for division by zero using machine epsilon */</span>\n    <span class=\"hljs-keyword\">if</span> (deno &lt;= std::numeric_limits&lt;<span class=\"hljs-type\">double</span>&gt;::<span class=\"hljs-built_in\">epsilon</span>()) {\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;[&quot;</span> &lt;&lt; __func__ &lt;&lt; <span class=\"hljs-string\">&quot;] Possible division by zero\\n&quot;</span>;\n        <span class=\"hljs-keyword\">return</span> a;  <span class=\"hljs-comment\">// return vector a back</span>\n    }\n\n    <span class=\"hljs-type\">double</span> scalar = num / deno;\n\n    <span class=\"hljs-keyword\">return</span> b * scalar;\n}\n\n<span class=\"hljs-comment\">/**\n * Decompose matrix \\f$A\\f$ using [Gram-Schmidt\n *process](https://en.wikipedia.org/wiki/QR_decomposition).\n *\n * \\f{eqnarray*}{\n * \\text{given that}\\quad A &amp;=&amp;\n *\\left[\\mathbf{a}_1,\\mathbf{a}_2,\\ldots,\\mathbf{a}_{N-1},\\right]\\\\\n * \\text{where}\\quad\\mathbf{a}_i &amp;=&amp;\n * \\left[a_{0i},a_{1i},a_{2i},\\ldots,a_{(M-1)i}\\right]^T\\quad\\ldots\\mbox{(column\n * vectors)}\\\\\n * \\text{then}\\quad\\mathbf{u}_i &amp;=&amp; \\mathbf{a}_i\n *-\\sum_{j=0}^{i-1}\\text{proj}_{\\mathbf{u}_j}\\mathbf{a}_i\\\\\n * \\mathbf{e}_i &amp;=&amp;\\frac{\\mathbf{u}_i}{\\left|\\mathbf{u}_i\\right|}\\\\\n * Q &amp;=&amp; \\begin{bmatrix}\\mathbf{e}_0 &amp; \\mathbf{e}_1 &amp; \\mathbf{e}_2 &amp; \\dots &amp;\n * \\mathbf{e}_{N-1}\\end{bmatrix}\\\\\n * R &amp;=&amp; \\begin{bmatrix}\\langle\\mathbf{e}_0\\,,\\mathbf{a}_0\\rangle &amp;\n * \\langle\\mathbf{e}_1\\,,\\mathbf{a}_1\\rangle &amp;\n * \\langle\\mathbf{e}_2\\,,\\mathbf{a}_2\\rangle &amp; \\dots \\\\\n *                  0 &amp; \\langle\\mathbf{e}_1\\,,\\mathbf{a}_1\\rangle &amp;\n * \\langle\\mathbf{e}_2\\,,\\mathbf{a}_2\\rangle &amp; \\dots\\\\\n *                  0 &amp; 0 &amp; \\langle\\mathbf{e}_2\\,,\\mathbf{a}_2\\rangle &amp;\n * \\dots\\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots\n *      \\end{bmatrix}\\\\\n * \\f}\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">qr_decompose</span><span class=\"hljs-params\">(\n    <span class=\"hljs-keyword\">const</span> std::valarray&lt;std::valarray&lt;T&gt;&gt; &amp;A, <span class=\"hljs-comment\">/**&lt; input matrix to decompose */</span>\n    std::valarray&lt;std::valarray&lt;T&gt;&gt; *Q,       <span class=\"hljs-comment\">/**&lt; output decomposed matrix */</span>\n    std::valarray&lt;std::valarray&lt;T&gt;&gt; *R        <span class=\"hljs-comment\">/**&lt; output decomposed matrix */</span>\n)</span> </span>{\n    std::<span class=\"hljs-type\">size_t</span> ROWS = A.<span class=\"hljs-built_in\">size</span>();        <span class=\"hljs-comment\">// number of rows of A</span>\n    std::<span class=\"hljs-type\">size_t</span> COLUMNS = A[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>();  <span class=\"hljs-comment\">// number of columns of A</span>\n    <span class=\"hljs-function\">std::valarray&lt;T&gt; <span class=\"hljs-title\">col_vector</span><span class=\"hljs-params\">(ROWS)</span></span>;\n    <span class=\"hljs-function\">std::valarray&lt;T&gt; <span class=\"hljs-title\">col_vector2</span><span class=\"hljs-params\">(ROWS)</span></span>;\n    <span class=\"hljs-function\">std::valarray&lt;T&gt; <span class=\"hljs-title\">tmp_vector</span><span class=\"hljs-params\">(ROWS)</span></span>;\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; COLUMNS; i++) {\n        <span class=\"hljs-comment\">/* for each column =&gt; R is a square matrix of NxN */</span>\n        <span class=\"hljs-type\">int</span> j;\n        R[<span class=\"hljs-number\">0</span>][i] = <span class=\"hljs-number\">0.</span>; <span class=\"hljs-comment\">/* make R upper triangular */</span>\n\n        <span class=\"hljs-comment\">/* get corresponding Q vector */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-comment\">// parallelize on threads</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n        <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; ROWS; j++) {\n            tmp_vector[j] = A[j][i]; <span class=\"hljs-comment\">/* accumulator for uk */</span>\n            col_vector[j] = A[j][i];\n        }\n        <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; i; j++) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; ROWS; k++) {\n                col_vector2[k] = Q[<span class=\"hljs-number\">0</span>][k][j];\n            }\n            col_vector2 = <span class=\"hljs-built_in\">vector_proj</span>(col_vector, col_vector2);\n            tmp_vector -= col_vector2;\n        }\n\n        <span class=\"hljs-type\">double</span> mag = <span class=\"hljs-built_in\">vector_mag</span>(tmp_vector);\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-comment\">// parallelize on threads</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n        <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; ROWS; j++) Q[<span class=\"hljs-number\">0</span>][j][i] = tmp_vector[j] / mag;\n\n            <span class=\"hljs-comment\">/* compute upper triangular values of R */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-comment\">// parallelize on threads</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> kk = <span class=\"hljs-number\">0</span>; kk &lt; ROWS; kk++) {\n            col_vector[kk] = Q[<span class=\"hljs-number\">0</span>][kk][i];\n        }\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-comment\">// parallelize on threads</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = i; k &lt; COLUMNS; k++) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> kk = <span class=\"hljs-number\">0</span>; kk &lt; ROWS; kk++) {\n                col_vector2[kk] = A[kk][k];\n            }\n            R[<span class=\"hljs-number\">0</span>][i][k] = (col_vector * col_vector2).<span class=\"hljs-built_in\">sum</span>();\n        }\n    }\n}\n}  <span class=\"hljs-comment\">// namespace qr_algorithm</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span>  <span class=\"hljs-comment\">// NUMERICAL_METHODS_QR_DECOMPOSE_H_</span></span>\n"
    }
  },
  "contributors": [
    {
      "name": "Krishna Vedala",
      "email": "krishna.vedala@ieee.org",
      "commits": 2
    },
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 3
    }
  ],
  "explanationUrl": {}
}
