{
  "slug": "basic-graphs",
  "name": "Basic Graphs",
  "categories": ["graphs"],
  "body": {},
  "implementations": {
    "python": {
      "dir": "graphs/basic_graphs.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/graphs/basic_graphs.py",
      "code": "<span class=\"hljs-keyword\">from</span> collections <span class=\"hljs-keyword\">import</span> deque\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    <span class=\"hljs-comment\"># Accept No. of Nodes and edges</span>\n    n, m = <span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">input</span>().split(<span class=\"hljs-string\">&quot; &quot;</span>))\n\n    <span class=\"hljs-comment\"># Initialising Dictionary of edges</span>\n    g = {}\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n):\n        g[i + <span class=\"hljs-number\">1</span>] = []\n\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    ----------------------------------------------------------------------------\n        Accepting edges of Unweighted Directed Graphs\n    ----------------------------------------------------------------------------\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(m):\n        x, y = <span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">input</span>().strip().split(<span class=\"hljs-string\">&quot; &quot;</span>))\n        g[x].append(y)\n\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    ----------------------------------------------------------------------------\n        Accepting edges of Unweighted Undirected Graphs\n    ----------------------------------------------------------------------------\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(m):\n        x, y = <span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">input</span>().strip().split(<span class=\"hljs-string\">&quot; &quot;</span>))\n        g[x].append(y)\n        g[y].append(x)\n\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    ----------------------------------------------------------------------------\n        Accepting edges of Weighted Undirected Graphs\n    ----------------------------------------------------------------------------\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(m):\n        x, y, r = <span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">input</span>().strip().split(<span class=\"hljs-string\">&quot; &quot;</span>))\n        g[x].append([y, r])\n        g[y].append([x, r])\n\n<span class=\"hljs-string\">&quot;&quot;&quot;\n--------------------------------------------------------------------------------\n    Depth First Search.\n        Args :  G - Dictionary of edges\n                s - Starting Node\n        Vars :  vis - Set of visited nodes\n                S - Traversal Stack\n--------------------------------------------------------------------------------\n&quot;&quot;&quot;</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">dfs</span>(<span class=\"hljs-params\">G, s</span>):\n    vis, S = {s}, [s]\n    <span class=\"hljs-built_in\">print</span>(s)\n    <span class=\"hljs-keyword\">while</span> S:\n        flag = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> G[S[-<span class=\"hljs-number\">1</span>]]:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> vis:\n                S.append(i)\n                vis.add(i)\n                flag = <span class=\"hljs-number\">1</span>\n                <span class=\"hljs-built_in\">print</span>(i)\n                <span class=\"hljs-keyword\">break</span>\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> flag:\n            S.pop()\n\n\n<span class=\"hljs-string\">&quot;&quot;&quot;\n--------------------------------------------------------------------------------\n    Breadth First Search.\n        Args :  G - Dictionary of edges\n                s - Starting Node\n        Vars :  vis - Set of visited nodes\n                Q - Traversal Stack\n--------------------------------------------------------------------------------\n&quot;&quot;&quot;</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">bfs</span>(<span class=\"hljs-params\">G, s</span>):\n    vis, Q = {s}, deque([s])\n    <span class=\"hljs-built_in\">print</span>(s)\n    <span class=\"hljs-keyword\">while</span> Q:\n        u = Q.popleft()\n        <span class=\"hljs-keyword\">for</span> v <span class=\"hljs-keyword\">in</span> G[u]:\n            <span class=\"hljs-keyword\">if</span> v <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> vis:\n                vis.add(v)\n                Q.append(v)\n                <span class=\"hljs-built_in\">print</span>(v)\n\n\n<span class=\"hljs-string\">&quot;&quot;&quot;\n--------------------------------------------------------------------------------\n    Dijkstra&#x27;s shortest path Algorithm\n        Args :  G - Dictionary of edges\n                s - Starting Node\n        Vars :  dist - Dictionary storing shortest distance from s to every other node\n                known - Set of knows nodes\n                path - Preceding node in path\n--------------------------------------------------------------------------------\n&quot;&quot;&quot;</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">dijk</span>(<span class=\"hljs-params\">G, s</span>):\n    dist, known, path = {s: <span class=\"hljs-number\">0</span>}, <span class=\"hljs-built_in\">set</span>(), {s: <span class=\"hljs-number\">0</span>}\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(known) == <span class=\"hljs-built_in\">len</span>(G) - <span class=\"hljs-number\">1</span>:\n            <span class=\"hljs-keyword\">break</span>\n        mini = <span class=\"hljs-number\">100000</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> dist:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> known <span class=\"hljs-keyword\">and</span> dist[i] &lt; mini:\n                mini = dist[i]\n                u = i\n        known.add(u)\n        <span class=\"hljs-keyword\">for</span> v <span class=\"hljs-keyword\">in</span> G[u]:\n            <span class=\"hljs-keyword\">if</span> v[<span class=\"hljs-number\">0</span>] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> known:\n                <span class=\"hljs-keyword\">if</span> dist[u] + v[<span class=\"hljs-number\">1</span>] &lt; dist.get(v[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">100000</span>):\n                    dist[v[<span class=\"hljs-number\">0</span>]] = dist[u] + v[<span class=\"hljs-number\">1</span>]\n                    path[v[<span class=\"hljs-number\">0</span>]] = u\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> dist:\n        <span class=\"hljs-keyword\">if</span> i != s:\n            <span class=\"hljs-built_in\">print</span>(dist[i])\n\n\n<span class=\"hljs-string\">&quot;&quot;&quot;\n--------------------------------------------------------------------------------\n    Topological Sort\n--------------------------------------------------------------------------------\n&quot;&quot;&quot;</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">topo</span>(<span class=\"hljs-params\">G, ind=<span class=\"hljs-literal\">None</span>, Q=<span class=\"hljs-literal\">None</span></span>):\n    <span class=\"hljs-keyword\">if</span> Q <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:\n        Q = [<span class=\"hljs-number\">1</span>]\n    <span class=\"hljs-keyword\">if</span> ind <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:\n        ind = [<span class=\"hljs-number\">0</span>] * (<span class=\"hljs-built_in\">len</span>(G) + <span class=\"hljs-number\">1</span>)  <span class=\"hljs-comment\"># SInce oth Index is ignored</span>\n        <span class=\"hljs-keyword\">for</span> u <span class=\"hljs-keyword\">in</span> G:\n            <span class=\"hljs-keyword\">for</span> v <span class=\"hljs-keyword\">in</span> G[u]:\n                ind[v] += <span class=\"hljs-number\">1</span>\n        Q = deque()\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> G:\n            <span class=\"hljs-keyword\">if</span> ind[i] == <span class=\"hljs-number\">0</span>:\n                Q.append(i)\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(Q) == <span class=\"hljs-number\">0</span>:\n        <span class=\"hljs-keyword\">return</span>\n    v = Q.popleft()\n    <span class=\"hljs-built_in\">print</span>(v)\n    <span class=\"hljs-keyword\">for</span> w <span class=\"hljs-keyword\">in</span> G[v]:\n        ind[w] -= <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">if</span> ind[w] == <span class=\"hljs-number\">0</span>:\n            Q.append(w)\n    topo(G, ind, Q)\n\n\n<span class=\"hljs-string\">&quot;&quot;&quot;\n--------------------------------------------------------------------------------\n    Reading an Adjacency matrix\n--------------------------------------------------------------------------------\n&quot;&quot;&quot;</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">adjm</span>():\n    n = <span class=\"hljs-built_in\">input</span>().strip()\n    a = []\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n):\n        a.append(<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">input</span>().strip().split()))\n    <span class=\"hljs-keyword\">return</span> a, n\n\n\n<span class=\"hljs-string\">&quot;&quot;&quot;\n--------------------------------------------------------------------------------\n    Floyd Warshall&#x27;s algorithm\n        Args :  G - Dictionary of edges\n                s - Starting Node\n        Vars :  dist - Dictionary storing shortest distance from s to every other node\n                known - Set of knows nodes\n                path - Preceding node in path\n\n--------------------------------------------------------------------------------\n&quot;&quot;&quot;</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">floy</span>(<span class=\"hljs-params\">A_and_n</span>):\n    (A, n) = A_and_n\n    dist = <span class=\"hljs-built_in\">list</span>(A)\n    path = [[<span class=\"hljs-number\">0</span>] * n <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n)]\n    <span class=\"hljs-keyword\">for</span> k <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n):\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n):\n            <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n):\n                <span class=\"hljs-keyword\">if</span> dist[i][j] &gt; dist[i][k] + dist[k][j]:\n                    dist[i][j] = dist[i][k] + dist[k][j]\n                    path[i][k] = k\n    <span class=\"hljs-built_in\">print</span>(dist)\n\n\n<span class=\"hljs-string\">&quot;&quot;&quot;\n--------------------------------------------------------------------------------\n    Prim&#x27;s MST Algorithm\n        Args :  G - Dictionary of edges\n                s - Starting Node\n        Vars :  dist - Dictionary storing shortest distance from s to nearest node\n                known - Set of knows nodes\n                path - Preceding node in path\n--------------------------------------------------------------------------------\n&quot;&quot;&quot;</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">prim</span>(<span class=\"hljs-params\">G, s</span>):\n    dist, known, path = {s: <span class=\"hljs-number\">0</span>}, <span class=\"hljs-built_in\">set</span>(), {s: <span class=\"hljs-number\">0</span>}\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(known) == <span class=\"hljs-built_in\">len</span>(G) - <span class=\"hljs-number\">1</span>:\n            <span class=\"hljs-keyword\">break</span>\n        mini = <span class=\"hljs-number\">100000</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> dist:\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> known <span class=\"hljs-keyword\">and</span> dist[i] &lt; mini:\n                mini = dist[i]\n                u = i\n        known.add(u)\n        <span class=\"hljs-keyword\">for</span> v <span class=\"hljs-keyword\">in</span> G[u]:\n            <span class=\"hljs-keyword\">if</span> v[<span class=\"hljs-number\">0</span>] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> known:\n                <span class=\"hljs-keyword\">if</span> v[<span class=\"hljs-number\">1</span>] &lt; dist.get(v[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">100000</span>):\n                    dist[v[<span class=\"hljs-number\">0</span>]] = v[<span class=\"hljs-number\">1</span>]\n                    path[v[<span class=\"hljs-number\">0</span>]] = u\n    <span class=\"hljs-keyword\">return</span> dist\n\n\n<span class=\"hljs-string\">&quot;&quot;&quot;\n--------------------------------------------------------------------------------\n    Accepting Edge list\n        Vars :  n - Number of nodes\n                m - Number of edges\n        Returns : l - Edge list\n                n - Number of Nodes\n--------------------------------------------------------------------------------\n&quot;&quot;&quot;</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">edglist</span>():\n    n, m = <span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">input</span>().split(<span class=\"hljs-string\">&quot; &quot;</span>))\n    edges = []\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(m):\n        edges.append(<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">input</span>().split(<span class=\"hljs-string\">&quot; &quot;</span>)))\n    <span class=\"hljs-keyword\">return</span> edges, n\n\n\n<span class=\"hljs-string\">&quot;&quot;&quot;\n--------------------------------------------------------------------------------\n    Kruskal&#x27;s MST Algorithm\n        Args :  E - Edge list\n                n - Number of Nodes\n        Vars :  s - Set of all nodes as unique disjoint sets (initially)\n--------------------------------------------------------------------------------\n&quot;&quot;&quot;</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">krusk</span>(<span class=\"hljs-params\">E_and_n</span>):\n    <span class=\"hljs-comment\"># Sort edges on the basis of distance</span>\n    (E, n) = E_and_n\n    E.sort(reverse=<span class=\"hljs-literal\">True</span>, key=<span class=\"hljs-keyword\">lambda</span> x: x[<span class=\"hljs-number\">2</span>])\n    s = [{i} <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, n + <span class=\"hljs-number\">1</span>)]\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(s) == <span class=\"hljs-number\">1</span>:\n            <span class=\"hljs-keyword\">break</span>\n        <span class=\"hljs-built_in\">print</span>(s)\n        x = E.pop()\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(s)):\n            <span class=\"hljs-keyword\">if</span> x[<span class=\"hljs-number\">0</span>] <span class=\"hljs-keyword\">in</span> s[i]:\n                <span class=\"hljs-keyword\">break</span>\n        <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(s)):\n            <span class=\"hljs-keyword\">if</span> x[<span class=\"hljs-number\">1</span>] <span class=\"hljs-keyword\">in</span> s[j]:\n                <span class=\"hljs-keyword\">if</span> i == j:\n                    <span class=\"hljs-keyword\">break</span>\n                s[j].update(s[i])\n                s.pop(i)\n                <span class=\"hljs-keyword\">break</span>\n\n\n<span class=\"hljs-comment\"># find the isolated node in the graph</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">find_isolated_nodes</span>(<span class=\"hljs-params\">graph</span>):\n    isolated = []\n    <span class=\"hljs-keyword\">for</span> node <span class=\"hljs-keyword\">in</span> graph:\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> graph[node]:\n            isolated.append(node)\n    <span class=\"hljs-keyword\">return</span> isolated\n"
    }
  },
  "contributors": [
    {
      "name": "AlexDvorak",
      "email": "opti.jawsome@gmail.com",
      "commits": 1
    },
    {
      "name": "Hector S",
      "email": "hfsam88@gmail.com",
      "commits": 1
    },
    {
      "name": "KARTHIKEYAN ANBARASU",
      "email": "53579498+karthikeyansa@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Shivam Arora",
      "email": "shivam.arora@inficold.com",
      "commits": 1
    },
    {
      "name": "97arushisharma",
      "email": "97arushisharma@gmail.com",
      "commits": 1
    },
    {
      "name": "Vishal Gupta",
      "email": "vishalg8897@gmail.com",
      "commits": 1
    },
    {
      "name": "ParthS007",
      "email": "parth1989shandilya@gmail.com",
      "commits": 2
    },
    {
      "name": "cclauss",
      "email": "cclauss@bluewin.ch",
      "commits": 2
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 6
    }
  ],
  "explanationUrl": {}
}
