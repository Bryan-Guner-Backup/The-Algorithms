{
  "slug": "streamsieve",
  "name": "StreamSieve",
  "categories": ["math"],
  "body": {},
  "implementations": {
    "scala": {
      "dir": "src/main/scala/Mathematics/StreamSieve.scala",
      "url": "https://github.com/TheAlgorithms/scala/tree/master/src/main/scala/Mathematics/StreamSieve.scala",
      "code": "<span class=\"hljs-keyword\">package</span> <span class=\"hljs-type\">Mathematics</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">object</span> <span class=\"hljs-title\">StreamSieve</span> </span>{\n\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> allPrimes: <span class=\"hljs-type\">Stream</span>[<span class=\"hljs-type\">Int</span>] = <span class=\"hljs-number\">2</span> #:: <span class=\"hljs-type\">Stream</span>.from(<span class=\"hljs-number\">3</span>).filter { c =&gt;\n    <span class=\"hljs-keyword\">val</span> primesUptoSqrt = allPrimes.takeWhile(p =&gt; p &lt;= math.sqrt(c))\n    !primesUptoSqrt.exists(p =&gt; c % p == <span class=\"hljs-number\">0</span>)\n  }\n\n  <span class=\"hljs-comment\">/**\n    * Method to use the allPrimes stream to take the first n prime numbers\n    * Using streams is both an easy and efficient way to generate fibonacci numbers (streams are memoized)\n    * Using streams as opposed to the classic sieve ensures that we stay following functional principles\n    * and not change states\n    *\n    * @param total\n    * @return\n    */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">getPrimeNumbers</span></span>(n: <span class=\"hljs-type\">Int</span>): <span class=\"hljs-type\">Seq</span>[<span class=\"hljs-type\">Int</span>] = allPrimes.take(n)\n}\n"
    }
  },
  "contributors": [
    {
      "name": "khanhhuynguyenvu",
      "email": "khanhhuynguyenvu@gmail.com",
      "commits": 1
    },
    {
      "name": "cutajarj2",
      "email": "james.cutajar@blip.pt",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}
