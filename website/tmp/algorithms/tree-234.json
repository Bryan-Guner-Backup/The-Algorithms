{
  "slug": "tree-234",
  "name": "Tree 234",
  "categories": ["datastructures"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "data_structures/tree_234.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/data_structures/tree_234.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * @brief A demo 2-3-4 tree implementation\n * @details\n * 2–3–4 tree is a self-balancing data structure that is an isometry of\n * red–black trees. Though we seldom use them in practice, we study them\n * to understand the theory behind Red-Black tree. Please read following\n * links for more infomation.\n * [2–3–4 tree](https://en.wikipedia.org/wiki/2%E2%80%933%E2%80%934_tree)\n * [2-3-4 Trees: A Visual\nIntroduction](https://www.educative.io/page/5689413791121408/80001)\n * We Only implement some basic and complicated operations in this demo.\n * Other operations should be easy to be added.\n * @author [liuhuan](https://github.com/fedom)\n */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;array&gt;</span>     <span class=\"hljs-comment\">/// for std::array</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>   <span class=\"hljs-comment\">/// for assert</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;fstream&gt;</span>   <span class=\"hljs-comment\">/// for std::ofstream</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>  <span class=\"hljs-comment\">/// for std::cout</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;memory&gt;</span>    <span class=\"hljs-comment\">/// for std::unique_ptr</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span>     <span class=\"hljs-comment\">/// for std::queue</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span>    <span class=\"hljs-comment\">/// for std::to_string</span></span>\n\n<span class=\"hljs-comment\">/**\n * @namespace data_structures\n * @brief Algorithms with data structures\n */</span>\n<span class=\"hljs-keyword\">namespace</span> data_structures {\n<span class=\"hljs-comment\">/**\n * @namespace tree_234\n * @brief Functions for [2–3–4 tree](https://en.wikipedia.org/wiki/2%E2%80%933%E2%80%934_tree)\n */</span>\n<span class=\"hljs-keyword\">namespace</span> tree_234 {\n<span class=\"hljs-comment\">/** @brief 2-3-4 tree node class */</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Node</span> {\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-comment\">/**\n     * @brief Node constructor\n     * @param item the first value we insert to the node\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">Node</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> item)</span>\n        : count(<span class=\"hljs-number\">1</span>),\n          items({</span>{item, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>}}),\n          <span class=\"hljs-built_in\">children</span>({{<span class=\"hljs-literal\">nullptr</span>, <span class=\"hljs-literal\">nullptr</span>, <span class=\"hljs-literal\">nullptr</span>, <span class=\"hljs-literal\">nullptr</span>}}) {}\n\n    <span class=\"hljs-comment\">/**\n     * @brief Get the item count that current saved in the node\n     * @return item count\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int8_t</span> <span class=\"hljs-title\">GetCount</span><span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-keyword\">return</span> count; }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Set the item count of the node\n     *\n     * This is only used when we spliting and merging node where we need to do\n     * some raw operation manually. In common inserting and removing operation\n     * the count is maintained automatically.\n     *\n     * @param c the count to set\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetCount</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int8_t</span> c)</span> </span>{ count = c; }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Check if node is a leaf\n     * @return true if node is leaf, false otherwise\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">IsLeaf</span><span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-keyword\">return</span> children[<span class=\"hljs-number\">0</span>] == <span class=\"hljs-literal\">nullptr</span>; }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Check if node is a full (4-node)\n     * @return true if node is full (4-node), false otherwise\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">IsFull</span><span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-keyword\">return</span> count == <span class=\"hljs-number\">3</span>; }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Check if node is a 2-node\n     * @return true if node is 2-node, otherwise false\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">Is2Node</span><span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-keyword\">return</span> count == <span class=\"hljs-number\">1</span>; }\n\n    <span class=\"hljs-comment\">/** @brief Check if node is a 3-node or 4-node, this is useful when we\n     * delete item from 2-3-4 tree\n     * @return true if node is 3-node or 4-node, false otherwise\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">Is34Node</span><span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-keyword\">return</span> count == <span class=\"hljs-number\">2</span> || count == <span class=\"hljs-number\">3</span>; }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Check if item is in the node\n     * @param item item to check\n     * @return true if item in the node, otherwise false\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">Contains</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> item)</span> </span>{\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int8_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; count; i++) {\n            <span class=\"hljs-keyword\">if</span> (item == items[i]) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Get the index of the item in the node, 0-based\n     * @param item item to check\n     * @return 0-based index of the item in the node, if not in the node, -1 is\n     * returned\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int8_t</span> <span class=\"hljs-title\">GetItemIndex</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> item)</span> </span>{\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int8_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; count; i++) {\n            <span class=\"hljs-keyword\">if</span> (items[i] == item) {\n                <span class=\"hljs-keyword\">return</span> i;\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Get max item (rightmost) in the current node\n     * @return max item\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title\">GetMaxItem</span><span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-keyword\">return</span> items[count - <span class=\"hljs-number\">1</span>]; }\n\n    <span class=\"hljs-comment\">/**\n     * @brief get min item (leftmost) in the current node\n     * @return min item\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title\">GetMinItem</span><span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-keyword\">return</span> items[<span class=\"hljs-number\">0</span>]; }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Get item of the \\index index\n     * @param index the item index to get\n     * @return the item\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title\">GetItem</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int8_t</span> index)</span> </span>{ <span class=\"hljs-keyword\">return</span> items[index]; }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Set item value at position of index\n     * @param index the index of the item to set\n     * @param new_item item value\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetItem</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int8_t</span> index, <span class=\"hljs-type\">int64_t</span> new_item)</span> </span>{\n        <span class=\"hljs-built_in\">assert</span>(index &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; index &lt;= <span class=\"hljs-number\">2</span>);\n\n        items[index] = new_item;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Insert item to the proper position of the node and return the\n     * position index.\n     *\n     * This is a helper function we use during insertion. Please mind that when\n     * insert a item, we aslo need to take care of two child pointers. One is\n     * the original child pointer at the insertion position. It can be placed as\n     * new item&#x27;s either left child or right child. And the other is the new\n     * child that should be added. For our dedicated situation here, we choose\n     * to use the original child as the new item&#x27;s left child, and add a null\n     * pointer to its right child. So after use the function, please update\n     * these two children pointer manually.\n     *\n     * @param item value to be inserted to the node\n     * @return index where item is inserted, caller can use this\n     * index to update its left and right child\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">InsertItem</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> item)</span> </span>{\n        <span class=\"hljs-built_in\">assert</span>(!<span class=\"hljs-built_in\">IsFull</span>());\n\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Contains</span>(item)) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n        }\n\n        <span class=\"hljs-type\">int8_t</span> i = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; count; i++) {\n            <span class=\"hljs-keyword\">if</span> (items[i] &gt; item) {\n                <span class=\"hljs-keyword\">break</span>;\n            }\n        }\n\n        <span class=\"hljs-built_in\">InsertItemByIndex</span>(i, item, <span class=\"hljs-literal\">nullptr</span>, <span class=\"hljs-literal\">true</span>);\n        <span class=\"hljs-keyword\">return</span> i;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Insert a value to the index position\n     * @param index index where to insert item\n     * @param item  value to insert\n     * @param with_child new added child pointer\n     * @param to_left true indicate adding with_child to new item&#x27;s left child,\n     * otherwise to right child\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">InsertItemByIndex</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int8_t</span> index, <span class=\"hljs-type\">int64_t</span> item, Node *with_child,\n                           <span class=\"hljs-type\">bool</span> to_left = <span class=\"hljs-literal\">true</span>)</span> </span>{\n        <span class=\"hljs-built_in\">assert</span>(count &lt; <span class=\"hljs-number\">3</span> &amp;&amp; index &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; index &lt; <span class=\"hljs-number\">3</span>);\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int8_t</span> i = count - <span class=\"hljs-number\">1</span>; i &gt;= index; i--) {\n            items[i + <span class=\"hljs-number\">1</span>] = items[i];\n        }\n\n        items[index] = item;\n\n        <span class=\"hljs-type\">int8_t</span> start_index = to_left ? index : index + <span class=\"hljs-number\">1</span>;\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int8_t</span> i = count; i &gt;= start_index; i--) {\n            children[i + <span class=\"hljs-number\">1</span>] = children[i];\n        }\n\n        children[start_index] = with_child;\n\n        count++;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Insert a value to the index position\n     * @param index index of the item to remove\n     * @param keep_left which child of the item to keep, true keep the left\n     * child, false keep the right child\n     * @return the removed child pointer\n     */</span>\n    <span class=\"hljs-function\">Node *<span class=\"hljs-title\">RemoveItemByIndex</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int8_t</span> index, <span class=\"hljs-type\">bool</span> keep_left)</span> </span>{\n        <span class=\"hljs-built_in\">assert</span>(index &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; index &lt; count);\n        Node *removed_child = keep_left ? children[index + <span class=\"hljs-number\">1</span>] : children[index];\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int8_t</span> i = index; i &lt; count - <span class=\"hljs-number\">1</span>; i++) {\n            items[i] = items[i + <span class=\"hljs-number\">1</span>];\n        }\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int8_t</span> i = keep_left ? index + <span class=\"hljs-number\">1</span> : index; i &lt; count; i++) {\n            children[i] = children[i + <span class=\"hljs-number\">1</span>];\n        }\n\n        count--;\n        <span class=\"hljs-keyword\">return</span> removed_child;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Get the child&#x27;s index of the children array\n     * @param child child pointer of which to get the index\n     * @return the index of child\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int8_t</span> <span class=\"hljs-title\">GetChildIndex</span><span class=\"hljs-params\">(Node *child)</span> </span>{\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int8_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; count + <span class=\"hljs-number\">1</span>; i++) {\n            <span class=\"hljs-keyword\">if</span> (children[i] == child) {\n                <span class=\"hljs-keyword\">return</span> i;\n            }\n        }\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Get the child pointer at position of index\n     * @param index index of child to get\n     * @return the child pointer\n     */</span>\n    <span class=\"hljs-function\">Node *<span class=\"hljs-title\">GetChild</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int8_t</span> index)</span> </span>{ <span class=\"hljs-keyword\">return</span> children[index]; }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Set child pointer to the position of index\n     * @param index children index\n     * @param child pointer to set\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetChild</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int8_t</span> index, Node *child)</span> </span>{ children[index] = child; }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Get rightmose child of the current node\n     * @return the rightmost child\n     */</span>\n    <span class=\"hljs-function\">Node *<span class=\"hljs-title\">GetRightmostChild</span><span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-keyword\">return</span> children[count]; }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Get leftmose child of the current node\n     * @return the leftmost child\n     */</span>\n    <span class=\"hljs-function\">Node *<span class=\"hljs-title\">GetLeftmostChild</span><span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-keyword\">return</span> children[<span class=\"hljs-number\">0</span>]; }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Get left child of item at item_index\n     * @param item_index  index of the item whose left child to be get\n     * @return left child of items[index]&#x27;s\n     */</span>\n    <span class=\"hljs-function\">Node *<span class=\"hljs-title\">GetItemLeftChild</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int8_t</span> item_index)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (item_index &lt; <span class=\"hljs-number\">0</span> || item_index &gt; count - <span class=\"hljs-number\">1</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;\n        }\n\n        <span class=\"hljs-keyword\">return</span> children[item_index];\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Get right child of item at item_index\n     * @param item_index  index of the item whose right child to be get\n     * @return right child of items[index]&#x27;s\n     */</span>\n    <span class=\"hljs-function\">Node *<span class=\"hljs-title\">GetItemRightChild</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int8_t</span> item_index)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (item_index &lt; <span class=\"hljs-number\">0</span> || item_index &gt; count - <span class=\"hljs-number\">1</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;\n        }\n\n        <span class=\"hljs-keyword\">return</span> children[item_index + <span class=\"hljs-number\">1</span>];\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Get next node which is possibly contains item\n     * @param item item to search\n     * @return the next node that possibly contains item\n     */</span>\n    <span class=\"hljs-function\">Node *<span class=\"hljs-title\">GetNextPossibleChild</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> item)</span> </span>{\n        <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; count; i++) {\n            <span class=\"hljs-keyword\">if</span> (items[i] &gt; item) {\n                <span class=\"hljs-keyword\">break</span>;\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> children[i];\n    }\n\n <span class=\"hljs-keyword\">private</span>:\n    std::array&lt;<span class=\"hljs-type\">int64_t</span>, 3&gt; items;  <span class=\"hljs-comment\">///&lt; store items</span>\n\n    std::array&lt;Node *, 4&gt; children;  <span class=\"hljs-comment\">///&lt; store the children pointers</span>\n\n    <span class=\"hljs-type\">int8_t</span> count = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">///&lt; track the current item count</span>\n};\n\n<span class=\"hljs-comment\">/** @brief 2-3-4 tree class */</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Tree234</span> {\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-built_in\">Tree234</span>() = <span class=\"hljs-keyword\">default</span>;\n    <span class=\"hljs-built_in\">Tree234</span>(<span class=\"hljs-keyword\">const</span> Tree234 &amp;) = <span class=\"hljs-keyword\">delete</span>;\n    <span class=\"hljs-built_in\">Tree234</span>(<span class=\"hljs-keyword\">const</span> Tree234 &amp;&amp;) = <span class=\"hljs-keyword\">delete</span>;\n    Tree234 &amp;<span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-keyword\">const</span> Tree234 &amp;) = <span class=\"hljs-keyword\">delete</span>;\n    Tree234 &amp;<span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-keyword\">const</span> Tree234 &amp;&amp;) = <span class=\"hljs-keyword\">delete</span>;\n\n    ~<span class=\"hljs-built_in\">Tree234</span>();\n\n    <span class=\"hljs-comment\">/**\n     * @brief Insert item to tree\n     * @param item item to insert\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> item)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * @brief Remove item from tree\n     * @param item item to remove\n     * @return true if item found and removed, false otherwise\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">Remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> item)</span></span>;\n\n    <span class=\"hljs-comment\">/** @brief In-order traverse */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Traverse</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * @brief Print tree into a dot file\n     * @param file_name output file name, if nullptr then use &quot;out.dot&quot; as\n     * default\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> *file_name = <span class=\"hljs-literal\">nullptr</span>)</span></span>;\n\n <span class=\"hljs-keyword\">private</span>:\n    <span class=\"hljs-comment\">/**\n     * @brief A insert implementation of pre-split\n     * @param item item to insert\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">InsertPreSplit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> item)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * @brief A insert implementation of post-merge\n     * @param item item to insert\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">InsertPostMerge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> item)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * @brief A helper function used by post-merge insert\n     * @param tree tree where to insert item\n     * @param item item to insert\n     * @return the node that split as the parent when overflow happen\n     */</span>\n    <span class=\"hljs-function\">Node *<span class=\"hljs-title\">Insert</span><span class=\"hljs-params\">(Node *tree, <span class=\"hljs-type\">int64_t</span> item)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * @brief A helper function used during post-merge insert\n     *\n     * When the inserting leads to overflow, it will split the node to 1 parent\n     * and 2 children. The parent will be merged to its origin parent after\n     * that. This is the function to complete this task. So the param node is\n     * always a 2-node.\n     *\n     * @param dst_node the target node we will merge node to, can be type of\n     * 2-node, 3-node or 4-node\n     * @param node the source node we will merge from, type must be 2-node\n     * @return overflow node of this level\n     */</span>\n    <span class=\"hljs-function\">Node *<span class=\"hljs-title\">MergeNode</span><span class=\"hljs-params\">(Node *dst_node, Node *node)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * @brief Merge node to a not-full target node\n     *\n     * Since the target node is not-full, no overflow will happen. So we have\n     * nothing to return.\n     *\n     * @param dst_node the target not-full node, that is the type is either\n     * 2-node or 3-node, but not 4-node\n     * @param node the source node we will merge from, type must be 2-node\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">MergeNodeNotFull</span><span class=\"hljs-params\">(Node *dst_node, Node *node)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * @brief Split a 4-node to 1 parent and 2 children, and return the parent\n     * node\n     * @param node the node to split, it must be a 4-node\n     * @return split parent node\n     */</span>\n    <span class=\"hljs-function\">Node *<span class=\"hljs-title\">SplitNode</span><span class=\"hljs-params\">(Node *node)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * @brief Get the max item of the tree\n     * @param tree the tree we will get item from\n     * @return max item of the tree\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title\">GetTreeMaxItem</span><span class=\"hljs-params\">(Node *tree)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * @brief Get the min item of the tree\n     * @param tree the tree we will get item from\n     * @return min item of the tree\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title\">GetTreeMinItem</span><span class=\"hljs-params\">(Node *tree)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * @brief A handy function to try if we can do a left rotate to the target\n     * node\n     *\n     * Given two node, the parent and the target child, the left rotate\n     * operation is uniquely identified. The source node must be the right\n     * sibling of the target child. The operation can be successfully done if\n     * the to_child has a right sibling and its right sibling is not 2-node.\n     *\n     * @param parent the parent node in this left rotate operation\n     * @param to_child the target child of this left rotate operation. In our\n     * case, this node is always 2-node\n     * @return true if we successfully do the rotate. false if the\n     * requirements are not fulfilled.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">TryLeftRotate</span><span class=\"hljs-params\">(Node *parent, Node *to_child)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * @brief A handy function to try if we can do a right rotate to the target\n     * node\n     *\n     * Given two node, the parent and the target child, the right rotate\n     * operation is uniquely identified. The source node must be the left\n     * sibling of the target child. The operation can be successfully done if\n     * the to_child has a left sibling and its left sibling is not 2-node.\n     *\n     * @param parent the parent node in this right rotate operation\n     * @param to_child the target child of this right rotate operation. In our\n     * case, it is always 2-node\n     * @return true if we successfully do the rotate. false if the\n     * requirements are not fulfilled.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">TryRightRotate</span><span class=\"hljs-params\">(Node *parent, Node *to_child)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * @brief Do the actual right rotate operation\n     *\n     * Given parent node, and the pivot item index, the right rotate operation\n     * is uniquely identified. The function assume the requirements are\n     * fulfilled and won&#x27;t do any extra check. This function is call by\n     * TryRightRotate(), and the condition checking should be done before call\n     * it.\n     *\n     * @param parent the parent node in this right rotate operation\n     * @param index the pivot item index of this right rotate operation.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">RightRotate</span><span class=\"hljs-params\">(Node *parent, <span class=\"hljs-type\">int8_t</span> index)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * @brief Do the actual left rotate operation\n     *\n     * Given parent node, and the pivot item index, the left rotate operation is\n     * uniquely identified. The function assume the requirements are fulfilled\n     * and won&#x27;t do any extra check. This function is call by TryLeftRotate(),\n     * and the condition checking should be done before call it.\n     *\n     * @param parent the parent node in this right rotate operation\n     * @param index the pivot item index of this right rotate operation.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">LeftRotate</span><span class=\"hljs-params\">(Node *parent, <span class=\"hljs-type\">int8_t</span> index)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * @brief Main function implement the pre-merge remove operation\n     * @param node the tree to remove item from\n     * @param item item to remove\n     * @return true if remove success, false otherwise\n     * */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">RemovePreMerge</span><span class=\"hljs-params\">(Node *node, <span class=\"hljs-type\">int64_t</span> item)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * @brief Merge the item at index of the parent node, and its left and right\n     * child\n     *\n     * the left and right child node must be 2-node. The 3 items will be merged\n     * into a 4-node. In our case the parent can be a 2-node iff it is the root.\n     * Otherwise, it must be 3-node or 4-node.\n     *\n     * @param parent the parent node in the merging operation\n     * @param index the item index of the parent node that involved in the\n     * merging\n     * @return the merged 4-node\n     */</span>\n    <span class=\"hljs-function\">Node *<span class=\"hljs-title\">Merge</span><span class=\"hljs-params\">(Node *parent, <span class=\"hljs-type\">int8_t</span> index)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * @brief Recursive release the tree\n     * @param tree root node of the tree to delete\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">DeleteNode</span><span class=\"hljs-params\">(Node *tree)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * @brief In-order traverse the tree, print items\n     * @param tree tree to traverse\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Traverse</span><span class=\"hljs-params\">(Node *tree)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * @brief Print the tree to a dot file. You can convert it to picture with\n     * graphviz\n     * @param ofs output file stream to print to\n     * @param node current node to print\n     * @param parent_index current node&#x27;s parent node index, this is used to\n     * draw the link from parent to current node\n     * @param index current node&#x27;s index of level order which is used to name\n     * the node in dot file\n     * @param parent_child_index the index that current node in parent&#x27;s\n     * children array, range in [0,4), help to locate the start position of the\n     * link between nodes\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintNode</span><span class=\"hljs-params\">(std::ofstream &amp;ofs, Node *node, <span class=\"hljs-type\">int64_t</span> parent_index,\n                   <span class=\"hljs-type\">int64_t</span> index, <span class=\"hljs-type\">int8_t</span> parent_child_index)</span></span>;\n\n    Node *root_{<span class=\"hljs-literal\">nullptr</span>};  <span class=\"hljs-comment\">///&lt; root node of the tree</span>\n};\n\nTree234::~<span class=\"hljs-built_in\">Tree234</span>() { <span class=\"hljs-built_in\">DeleteNode</span>(root_); }\n\n<span class=\"hljs-comment\">/**\n * @brief Recursive release the tree\n * @param tree root node of the tree to delete\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Tree234::DeleteNode</span><span class=\"hljs-params\">(Node *tree)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (!tree) {\n        <span class=\"hljs-keyword\">return</span>;\n    }\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int8_t</span> i = <span class=\"hljs-number\">0</span>; i &lt;= tree-&gt;<span class=\"hljs-built_in\">GetCount</span>(); i++) {\n        <span class=\"hljs-built_in\">DeleteNode</span>(tree-&gt;<span class=\"hljs-built_in\">GetChild</span>(i));\n    }\n\n    <span class=\"hljs-keyword\">delete</span> tree;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief In-order traverse the tree, print items\n * @param tree tree to traverse\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Tree234::Traverse</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">Traverse</span>(root_);\n    std::cout &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Tree234::Traverse</span><span class=\"hljs-params\">(Node *node)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (!node) {\n        <span class=\"hljs-keyword\">return</span>;\n    }\n\n    <span class=\"hljs-type\">int8_t</span> i = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; node-&gt;<span class=\"hljs-built_in\">GetCount</span>(); i++) {\n        <span class=\"hljs-built_in\">Traverse</span>(node-&gt;<span class=\"hljs-built_in\">GetChild</span>(i));\n        std::cout &lt;&lt; node-&gt;<span class=\"hljs-built_in\">GetItem</span>(i) &lt;&lt; <span class=\"hljs-string\">&quot;, &quot;</span>;\n    }\n\n    <span class=\"hljs-built_in\">Traverse</span>(node-&gt;<span class=\"hljs-built_in\">GetChild</span>(i));\n}\n\n<span class=\"hljs-comment\">/**\n * @brief A insert implementation of pre-split\n * @param item item to insert\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Tree234::InsertPreSplit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> item)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (!root_) {\n        root_ = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(item);\n        <span class=\"hljs-keyword\">return</span>;\n    }\n\n    Node *parent = <span class=\"hljs-literal\">nullptr</span>;\n    Node *node = root_;\n\n    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\n        <span class=\"hljs-keyword\">if</span> (!node) {\n            <span class=\"hljs-function\">std::unique_ptr&lt;Node&gt; <span class=\"hljs-title\">tmp</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">new</span> Node(item))</span></span>;\n            <span class=\"hljs-built_in\">MergeNodeNotFull</span>(parent, tmp.<span class=\"hljs-built_in\">get</span>());\n            <span class=\"hljs-keyword\">return</span>;\n        }\n\n        <span class=\"hljs-keyword\">if</span> (node-&gt;<span class=\"hljs-built_in\">Contains</span>(item)) {\n            <span class=\"hljs-keyword\">return</span>;\n        }\n\n        <span class=\"hljs-keyword\">if</span> (node-&gt;<span class=\"hljs-built_in\">IsFull</span>()) {\n            node = <span class=\"hljs-built_in\">SplitNode</span>(node);\n\n            Node *cur_node = <span class=\"hljs-literal\">nullptr</span>;\n\n            <span class=\"hljs-keyword\">if</span> (item &lt; node-&gt;<span class=\"hljs-built_in\">GetItem</span>(<span class=\"hljs-number\">0</span>)) {\n                cur_node = node-&gt;<span class=\"hljs-built_in\">GetChild</span>(<span class=\"hljs-number\">0</span>);\n            } <span class=\"hljs-keyword\">else</span> {\n                cur_node = node-&gt;<span class=\"hljs-built_in\">GetChild</span>(<span class=\"hljs-number\">1</span>);\n            }\n\n            <span class=\"hljs-keyword\">if</span> (!parent) {\n                <span class=\"hljs-comment\">// for the root node parent is nullptr, we simply assign the</span>\n                <span class=\"hljs-comment\">// split parent to root_</span>\n                root_ = node;\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-comment\">// merge the split parent to its origin parent</span>\n                <span class=\"hljs-built_in\">MergeNodeNotFull</span>(parent, node);\n            }\n\n            node = cur_node;\n        }\n\n        parent = node;\n        node = parent-&gt;<span class=\"hljs-built_in\">GetNextPossibleChild</span>(item);\n    }\n}\n\n<span class=\"hljs-comment\">/**\n * @brief A insert implementation of post-merge\n * @param item item to insert\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Tree234::InsertPostMerge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> item)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (!root_) {\n        root_ = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(item);\n        <span class=\"hljs-keyword\">return</span>;\n    }\n\n    Node *split_node = <span class=\"hljs-built_in\">Insert</span>(root_, item);\n\n    <span class=\"hljs-comment\">// if root has split, then update root_</span>\n    <span class=\"hljs-keyword\">if</span> (split_node) {\n        root_ = split_node;\n    }\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Insert item to tree\n * @param item item to insert\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Tree234::Insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> item)</span> </span>{ <span class=\"hljs-built_in\">InsertPreSplit</span>(item); }\n\n<span class=\"hljs-comment\">/**\n * @brief A helper function used by post-merge insert\n * @param tree tree where to insert item\n * @param item item to insert\n * @return the node that split as the parent when overflow happen\n */</span>\n<span class=\"hljs-function\">Node *<span class=\"hljs-title\">Tree234::Insert</span><span class=\"hljs-params\">(Node *tree, <span class=\"hljs-type\">int64_t</span> item)</span> </span>{\n    <span class=\"hljs-built_in\">assert</span>(tree != <span class=\"hljs-literal\">nullptr</span>);\n\n    std::unique_ptr&lt;Node&gt; split_node;\n\n    <span class=\"hljs-keyword\">if</span> (tree-&gt;<span class=\"hljs-built_in\">Contains</span>(item)) {\n        <span class=\"hljs-comment\">// return nullptr indicate current node not overflow</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;\n    }\n\n    Node *next_node = tree-&gt;<span class=\"hljs-built_in\">GetNextPossibleChild</span>(item);\n    <span class=\"hljs-keyword\">if</span> (next_node) {\n        split_node.<span class=\"hljs-built_in\">reset</span>(<span class=\"hljs-built_in\">Insert</span>(next_node, item));\n    } <span class=\"hljs-keyword\">else</span> {\n        split_node.<span class=\"hljs-built_in\">reset</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(item));\n    }\n\n    <span class=\"hljs-keyword\">if</span> (split_node) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">MergeNode</span>(tree, split_node.<span class=\"hljs-built_in\">get</span>());\n    }\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief A helper function used during post-merge insert\n *\n * When the inserting leads to overflow, it will split the node to 1 parent\n * and 2 children. The parent will be merged to its origin parent after\n * that. This is the function to complete this task. So the param node is\n * always a 2-node.\n *\n * @param dst_node the target node we will merge node to, can be type of\n * 2-node, 3-node or 4-node\n * @param node the source node we will merge from, type must be 2-node\n * @return overflow node of this level\n */</span>\n<span class=\"hljs-function\">Node *<span class=\"hljs-title\">Tree234::MergeNode</span><span class=\"hljs-params\">(Node *dst_node, Node *node)</span> </span>{\n    <span class=\"hljs-built_in\">assert</span>(dst_node != <span class=\"hljs-literal\">nullptr</span> &amp;&amp; node != <span class=\"hljs-literal\">nullptr</span>);\n\n    <span class=\"hljs-keyword\">if</span> (!dst_node-&gt;<span class=\"hljs-built_in\">IsFull</span>()) {\n        <span class=\"hljs-built_in\">MergeNodeNotFull</span>(dst_node, node);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;\n    }\n\n    dst_node = <span class=\"hljs-built_in\">SplitNode</span>(dst_node);\n\n    <span class=\"hljs-keyword\">if</span> (node-&gt;<span class=\"hljs-built_in\">GetItem</span>(<span class=\"hljs-number\">0</span>) &lt; dst_node-&gt;<span class=\"hljs-built_in\">GetItem</span>(<span class=\"hljs-number\">0</span>)) {\n        <span class=\"hljs-built_in\">MergeNodeNotFull</span>(dst_node-&gt;<span class=\"hljs-built_in\">GetChild</span>(<span class=\"hljs-number\">0</span>), node);\n\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-built_in\">MergeNodeNotFull</span>(dst_node-&gt;<span class=\"hljs-built_in\">GetChild</span>(<span class=\"hljs-number\">1</span>), node);\n    }\n\n    <span class=\"hljs-keyword\">return</span> dst_node;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Merge node to a not-full target node\n *\n * Since the target node is not-full, no overflow will happen. So we have\n * nothing to return.\n *\n * @param dst_node the target not-full node, that is the type is either\n * 2-node or 3-node, but not 4-node\n * @param node the source node we will merge from, type must be 2-node\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Tree234::MergeNodeNotFull</span><span class=\"hljs-params\">(Node *dst_node, Node *node)</span> </span>{\n    <span class=\"hljs-built_in\">assert</span>(dst_node &amp;&amp; node &amp;&amp; !dst_node-&gt;<span class=\"hljs-built_in\">IsFull</span>() &amp;&amp; node-&gt;<span class=\"hljs-built_in\">Is2Node</span>());\n\n    <span class=\"hljs-type\">int8_t</span> i = dst_node-&gt;<span class=\"hljs-built_in\">InsertItem</span>(node-&gt;<span class=\"hljs-built_in\">GetItem</span>(<span class=\"hljs-number\">0</span>));\n\n    dst_node-&gt;<span class=\"hljs-built_in\">SetChild</span>(i, node-&gt;<span class=\"hljs-built_in\">GetChild</span>(<span class=\"hljs-number\">0</span>));\n    dst_node-&gt;<span class=\"hljs-built_in\">SetChild</span>(i + <span class=\"hljs-number\">1</span>, node-&gt;<span class=\"hljs-built_in\">GetChild</span>(<span class=\"hljs-number\">1</span>));\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Split a 4-node to 1 parent and 2 children, and return the parent\n * node\n * @param node the node to split, it must be a 4-node\n * @return split parent node\n */</span>\n<span class=\"hljs-function\">Node *<span class=\"hljs-title\">Tree234::SplitNode</span><span class=\"hljs-params\">(Node *node)</span> </span>{\n    <span class=\"hljs-built_in\">assert</span>(node-&gt;<span class=\"hljs-built_in\">GetCount</span>() == <span class=\"hljs-number\">3</span>);\n\n    Node *left = node;\n\n    Node *right = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(node-&gt;<span class=\"hljs-built_in\">GetItem</span>(<span class=\"hljs-number\">2</span>));\n    right-&gt;<span class=\"hljs-built_in\">SetChild</span>(<span class=\"hljs-number\">0</span>, node-&gt;<span class=\"hljs-built_in\">GetChild</span>(<span class=\"hljs-number\">2</span>));\n    right-&gt;<span class=\"hljs-built_in\">SetChild</span>(<span class=\"hljs-number\">1</span>, node-&gt;<span class=\"hljs-built_in\">GetChild</span>(<span class=\"hljs-number\">3</span>));\n\n    Node *parent = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(node-&gt;<span class=\"hljs-built_in\">GetItem</span>(<span class=\"hljs-number\">1</span>));\n    parent-&gt;<span class=\"hljs-built_in\">SetChild</span>(<span class=\"hljs-number\">0</span>, left);\n    parent-&gt;<span class=\"hljs-built_in\">SetChild</span>(<span class=\"hljs-number\">1</span>, right);\n\n    left-&gt;<span class=\"hljs-built_in\">SetCount</span>(<span class=\"hljs-number\">1</span>);\n\n    <span class=\"hljs-keyword\">return</span> parent;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief A handy function to try if we can do a left rotate to the target\n * node\n *\n * Given two node, the parent and the target child, the left rotate\n * operation is uniquely identified. The source node must be the right\n * sibling of the target child. The operation can be successfully done if\n * the to_child has a right sibling and its right sibling is not 2-node.\n *\n * @param parent the parent node in this left rotate operation\n * @param to_child the target child of this left rotate operation. In our\n * case, this node is always 2-node\n * @return true if we successfully do the rotate. false if the\n * requirements are not fulfilled.\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">Tree234::TryLeftRotate</span><span class=\"hljs-params\">(Node *parent, Node *to_child)</span> </span>{\n    <span class=\"hljs-type\">int</span> to_child_index = parent-&gt;<span class=\"hljs-built_in\">GetChildIndex</span>(to_child);\n\n    <span class=\"hljs-comment\">// child is right most, can not do left rotate to it</span>\n    <span class=\"hljs-keyword\">if</span> (to_child_index &gt;= parent-&gt;<span class=\"hljs-built_in\">GetCount</span>()) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    }\n\n    Node *right_sibling = parent-&gt;<span class=\"hljs-built_in\">GetChild</span>(to_child_index + <span class=\"hljs-number\">1</span>);\n\n    <span class=\"hljs-comment\">// right sibling is 2-node. can not do left rotate.</span>\n    <span class=\"hljs-keyword\">if</span> (right_sibling-&gt;<span class=\"hljs-built_in\">Is2Node</span>()) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    }\n\n    <span class=\"hljs-built_in\">LeftRotate</span>(parent, to_child_index);\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief A handy function to try if we can do a right rotate to the target\n * node\n *\n * Given two node, the parent and the target child, the right rotate\n * operation is uniquely identified. The source node must be the left\n * sibling of the target child. The operation can be successfully done if\n * the to_child has a left sibling and its left sibling is not 2-node.\n *\n * @param parent the parent node in this right rotate operation\n * @param to_child the target child of this right rotate operation. In our\n * case, it is always 2-node\n * @return true if we successfully do the rotate. false if the\n * requirements are not fulfilled.\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">Tree234::TryRightRotate</span><span class=\"hljs-params\">(Node *parent, Node *to_child)</span> </span>{\n    <span class=\"hljs-type\">int8_t</span> to_child_index = parent-&gt;<span class=\"hljs-built_in\">GetChildIndex</span>(to_child);\n\n    <span class=\"hljs-comment\">// child is left most, can not do right rotate to it</span>\n    <span class=\"hljs-keyword\">if</span> (to_child_index &lt;= <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    }\n\n    Node *left_sibling = parent-&gt;<span class=\"hljs-built_in\">GetChild</span>(to_child_index - <span class=\"hljs-number\">1</span>);\n\n    <span class=\"hljs-comment\">// right sibling is 2-node. can not do left rotate.</span>\n    <span class=\"hljs-keyword\">if</span> (left_sibling-&gt;<span class=\"hljs-built_in\">Is2Node</span>()) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    }\n\n    <span class=\"hljs-built_in\">RightRotate</span>(parent, to_child_index - <span class=\"hljs-number\">1</span>);\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Do the actual right rotate operation\n *\n * Given parent node, and the pivot item index, the right rotate operation\n * is uniquely identified. The function assume the requirements are\n * fulfilled and won&#x27;t do any extra check. This function is call by\n * TryRightRotate(), and the condition checking should be done before call\n * it.\n *\n * @param parent the parent node in this right rotate operation\n * @param index the pivot item index of this right rotate operation.\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Tree234::RightRotate</span><span class=\"hljs-params\">(Node *parent, <span class=\"hljs-type\">int8_t</span> index)</span> </span>{\n    Node *left = parent-&gt;<span class=\"hljs-built_in\">GetItemLeftChild</span>(index);\n    Node *right = parent-&gt;<span class=\"hljs-built_in\">GetItemRightChild</span>(index);\n\n    <span class=\"hljs-built_in\">assert</span>(left &amp;&amp; left-&gt;<span class=\"hljs-built_in\">Is34Node</span>());\n    <span class=\"hljs-built_in\">assert</span>(right &amp;&amp; right-&gt;<span class=\"hljs-built_in\">Is2Node</span>());\n\n    right-&gt;<span class=\"hljs-built_in\">InsertItemByIndex</span>(<span class=\"hljs-number\">0</span>, parent-&gt;<span class=\"hljs-built_in\">GetItem</span>(index),\n                             left-&gt;<span class=\"hljs-built_in\">GetRightmostChild</span>(), <span class=\"hljs-literal\">true</span>);\n    parent-&gt;<span class=\"hljs-built_in\">SetItem</span>(index, left-&gt;<span class=\"hljs-built_in\">GetMaxItem</span>());\n    left-&gt;<span class=\"hljs-built_in\">RemoveItemByIndex</span>(left-&gt;<span class=\"hljs-built_in\">GetCount</span>() - <span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">true</span>);\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Do the actual left rotate operation\n *\n * Given parent node, and the pivot item index, the left rotate operation is\n * uniquely identified. The function assume the requirements are fulfilled\n * and won&#x27;t do any extra check. This function is call by TryLeftRotate(),\n * and the condition checking should be done before call it.\n *\n * @param parent the parent node in this right rotate operation\n * @param index the pivot item index of this right rotate operation.\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Tree234::LeftRotate</span><span class=\"hljs-params\">(Node *parent, <span class=\"hljs-type\">int8_t</span> index)</span> </span>{\n    Node *left = parent-&gt;<span class=\"hljs-built_in\">GetItemLeftChild</span>(index);\n    Node *right = parent-&gt;<span class=\"hljs-built_in\">GetItemRightChild</span>(index);\n\n    <span class=\"hljs-built_in\">assert</span>(right &amp;&amp; right-&gt;<span class=\"hljs-built_in\">Is34Node</span>());\n    <span class=\"hljs-built_in\">assert</span>(left &amp;&amp; left-&gt;<span class=\"hljs-built_in\">Is2Node</span>());\n\n    left-&gt;<span class=\"hljs-built_in\">InsertItemByIndex</span>(left-&gt;<span class=\"hljs-built_in\">GetCount</span>(), parent-&gt;<span class=\"hljs-built_in\">GetItem</span>(index),\n                            right-&gt;<span class=\"hljs-built_in\">GetLeftmostChild</span>(), <span class=\"hljs-literal\">false</span>);\n    parent-&gt;<span class=\"hljs-built_in\">SetItem</span>(index, right-&gt;<span class=\"hljs-built_in\">GetMinItem</span>());\n    right-&gt;<span class=\"hljs-built_in\">RemoveItemByIndex</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">false</span>);\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Merge the item at index of the parent node, and its left and right\n * child\n *\n * the left and right child node must be 2-node. The 3 items will be merged\n * into a 4-node. In our case the parent can be a 2-node iff it is the root.\n * Otherwise, it must be 3-node or 4-node.\n *\n * @param parent the parent node in the merging operation\n * @param index the item index of the parent node that involved in the\n * merging\n * @return the merged 4-node\n */</span>\n<span class=\"hljs-function\">Node *<span class=\"hljs-title\">Tree234::Merge</span><span class=\"hljs-params\">(Node *parent, <span class=\"hljs-type\">int8_t</span> index)</span> </span>{\n    <span class=\"hljs-built_in\">assert</span>(parent);\n\n    <span class=\"hljs-comment\">// bool is_parent_2node = parent-&gt;Is2Node();</span>\n\n    Node *left_child = parent-&gt;<span class=\"hljs-built_in\">GetItemLeftChild</span>(index);\n    Node *right_child = parent-&gt;<span class=\"hljs-built_in\">GetItemRightChild</span>(index);\n\n    <span class=\"hljs-built_in\">assert</span>(left_child-&gt;<span class=\"hljs-built_in\">Is2Node</span>() &amp;&amp; right_child-&gt;<span class=\"hljs-built_in\">Is2Node</span>());\n\n    <span class=\"hljs-type\">int64_t</span> item = parent-&gt;<span class=\"hljs-built_in\">GetItem</span>(index);\n\n    <span class=\"hljs-comment\">// 1. merge parent&#x27;s item and right child to left child</span>\n    left_child-&gt;<span class=\"hljs-built_in\">SetItem</span>(<span class=\"hljs-number\">1</span>, item);\n    left_child-&gt;<span class=\"hljs-built_in\">SetItem</span>(<span class=\"hljs-number\">2</span>, right_child-&gt;<span class=\"hljs-built_in\">GetItem</span>(<span class=\"hljs-number\">0</span>));\n    left_child-&gt;<span class=\"hljs-built_in\">SetChild</span>(<span class=\"hljs-number\">2</span>, right_child-&gt;<span class=\"hljs-built_in\">GetChild</span>(<span class=\"hljs-number\">0</span>));\n    left_child-&gt;<span class=\"hljs-built_in\">SetChild</span>(<span class=\"hljs-number\">3</span>, right_child-&gt;<span class=\"hljs-built_in\">GetChild</span>(<span class=\"hljs-number\">1</span>));\n\n    left_child-&gt;<span class=\"hljs-built_in\">SetCount</span>(<span class=\"hljs-number\">3</span>);\n\n    <span class=\"hljs-comment\">// 2. remove the parent&#x27;s item</span>\n    parent-&gt;<span class=\"hljs-built_in\">RemoveItemByIndex</span>(index, <span class=\"hljs-literal\">true</span>);\n\n    <span class=\"hljs-comment\">// 3. delete the unused right child</span>\n    <span class=\"hljs-keyword\">delete</span> right_child;\n\n    <span class=\"hljs-keyword\">return</span> left_child;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Remove item from tree\n * @param item item to remove\n * @return true if item found and removed, false otherwise\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">Tree234::Remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> item)</span> </span>{ <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">RemovePreMerge</span>(root_, item); }\n\n<span class=\"hljs-comment\">/**\n * @brief Main function implement the pre-merge remove operation\n * @param node the tree to remove item from\n * @param item item to remove\n * @return true if remove success, false otherwise\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">Tree234::RemovePreMerge</span><span class=\"hljs-params\">(Node *node, <span class=\"hljs-type\">int64_t</span> item)</span> </span>{\n    <span class=\"hljs-keyword\">while</span> (node) {\n        <span class=\"hljs-keyword\">if</span> (node-&gt;<span class=\"hljs-built_in\">IsLeaf</span>()) {\n            <span class=\"hljs-keyword\">if</span> (node-&gt;<span class=\"hljs-built_in\">Contains</span>(item)) {\n                <span class=\"hljs-keyword\">if</span> (node-&gt;<span class=\"hljs-built_in\">Is2Node</span>()) {\n                    <span class=\"hljs-comment\">// node must be root</span>\n                    <span class=\"hljs-keyword\">delete</span> node;\n                    root_ = <span class=\"hljs-literal\">nullptr</span>;\n                } <span class=\"hljs-keyword\">else</span> {\n                    node-&gt;<span class=\"hljs-built_in\">RemoveItemByIndex</span>(node-&gt;<span class=\"hljs-built_in\">GetItemIndex</span>(item), <span class=\"hljs-literal\">true</span>);\n                }\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n            }\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n        }\n\n        <span class=\"hljs-comment\">// node is internal</span>\n        <span class=\"hljs-keyword\">if</span> (node-&gt;<span class=\"hljs-built_in\">Contains</span>(item)) {\n            <span class=\"hljs-type\">int8_t</span> index = node-&gt;<span class=\"hljs-built_in\">GetItemIndex</span>(item);\n\n            <span class=\"hljs-comment\">// Here is important!!! What we do next depend on its children&#x27;s</span>\n            <span class=\"hljs-comment\">// state. Why?</span>\n            Node *left_child = node-&gt;<span class=\"hljs-built_in\">GetItemLeftChild</span>(index);\n            Node *right_child = node-&gt;<span class=\"hljs-built_in\">GetItemRightChild</span>(index);\n            <span class=\"hljs-built_in\">assert</span>(left_child &amp;&amp; right_child);\n\n            <span class=\"hljs-keyword\">if</span> (left_child-&gt;<span class=\"hljs-built_in\">Is2Node</span>() &amp;&amp; right_child-&gt;<span class=\"hljs-built_in\">Is2Node</span>()) {\n                <span class=\"hljs-comment\">// both left and right child are 2-node,we should not modify</span>\n                <span class=\"hljs-comment\">// current node in this situation. Because we are going to do</span>\n                <span class=\"hljs-comment\">// merge with its children which will move target item to next</span>\n                <span class=\"hljs-comment\">// layer. so if we replace the item with successor or</span>\n                <span class=\"hljs-comment\">// predecessor now, when we do the recursive remove with</span>\n                <span class=\"hljs-comment\">// successor or predecessor, we will result in removing the just</span>\n                <span class=\"hljs-comment\">// replaced one in the merged node. That&#x27;s not what we want.</span>\n\n                <span class=\"hljs-comment\">// we need to convert the child 2-node to 3-node or 4-node</span>\n                <span class=\"hljs-comment\">// first. First we try to see if any of them can convert to</span>\n                <span class=\"hljs-comment\">// 3-node by rotate. By using rotate we keep the empty house for</span>\n                <span class=\"hljs-comment\">// the future insertion which will be more efficient than merge.</span>\n                <span class=\"hljs-comment\">//</span>\n                <span class=\"hljs-comment\">//            | ? | node | ? |</span>\n                <span class=\"hljs-comment\">//           /    |      |    \\\n                //          /     |      |     \\\n                //         /      |      |      \\\n                //        /       |      |       \\\n                //       /        |      |        \\\n                //      /         |      |         \\\n                //     ?  left_child  right_child   ?</span>\n                <span class=\"hljs-comment\">//</span>\n\n                <span class=\"hljs-comment\">// node must be the root</span>\n                <span class=\"hljs-keyword\">if</span> (node-&gt;<span class=\"hljs-built_in\">Is2Node</span>()) {\n                    <span class=\"hljs-comment\">// this means we can&#x27;t avoid merging the target item into</span>\n                    <span class=\"hljs-comment\">// next layer, and this will cause us do different process</span>\n                    <span class=\"hljs-comment\">// compared with other cases</span>\n                    Node *new_root = <span class=\"hljs-built_in\">Merge</span>(node, index);\n                    <span class=\"hljs-keyword\">delete</span> root_;\n                    root_ = new_root;\n                    node = root_;\n\n                    <span class=\"hljs-comment\">// now node point to the</span>\n                    <span class=\"hljs-keyword\">continue</span>;\n                }\n\n                <span class=\"hljs-comment\">// here means we can avoid merging the target item into next</span>\n                <span class=\"hljs-comment\">// layer. So we convert one of its left or right child to 3-node</span>\n                <span class=\"hljs-comment\">// and then do the successor or predecessor swap and recursive</span>\n                <span class=\"hljs-comment\">// remove the next layer will successor or predecessor.</span>\n                <span class=\"hljs-keyword\">do</span> {\n                    <span class=\"hljs-keyword\">if</span> (index &gt; <span class=\"hljs-number\">0</span>) {\n                        <span class=\"hljs-comment\">// left_child has left-sibling, we check if we can do a</span>\n                        <span class=\"hljs-comment\">// rotate</span>\n                        Node *left_sibling = node-&gt;<span class=\"hljs-built_in\">GetItemLeftChild</span>(index - <span class=\"hljs-number\">1</span>);\n                        <span class=\"hljs-keyword\">if</span> (left_sibling-&gt;<span class=\"hljs-built_in\">Is34Node</span>()) {\n                            <span class=\"hljs-built_in\">RightRotate</span>(node, index - <span class=\"hljs-number\">1</span>);\n                            <span class=\"hljs-keyword\">break</span>;\n                        }\n                    }\n\n                    <span class=\"hljs-keyword\">if</span> (index &lt; node-&gt;<span class=\"hljs-built_in\">GetCount</span>() - <span class=\"hljs-number\">1</span>) {\n                        <span class=\"hljs-comment\">// right_child has right-sibling, we check if we can do</span>\n                        <span class=\"hljs-comment\">// a rotate</span>\n                        Node *right_sibling =\n                            node-&gt;<span class=\"hljs-built_in\">GetItemRightChild</span>(index + <span class=\"hljs-number\">1</span>);\n                        <span class=\"hljs-keyword\">if</span> (right_sibling-&gt;<span class=\"hljs-built_in\">Is34Node</span>()) {\n                            <span class=\"hljs-built_in\">LeftRotate</span>(node, index + <span class=\"hljs-number\">1</span>);\n                            <span class=\"hljs-keyword\">break</span>;\n                        }\n                    }\n\n                    <span class=\"hljs-comment\">// we do a merge. We avoid merging the target item, which</span>\n                    <span class=\"hljs-comment\">// may trigger another merge in the recursion process.</span>\n                    <span class=\"hljs-keyword\">if</span> (index &gt; <span class=\"hljs-number\">0</span>) {\n                        <span class=\"hljs-built_in\">Merge</span>(node, index - <span class=\"hljs-number\">1</span>);\n                        <span class=\"hljs-keyword\">break</span>;\n                    }\n\n                    <span class=\"hljs-built_in\">Merge</span>(node, index + <span class=\"hljs-number\">1</span>);\n\n                } <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">false</span>);\n            }\n\n            <span class=\"hljs-comment\">// refresh the left_child and right_child since they may be invalid</span>\n            <span class=\"hljs-comment\">// because of merge</span>\n            left_child = node-&gt;<span class=\"hljs-built_in\">GetItemLeftChild</span>(index);\n            right_child = node-&gt;<span class=\"hljs-built_in\">GetItemRightChild</span>(index);\n\n            <span class=\"hljs-keyword\">if</span> (left_child-&gt;<span class=\"hljs-built_in\">Is34Node</span>()) {\n                <span class=\"hljs-type\">int64_t</span> predecessor_item = <span class=\"hljs-built_in\">GetTreeMaxItem</span>(left_child);\n                node-&gt;<span class=\"hljs-built_in\">SetItem</span>(node-&gt;<span class=\"hljs-built_in\">GetItemIndex</span>(item), predecessor_item);\n\n                node = left_child;\n                item = predecessor_item;\n                <span class=\"hljs-keyword\">continue</span>;\n            }\n\n            <span class=\"hljs-keyword\">if</span> (right_child-&gt;<span class=\"hljs-built_in\">Is34Node</span>()) {\n                <span class=\"hljs-type\">int64_t</span> successor_item = <span class=\"hljs-built_in\">GetTreeMinItem</span>(right_child);\n                node-&gt;<span class=\"hljs-built_in\">SetItem</span>(node-&gt;<span class=\"hljs-built_in\">GetItemIndex</span>(item), successor_item);\n                node = right_child;\n                item = successor_item;\n                <span class=\"hljs-keyword\">continue</span>;\n            }\n        }\n\n        Node *next_node = node-&gt;<span class=\"hljs-built_in\">GetNextPossibleChild</span>(item);\n\n        <span class=\"hljs-keyword\">if</span> (next_node-&gt;<span class=\"hljs-built_in\">Is34Node</span>()) {\n            node = next_node;\n            <span class=\"hljs-keyword\">continue</span>;\n        }\n\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">TryRightRotate</span>(node, next_node)) {\n            node = next_node;\n            <span class=\"hljs-keyword\">continue</span>;\n        }\n\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">TryLeftRotate</span>(node, next_node)) {\n            node = next_node;\n            <span class=\"hljs-keyword\">continue</span>;\n        }\n\n        <span class=\"hljs-comment\">// get here means both left sibling and right sibling of next_node is</span>\n        <span class=\"hljs-comment\">// 2-node, so we do merge</span>\n        <span class=\"hljs-type\">int8_t</span> child_index = node-&gt;<span class=\"hljs-built_in\">GetChildIndex</span>(next_node);\n        <span class=\"hljs-keyword\">if</span> (child_index &gt; <span class=\"hljs-number\">0</span>) {\n            node = <span class=\"hljs-built_in\">Merge</span>(node, child_index - <span class=\"hljs-number\">1</span>);\n        } <span class=\"hljs-keyword\">else</span> {\n            node = <span class=\"hljs-built_in\">Merge</span>(node, child_index);\n        }\n\n    }  <span class=\"hljs-comment\">// while</span>\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Get the max item of the tree\n * @param tree the tree we will get item from\n * @return max item of the tree\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title\">Tree234::GetTreeMaxItem</span><span class=\"hljs-params\">(Node *tree)</span> </span>{\n    <span class=\"hljs-built_in\">assert</span>(tree);\n    <span class=\"hljs-type\">int64_t</span> max = <span class=\"hljs-number\">0</span>;\n\n    <span class=\"hljs-keyword\">while</span> (tree) {\n        max = tree-&gt;<span class=\"hljs-built_in\">GetMaxItem</span>();\n        tree = tree-&gt;<span class=\"hljs-built_in\">GetRightmostChild</span>();\n    }\n\n    <span class=\"hljs-keyword\">return</span> max;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Get the min item of the tree\n * @param tree the tree we will get item from\n * @return min item of the tree\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title\">Tree234::GetTreeMinItem</span><span class=\"hljs-params\">(Node *tree)</span> </span>{\n    <span class=\"hljs-built_in\">assert</span>(tree);\n    <span class=\"hljs-type\">int64_t</span> min = <span class=\"hljs-number\">0</span>;\n\n    <span class=\"hljs-keyword\">while</span> (tree) {\n        min = tree-&gt;<span class=\"hljs-built_in\">GetMinItem</span>();\n        tree = tree-&gt;<span class=\"hljs-built_in\">GetLeftmostChild</span>();\n    }\n\n    <span class=\"hljs-keyword\">return</span> min;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Print tree into a dot file\n * @param file_name output file name, if nullptr then use &quot;out.dot&quot; as default\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Tree234::Print</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> *file_name)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (!file_name) {\n        file_name = <span class=\"hljs-string\">&quot;out.dot&quot;</span>;\n    }\n\n    std::ofstream ofs;\n\n    ofs.<span class=\"hljs-built_in\">open</span>(file_name);\n    <span class=\"hljs-keyword\">if</span> (!ofs) {\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;create tree dot file failed, &quot;</span> &lt;&lt; file_name &lt;&lt; std::endl;\n        <span class=\"hljs-keyword\">return</span>;\n    }\n\n    ofs &lt;&lt; <span class=\"hljs-string\">&quot;digraph G {\\n&quot;</span>;\n    ofs &lt;&lt; <span class=\"hljs-string\">&quot;node [shape=record]\\n&quot;</span>;\n\n    <span class=\"hljs-type\">int64_t</span> index = <span class=\"hljs-number\">0</span>;\n\n    <span class=\"hljs-comment\">/** @brief This is a helper structure to do a level order traversal to print\n     * the tree. */</span>\n    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">NodeInfo</span> {\n        Node *node;     <span class=\"hljs-comment\">///&lt; tree node</span>\n        <span class=\"hljs-type\">int64_t</span> index;  <span class=\"hljs-comment\">///&lt; node index of level order that used when draw the</span>\n                        <span class=\"hljs-comment\">///&lt; link between child and parent</span>\n    };\n\n    std::queue&lt;NodeInfo&gt; q;\n\n    <span class=\"hljs-keyword\">if</span> (root_) {\n        <span class=\"hljs-comment\">// print root node</span>\n        <span class=\"hljs-built_in\">PrintNode</span>(ofs, root_, <span class=\"hljs-number\">-1</span>, index, <span class=\"hljs-number\">0</span>);\n\n        NodeInfo ni{};\n        ni.node = root_;\n        ni.index = index;\n\n        q.<span class=\"hljs-built_in\">push</span>(ni);\n\n        <span class=\"hljs-keyword\">while</span> (!q.<span class=\"hljs-built_in\">empty</span>()) {\n            NodeInfo node_info = q.<span class=\"hljs-built_in\">front</span>();\n            q.<span class=\"hljs-built_in\">pop</span>();\n\n            <span class=\"hljs-built_in\">assert</span>(node_info.node-&gt;<span class=\"hljs-built_in\">GetCount</span>() &gt; <span class=\"hljs-number\">0</span>);\n\n            <span class=\"hljs-keyword\">if</span> (!node_info.node-&gt;<span class=\"hljs-built_in\">IsLeaf</span>()) {\n                <span class=\"hljs-keyword\">if</span> (node_info.node-&gt;<span class=\"hljs-built_in\">GetCount</span>() &gt; <span class=\"hljs-number\">0</span>) {\n                    <span class=\"hljs-built_in\">PrintNode</span>(ofs, node_info.node-&gt;<span class=\"hljs-built_in\">GetChild</span>(<span class=\"hljs-number\">0</span>), node_info.index,\n                              ++index, <span class=\"hljs-number\">0</span>);\n                    ni.node = node_info.node-&gt;<span class=\"hljs-built_in\">GetChild</span>(<span class=\"hljs-number\">0</span>);\n                    ni.index = index;\n                    q.<span class=\"hljs-built_in\">push</span>(ni);\n\n                    <span class=\"hljs-built_in\">PrintNode</span>(ofs, node_info.node-&gt;<span class=\"hljs-built_in\">GetChild</span>(<span class=\"hljs-number\">1</span>), node_info.index,\n                              ++index, <span class=\"hljs-number\">1</span>);\n                    ni.node = node_info.node-&gt;<span class=\"hljs-built_in\">GetChild</span>(<span class=\"hljs-number\">1</span>);\n                    ni.index = index;\n                    q.<span class=\"hljs-built_in\">push</span>(ni);\n                }\n\n                <span class=\"hljs-keyword\">if</span> (node_info.node-&gt;<span class=\"hljs-built_in\">GetCount</span>() &gt; <span class=\"hljs-number\">1</span>) {\n                    <span class=\"hljs-built_in\">PrintNode</span>(ofs, node_info.node-&gt;<span class=\"hljs-built_in\">GetChild</span>(<span class=\"hljs-number\">2</span>), node_info.index,\n                              ++index, <span class=\"hljs-number\">2</span>);\n                    ni.node = node_info.node-&gt;<span class=\"hljs-built_in\">GetChild</span>(<span class=\"hljs-number\">2</span>);\n                    ni.index = index;\n                    q.<span class=\"hljs-built_in\">push</span>(ni);\n                }\n\n                <span class=\"hljs-keyword\">if</span> (node_info.node-&gt;<span class=\"hljs-built_in\">GetCount</span>() &gt; <span class=\"hljs-number\">2</span>) {\n                    <span class=\"hljs-built_in\">PrintNode</span>(ofs, node_info.node-&gt;<span class=\"hljs-built_in\">GetChild</span>(<span class=\"hljs-number\">3</span>), node_info.index,\n                              ++index, <span class=\"hljs-number\">3</span>);\n                    ni.node = node_info.node-&gt;<span class=\"hljs-built_in\">GetChild</span>(<span class=\"hljs-number\">3</span>);\n                    ni.index = index;\n                    q.<span class=\"hljs-built_in\">push</span>(ni);\n                }\n            }\n        }\n    }\n\n    ofs &lt;&lt; <span class=\"hljs-string\">&quot;}\\n&quot;</span>;\n    ofs.<span class=\"hljs-built_in\">close</span>();\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Print the tree to a dot file. You can convert it to picture with\n * graphviz\n * @param ofs output file stream to print to\n * @param node current node to print\n * @param parent_index current node&#x27;s parent node index, this is used to draw\n * the link from parent to current node\n * @param index current node&#x27;s index of level order which is used to name the\n * node in dot file\n * @param parent_child_index the index that current node in parent&#x27;s children\n * array, range in [0,4), help to locate the start position of the link between\n * nodes\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Tree234::PrintNode</span><span class=\"hljs-params\">(std::ofstream &amp;ofs, Node *node, <span class=\"hljs-type\">int64_t</span> parent_index,\n                        <span class=\"hljs-type\">int64_t</span> index, <span class=\"hljs-type\">int8_t</span> parent_child_index)</span> </span>{\n    <span class=\"hljs-built_in\">assert</span>(node);\n\n    <span class=\"hljs-built_in\">switch</span> (node-&gt;<span class=\"hljs-built_in\">GetCount</span>()) {\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>:\n            ofs &lt;&lt; <span class=\"hljs-string\">&quot;node_&quot;</span> &lt;&lt; index &lt;&lt; <span class=\"hljs-string\">&quot; [label=\\&quot;&lt;f0&gt; &quot;</span> &lt;&lt; node-&gt;<span class=\"hljs-built_in\">GetItem</span>(<span class=\"hljs-number\">0</span>)\n                &lt;&lt; <span class=\"hljs-string\">&quot;\\&quot;]\\n&quot;</span>;\n            <span class=\"hljs-keyword\">break</span>;\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">2</span>:\n            ofs &lt;&lt; <span class=\"hljs-string\">&quot;node_&quot;</span> &lt;&lt; index &lt;&lt; <span class=\"hljs-string\">&quot; [label=\\&quot;&lt;f0&gt; &quot;</span> &lt;&lt; node-&gt;<span class=\"hljs-built_in\">GetItem</span>(<span class=\"hljs-number\">0</span>)\n                &lt;&lt; <span class=\"hljs-string\">&quot; | &lt;f1&gt; &quot;</span> &lt;&lt; node-&gt;<span class=\"hljs-built_in\">GetItem</span>(<span class=\"hljs-number\">1</span>) &lt;&lt; <span class=\"hljs-string\">&quot;\\&quot;]\\n&quot;</span>;\n            <span class=\"hljs-keyword\">break</span>;\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">3</span>:\n            ofs &lt;&lt; <span class=\"hljs-string\">&quot;node_&quot;</span> &lt;&lt; index &lt;&lt; <span class=\"hljs-string\">&quot; [label=\\&quot;&lt;f0&gt; &quot;</span> &lt;&lt; node-&gt;<span class=\"hljs-built_in\">GetItem</span>(<span class=\"hljs-number\">0</span>)\n                &lt;&lt; <span class=\"hljs-string\">&quot; | &lt;f1&gt; &quot;</span> &lt;&lt; node-&gt;<span class=\"hljs-built_in\">GetItem</span>(<span class=\"hljs-number\">1</span>) &lt;&lt; <span class=\"hljs-string\">&quot;| &lt;f2&gt; &quot;</span>\n                &lt;&lt; node-&gt;<span class=\"hljs-built_in\">GetItem</span>(<span class=\"hljs-number\">2</span>) &lt;&lt; <span class=\"hljs-string\">&quot;\\&quot;]\\n&quot;</span>;\n            <span class=\"hljs-keyword\">break</span>;\n\n        <span class=\"hljs-keyword\">default</span>:\n            <span class=\"hljs-keyword\">break</span>;\n    }\n\n    <span class=\"hljs-comment\">// draw the edge</span>\n    <span class=\"hljs-keyword\">if</span> (parent_index &gt;= <span class=\"hljs-number\">0</span>) {\n        ofs &lt;&lt; <span class=\"hljs-string\">&quot;node_&quot;</span> &lt;&lt; parent_index &lt;&lt; <span class=\"hljs-string\">&quot;:f&quot;</span>\n            &lt;&lt; (parent_child_index == <span class=\"hljs-number\">0</span> ? <span class=\"hljs-number\">0</span> : parent_child_index - <span class=\"hljs-number\">1</span>) &lt;&lt; <span class=\"hljs-string\">&quot;:&quot;</span>\n            &lt;&lt; (parent_child_index == <span class=\"hljs-number\">0</span> ? <span class=\"hljs-string\">&quot;sw&quot;</span> : <span class=\"hljs-string\">&quot;se&quot;</span>) &lt;&lt; <span class=\"hljs-string\">&quot; -&gt; node_&quot;</span> &lt;&lt; index\n            &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n    }\n}\n}  <span class=\"hljs-comment\">// namespace tree_234</span>\n}  <span class=\"hljs-comment\">// namespace data_structures</span>\n\n\n<span class=\"hljs-comment\">/** @brief simple test to insert a given array and delete some item, and print\n * the tree*/</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test1</span><span class=\"hljs-params\">()</span> </span>{\n    std::array&lt;<span class=\"hljs-type\">int16_t</span>, 13&gt; arr = {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">14</span>};\n    data_structures::tree_234::Tree234 tree;\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i : arr) {\n        tree.<span class=\"hljs-built_in\">Insert</span>(i);\n    }\n\n    <span class=\"hljs-comment\">// tree.Remove(10);</span>\n    tree.<span class=\"hljs-built_in\">Remove</span>(<span class=\"hljs-number\">5</span>);\n    tree.<span class=\"hljs-built_in\">Print</span>();\n}\n\n<span class=\"hljs-comment\">/**\n * @brief simple test to insert continuous number of range [0, n), and print\n * the tree\n * @param n upper bound of the range number to insert\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> n)</span> </span>{\n    data_structures::tree_234::Tree234 tree;\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int64_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; i++) {\n        tree.<span class=\"hljs-built_in\">Insert</span>(i);\n    }\n\n    tree.<span class=\"hljs-built_in\">Traverse</span>();\n    tree.<span class=\"hljs-built_in\">Print</span>((std::<span class=\"hljs-built_in\">to_string</span>(n) + <span class=\"hljs-string\">&quot;.dot&quot;</span>).<span class=\"hljs-built_in\">c_str</span>());\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Main function\n * @param argc commandline argument count (ignored)\n * @param argv commandline array of arguments (ignored)\n * @returns 0 on exit\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (argc &lt; <span class=\"hljs-number\">2</span>) {\n        <span class=\"hljs-built_in\">test1</span>();  <span class=\"hljs-comment\">// execute 1st test</span>\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-built_in\">test2</span>(std::<span class=\"hljs-built_in\">stoi</span>(argv[<span class=\"hljs-number\">1</span>]));  <span class=\"hljs-comment\">// execute 2nd test</span>\n    }\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "fedom",
      "email": "hl1008@gmail.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}
