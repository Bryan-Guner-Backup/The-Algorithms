{
  "slug": "iterative-tree-traversals",
  "name": "Iterative Tree Traversals",
  "categories": ["others"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "others/iterative_tree_traversals.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/others/iterative_tree_traversals.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file\r\n * @brief Iterative version of Preorder, Postorder, and preorder [Traversal of\r\n * the Tree] (https://en.wikipedia.org/wiki/Tree_traversal)\r\n * @author [Motasim](https://github.com/motasimmakki)\r\n * @details\r\n *\r\n * ### Iterative Preorder Traversal of a tree\r\n * Create a Stack that will store the Node of Tree.\r\n * Push the root node into the stack.\r\n * Save the root into the variabe named as current, and pop and elemnt from the\r\n * stack. Store the data of current into the result array, and start traversing\r\n * from it. Push both the child node of the current node into the stack, first\r\n * right child then left child. Repeat the same set of steps untill the Stack\r\n * becomes empty. And return the result array as the preorder traversal of a\r\n * tree.\r\n *\r\n * ### Iterative Postorder Traversal of a tree\r\n * Create a Stack that will store the Node of Tree.\r\n * Push the root node into the stack.\r\n * Save the root into the variabe named as current, and pop and elemnt from the\r\n * stack. Store the data of current into the result array, and start traversing\r\n * from it. Push both the child node of the current node into the stack, first\r\n * left child then right child. Repeat the same set of steps untill the Stack\r\n * becomes empty. Now reverse the result array and then return it to the calling\r\n * function as a postorder traversal of a tree.\r\n *\r\n * ### Iterative Inorder Traversal of a tree\r\n * Create a Stack that will store the Node of Tree.\r\n * Push the root node into the stack.\r\n * Save the root into the variabe named as current.\r\n * Now iterate and take the current to the extreme left of the tree by\r\n * traversing only to its left. Pop the elemnt from the stack and assign it to\r\n * the current. Store the data of current into the result array. Repeat the same\r\n * set of steps until the Stack becomes empty or the current becomes NULL. And\r\n * return the result array as the inorder traversal of a tree.\r\n */</span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span>  <span class=\"hljs-comment\">/// for `reverse`</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>    <span class=\"hljs-comment\">/// for `assert`</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>   <span class=\"hljs-comment\">/// for I/O operations</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span>      <span class=\"hljs-comment\">/// for `stack`</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>     <span class=\"hljs-comment\">/// for `vector`</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @namespace others\r\n * @brief Other algorithms\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> others {\r\n<span class=\"hljs-comment\">/**\r\n * @namespace iterative_tree_traversals\r\n * @brief Functions for the [Traversal of the\r\n * Tree](https://en.wikipedia.org/wiki/Tree_traversal) algorithm\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> iterative_tree_traversals {\r\n<span class=\"hljs-comment\">/**\r\n * @brief defines the structure of a node of the tree\r\n */</span>\r\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> {\r\n    <span class=\"hljs-type\">int64_t</span> data = <span class=\"hljs-number\">0</span>;      <span class=\"hljs-comment\">///&lt; The value/key of the node.</span>\r\n    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> *left{};   <span class=\"hljs-comment\">///&lt; struct pointer to left subtree.</span>\r\n    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> *right{};  <span class=\"hljs-comment\">///&lt; struct pointer to right subtree.</span>\r\n};\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief defines the functions associated with the binary tree\r\n */</span>\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BinaryTree</span> {\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-function\">Node *<span class=\"hljs-title\">createNewNode</span><span class=\"hljs-params\">(\r\n        <span class=\"hljs-type\">int64_t</span>)</span></span>;  <span class=\"hljs-comment\">///&lt; function that will create new node for insertion.</span>\r\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; <span class=\"hljs-title\">preOrderIterative</span><span class=\"hljs-params\">(\r\n        Node *)</span></span>;  <span class=\"hljs-comment\">///&lt; function that takes root of the tree as an argument, and</span>\r\n                  <span class=\"hljs-comment\">///&lt; returns its preorder traversal.</span>\r\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; <span class=\"hljs-title\">postOrderIterative</span><span class=\"hljs-params\">(\r\n        Node *)</span></span>;  <span class=\"hljs-comment\">///&lt; function that takes root of the tree as an argument, and</span>\r\n                  <span class=\"hljs-comment\">///&lt; returns its postorder traversal.</span>\r\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; <span class=\"hljs-title\">inOrderIterative</span><span class=\"hljs-params\">(\r\n        Node *)</span></span>;  <span class=\"hljs-comment\">///&lt; function that takes root of the tree as an argument, and</span>\r\n                  <span class=\"hljs-comment\">///&lt; returns its inorder traversal.</span>\r\n};\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief will allocate the memory for a node and, along the data and return the\r\n * node.\r\n * @param data value that a particular node will contain.\r\n * @return pointer to the newly created node with assigned data.\r\n */</span>\r\n<span class=\"hljs-function\">Node *<span class=\"hljs-title\">BinaryTree::createNewNode</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> data)</span> </span>{\r\n    Node *node = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>();\r\n    node-&gt;data = data;\r\n    node-&gt;left = node-&gt;right = <span class=\"hljs-literal\">nullptr</span>;\r\n    <span class=\"hljs-keyword\">return</span> node;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief preOrderIterative() function that will perform the preorder traversal\r\n * iteratively, and return the result array that contain the preorder traversal\r\n * of a tree.\r\n * @param root head/root node of a tree\r\n * @return result that is containing the preorder traversal of a tree\r\n */</span>\r\n<span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; <span class=\"hljs-title\">BinaryTree::preOrderIterative</span><span class=\"hljs-params\">(Node *root)</span> </span>{\r\n    std::stack&lt;Node *&gt;\r\n        stack;  <span class=\"hljs-comment\">///&lt; is used to find and traverse the child nodes.</span>\r\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; result;  <span class=\"hljs-comment\">///&lt; list of values, sorted in pre-order.</span>\r\n\r\n    stack.<span class=\"hljs-built_in\">push</span>(root);\r\n\r\n    <span class=\"hljs-keyword\">while</span> (!stack.<span class=\"hljs-built_in\">empty</span>()) {\r\n        result.<span class=\"hljs-built_in\">push_back</span>(stack.<span class=\"hljs-built_in\">top</span>()-&gt;data);\r\n        Node *current = stack.<span class=\"hljs-built_in\">top</span>();\r\n        stack.<span class=\"hljs-built_in\">pop</span>();\r\n\r\n        <span class=\"hljs-keyword\">if</span> (current-&gt;right) {\r\n            stack.<span class=\"hljs-built_in\">push</span>(current-&gt;right);\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (current-&gt;left) {\r\n            stack.<span class=\"hljs-built_in\">push</span>(current-&gt;left);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">return</span> result;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief postOrderIterative() function that will perform the postorder\r\n * traversal iteratively, and return the result array that contain the postorder\r\n * traversal of a tree.\r\n * @param root head/root node of a tree\r\n * @return result that is containing the postorder traversal of a tree\r\n */</span>\r\n<span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; <span class=\"hljs-title\">BinaryTree::postOrderIterative</span><span class=\"hljs-params\">(Node *root)</span> </span>{\r\n    std::stack&lt;Node *&gt;\r\n        stack;  <span class=\"hljs-comment\">///&lt; is used to find and traverse the child nodes.</span>\r\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; result;  <span class=\"hljs-comment\">///&lt; List of values, sorted in post-order.</span>\r\n\r\n    stack.<span class=\"hljs-built_in\">push</span>(root);\r\n\r\n    <span class=\"hljs-keyword\">while</span> (!stack.<span class=\"hljs-built_in\">empty</span>()) {\r\n        result.<span class=\"hljs-built_in\">push_back</span>(stack.<span class=\"hljs-built_in\">top</span>()-&gt;data);\r\n        Node *current = stack.<span class=\"hljs-built_in\">top</span>();\r\n        stack.<span class=\"hljs-built_in\">pop</span>();\r\n\r\n        <span class=\"hljs-keyword\">if</span> (current-&gt;left) {\r\n            stack.<span class=\"hljs-built_in\">push</span>(current-&gt;left);\r\n        }\r\n        <span class=\"hljs-keyword\">if</span> (current-&gt;right) {\r\n            stack.<span class=\"hljs-built_in\">push</span>(current-&gt;right);\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-built_in\">reverse</span>(result.<span class=\"hljs-built_in\">begin</span>(), result.<span class=\"hljs-built_in\">end</span>());\r\n\r\n    <span class=\"hljs-keyword\">return</span> result;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief inOrderIterative() function that will perform the inorder traversal\r\n * iteratively, and return the result array that contain the inorder traversal\r\n * of a tree.\r\n * @param root head/root node of a tree\r\n * @return result that is containing the inorder traversal of a tree\r\n */</span>\r\n<span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; <span class=\"hljs-title\">BinaryTree::inOrderIterative</span><span class=\"hljs-params\">(Node *root)</span> </span>{\r\n    std::stack&lt;Node *&gt;\r\n        stack;  <span class=\"hljs-comment\">///&lt; is used to find and traverse the child nodes.</span>\r\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; result;  <span class=\"hljs-comment\">///&lt; List of values, sorted in in-order.</span>\r\n\r\n    Node *current = root;\r\n\r\n    <span class=\"hljs-keyword\">while</span> (!stack.<span class=\"hljs-built_in\">empty</span>() || current) {\r\n        <span class=\"hljs-keyword\">while</span> (current) {\r\n            stack.<span class=\"hljs-built_in\">push</span>(current);\r\n            current = current-&gt;left;\r\n        }\r\n        current = stack.<span class=\"hljs-built_in\">top</span>();\r\n        stack.<span class=\"hljs-built_in\">pop</span>();\r\n        result.<span class=\"hljs-built_in\">push_back</span>(current-&gt;data);\r\n        current = current-&gt;right;\r\n    }\r\n    <span class=\"hljs-keyword\">return</span> result;\r\n}\r\n}  <span class=\"hljs-comment\">// namespace iterative_tree_traversals</span>\r\n}  <span class=\"hljs-comment\">// namespace others</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Test the computed preorder with the actual preorder.\r\n * @param binaryTree instance of the BinaryTree class\r\n * @param root head/root node of a tree\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test1</span><span class=\"hljs-params\">(others::iterative_tree_traversals::BinaryTree binaryTree,\r\n                  others::iterative_tree_traversals::Node *root)</span> </span>{\r\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; actual_result{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">3</span>};\r\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt;\r\n        result;  <span class=\"hljs-comment\">///&lt; result stores the preorder traversal of the binary tree</span>\r\n\r\n    <span class=\"hljs-comment\">// Calling preOrderIterative() function by passing a root node,</span>\r\n    <span class=\"hljs-comment\">// and storing the preorder traversal in result.</span>\r\n    result = binaryTree.<span class=\"hljs-built_in\">preOrderIterative</span>(root);\r\n\r\n    <span class=\"hljs-comment\">// Self-testing the result using `assert`</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; result.<span class=\"hljs-built_in\">size</span>(); i++) {\r\n        <span class=\"hljs-built_in\">assert</span>(actual_result[i] == result[i]);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// Printing the result storing preorder.</span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nPreOrder Traversal Is : &quot;</span> &lt;&lt; std::endl;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i : result) {\r\n        std::cout &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot;  &quot;</span>;\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Test the computed postorder with the actual postorder.\r\n * @param binaryTree instance of BinaryTree class\r\n * @param root head/root node of a tree\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test2</span><span class=\"hljs-params\">(others::iterative_tree_traversals::BinaryTree binaryTree,\r\n                  others::iterative_tree_traversals::Node *root)</span> </span>{\r\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; actual_result{<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span>};\r\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt;\r\n        result;  <span class=\"hljs-comment\">///&lt; result stores the postorder traversal of the binary tree.</span>\r\n\r\n    <span class=\"hljs-comment\">// Calling postOrderIterative() function by passing a root node,</span>\r\n    <span class=\"hljs-comment\">// and storing the postorder traversal in result.</span>\r\n    result = binaryTree.<span class=\"hljs-built_in\">postOrderIterative</span>(root);\r\n\r\n    <span class=\"hljs-comment\">// Self-testing the result using `assert`</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; result.<span class=\"hljs-built_in\">size</span>(); i++) {\r\n        <span class=\"hljs-built_in\">assert</span>(actual_result[i] == result[i]);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// Printing the result storing postorder.</span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nPostOrder Traversal Is : &quot;</span> &lt;&lt; std::endl;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i : result) {\r\n        std::cout &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot;  &quot;</span>;\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Test the computed inorder with the actual inorder.\r\n * @param binaryTree instance of BinaryTree class\r\n * @param root head/root node of a tree\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test3</span><span class=\"hljs-params\">(others::iterative_tree_traversals::BinaryTree binaryTree,\r\n                  others::iterative_tree_traversals::Node *root)</span> </span>{\r\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; actual_result{<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>};\r\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt;\r\n        result;  <span class=\"hljs-comment\">///&lt; result stores the inorder traversal of the binary tree.</span>\r\n\r\n    <span class=\"hljs-comment\">// Calling inOrderIterative() function by passing a root node,</span>\r\n    <span class=\"hljs-comment\">// and storing the inorder traversal in result.</span>\r\n    result = binaryTree.<span class=\"hljs-built_in\">inOrderIterative</span>(root);\r\n\r\n    <span class=\"hljs-comment\">// Self-testing the result using `assert`</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; result.<span class=\"hljs-built_in\">size</span>(); i++) {\r\n        <span class=\"hljs-built_in\">assert</span>(actual_result[i] == result[i]);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// Printing the result storing inorder.</span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nInOrder Traversal Is : &quot;</span> &lt;&lt; std::endl;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i : result) {\r\n        std::cout &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot;  &quot;</span>;\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Test the computed preorder with the actual preorder on negative value.\r\n * @param binaryTree instance of BinaryTree class\r\n * @param root head/root node of a tree\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test4</span><span class=\"hljs-params\">(others::iterative_tree_traversals::BinaryTree binaryTree,\r\n                  others::iterative_tree_traversals::Node *root)</span> </span>{\r\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; actual_result{<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-2</span>, <span class=\"hljs-number\">-4</span>, <span class=\"hljs-number\">-5</span>, <span class=\"hljs-number\">-3</span>};\r\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt;\r\n        result;  <span class=\"hljs-comment\">///&lt; result stores the preorder traversal of the binary tree</span>\r\n\r\n    <span class=\"hljs-comment\">// Calling preOrderIterative() function by passing a root node,</span>\r\n    <span class=\"hljs-comment\">// and storing the preorder traversal in result.</span>\r\n    result = binaryTree.<span class=\"hljs-built_in\">preOrderIterative</span>(root);\r\n\r\n    <span class=\"hljs-comment\">// Self-testing the result using `assert`</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; result.<span class=\"hljs-built_in\">size</span>(); i++) {\r\n        <span class=\"hljs-built_in\">assert</span>(actual_result[i] == result[i]);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// Printing the result storing preorder.</span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nPreOrder Traversal Is : &quot;</span> &lt;&lt; std::endl;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i : result) {\r\n        std::cout &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot;  &quot;</span>;\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Test the computed postorder with the actual postorder on negative\r\n * value.\r\n * @param binaryTree instance of BinaryTree class\r\n * @param root head/root node of a tree\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test5</span><span class=\"hljs-params\">(others::iterative_tree_traversals::BinaryTree binaryTree,\r\n                  others::iterative_tree_traversals::Node *root)</span> </span>{\r\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; actual_result{<span class=\"hljs-number\">-4</span>, <span class=\"hljs-number\">-5</span>, <span class=\"hljs-number\">-2</span>, <span class=\"hljs-number\">-3</span>, <span class=\"hljs-number\">-1</span>};\r\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt;\r\n        result;  <span class=\"hljs-comment\">///&lt; result stores the postorder traversal of the binary tree.</span>\r\n\r\n    <span class=\"hljs-comment\">// Calling postOrderIterative() function by passing a root node,</span>\r\n    <span class=\"hljs-comment\">// and storing the postorder traversal in result.</span>\r\n    result = binaryTree.<span class=\"hljs-built_in\">postOrderIterative</span>(root);\r\n\r\n    <span class=\"hljs-comment\">// Self-testing the result using `assert`</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; result.<span class=\"hljs-built_in\">size</span>(); i++) {\r\n        <span class=\"hljs-built_in\">assert</span>(actual_result[i] == result[i]);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// Printing the result storing postorder.</span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nPostOrder Traversal Is : &quot;</span> &lt;&lt; std::endl;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i : result) {\r\n        std::cout &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot;  &quot;</span>;\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Test the computed inorder with the actual inorder on negative value.\r\n * @param binaryTree instance of BinaryTree class\r\n * @param root head/root node of a tree\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test6</span><span class=\"hljs-params\">(others::iterative_tree_traversals::BinaryTree binaryTree,\r\n                  others::iterative_tree_traversals::Node *root)</span> </span>{\r\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; actual_result{<span class=\"hljs-number\">-4</span>, <span class=\"hljs-number\">-2</span>, <span class=\"hljs-number\">-5</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-3</span>};\r\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt;\r\n        result;  <span class=\"hljs-comment\">///&lt; result stores the inorder traversal of the binary tree.</span>\r\n\r\n    <span class=\"hljs-comment\">// Calling inOrderIterative() function by passing a root node,</span>\r\n    <span class=\"hljs-comment\">// and storing the inorder traversal in result.</span>\r\n    result = binaryTree.<span class=\"hljs-built_in\">inOrderIterative</span>(root);\r\n\r\n    <span class=\"hljs-comment\">// Self-testing the result using `assert`</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; result.<span class=\"hljs-built_in\">size</span>(); i++) {\r\n        <span class=\"hljs-built_in\">assert</span>(actual_result[i] == result[i]);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// Printing the result storing inorder.</span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nInOrder Traversal Is : &quot;</span> &lt;&lt; std::endl;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i : result) {\r\n        std::cout &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot;  &quot;</span>;\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Main function\r\n * @returns 0 on exit\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-comment\">// Creating a tree with the following structure,</span>\r\n    <span class=\"hljs-comment\">/*\r\n              1\r\n            /   \\\r\n           2     3\r\n         /   \\\r\n        4     5\r\n    */</span>\r\n\r\n    others::iterative_tree_traversals::BinaryTree\r\n        binaryTree;  <span class=\"hljs-comment\">///&lt; instace of BinaryTree, used to access its members</span>\r\n                     <span class=\"hljs-comment\">///&lt; functions.</span>\r\n    others::iterative_tree_traversals::Node *root = binaryTree.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">1</span>);\r\n    root-&gt;left = binaryTree.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">2</span>);\r\n    root-&gt;right = binaryTree.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">3</span>);\r\n    root-&gt;left-&gt;left = binaryTree.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">4</span>);\r\n    root-&gt;left-&gt;right = binaryTree.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">5</span>);\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n| Tests for positive data value |&quot;</span> &lt;&lt; std::endl;\r\n    <span class=\"hljs-built_in\">test1</span>(binaryTree, root);  <span class=\"hljs-comment\">// run preorder-iterative test</span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nPre-order test Passed!&quot;</span> &lt;&lt; std::endl;\r\n\r\n    <span class=\"hljs-built_in\">test2</span>(binaryTree, root);  <span class=\"hljs-comment\">// run postorder-iterative test</span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nPost-order test Passed!&quot;</span> &lt;&lt; std::endl;\r\n\r\n    <span class=\"hljs-built_in\">test3</span>(binaryTree, root);  <span class=\"hljs-comment\">// run inorder-iterative test</span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nIn-order test Passed!&quot;</span> &lt;&lt; std::endl;\r\n\r\n    <span class=\"hljs-comment\">// Modifying tree for negative values.</span>\r\n    root-&gt;data = <span class=\"hljs-number\">-1</span>;\r\n    root-&gt;left-&gt;data = <span class=\"hljs-number\">-2</span>;\r\n    root-&gt;right-&gt;data = <span class=\"hljs-number\">-3</span>;\r\n    root-&gt;left-&gt;left-&gt;data = <span class=\"hljs-number\">-4</span>;\r\n    root-&gt;left-&gt;right-&gt;data = <span class=\"hljs-number\">-5</span>;\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n| Tests for negative data values |&quot;</span> &lt;&lt; std::endl;\r\n    <span class=\"hljs-built_in\">test4</span>(binaryTree, root);  <span class=\"hljs-comment\">// run preorder-iterative test on negative values</span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nPre-order test on-negative value Passed!&quot;</span> &lt;&lt; std::endl;\r\n\r\n    <span class=\"hljs-built_in\">test5</span>(binaryTree, root);  <span class=\"hljs-comment\">// run postorder-iterative test on negative values</span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nPost-order test on-negative value Passed!&quot;</span> &lt;&lt; std::endl;\r\n\r\n    <span class=\"hljs-built_in\">test6</span>(binaryTree, root);  <span class=\"hljs-comment\">// run inorder-iterative test on negative values</span>\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nIn-order test on-negative value Passed!&quot;</span> &lt;&lt; std::endl;\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "Swastika Gupta",
      "email": "64654203+Swastyy@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Motasim",
      "email": "44056349+motasimmakki@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}
