{
  "slug": "durand-kerner-roots",
  "name": "Durand Kerner Roots",
  "categories": ["numericalmethods"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "numerical_methods/durand_kerner_roots.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/numerical_methods/durand_kerner_roots.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * \\brief Compute all possible approximate roots of any given polynomial using\n * [Durand Kerner\n * algorithm](https://en.wikipedia.org/wiki/Durand%E2%80%93Kerner_method)\n * \\author [Krishna Vedala](https://github.com/kvedala)\n *\n * Test the algorithm online:\n * https://gist.github.com/kvedala/27f1b0b6502af935f6917673ec43bcd7\n *\n * Try the highly unstable Wilkinson&#x27;s polynomial:\n * ```\n * ./numerical_methods/durand_kerner_roots 1 -210 20615 -1256850 53327946\n * -1672280820 40171771630 -756111184500 11310276995381 -135585182899530\n * 1307535010540395 -10142299865511450 63030812099294896 -311333643161390640\n * 1206647803780373360 -3599979517947607200 8037811822645051776\n * -12870931245150988800 13803759753640704000 -8752948036761600000\n * 2432902008176640000\n * ```\n * Sample implementation results to compute approximate roots of the equation\n * \\f$x^4-1=0\\f$:\\n\n * &lt;img\n * src=&quot;https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/numerical_methods/durand_kerner_error.svg&quot;\n * width=&quot;400&quot; alt=&quot;Error evolution during root approximations computed every\n * iteration.&quot;/&gt; &lt;img\n * src=&quot;https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/numerical_methods/durand_kerner_roots.svg&quot;\n * width=&quot;400&quot; alt=&quot;Roots evolution - shows the initial approximation of the\n * roots and their convergence to a final approximation along with the iterative\n * approximations&quot; /&gt;\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;complex&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdlib&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ctime&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;fstream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;valarray&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;omp.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ACCURACY 1e-10 <span class=\"hljs-comment\">/**&lt; maximum accuracy limit */</span></span>\n\n<span class=\"hljs-comment\">/**\n * Evaluate the value of a polynomial with given coefficients\n * \\param[in] coeffs coefficients of the polynomial\n * \\param[in] x point at which to evaluate the polynomial\n * \\returns \\f$f(x)\\f$\n **/</span>\n<span class=\"hljs-function\">std::complex&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">poly_function</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::valarray&lt;<span class=\"hljs-type\">double</span>&gt; &amp;coeffs,\n                                   std::complex&lt;<span class=\"hljs-type\">double</span>&gt; x)</span> </span>{\n    <span class=\"hljs-type\">double</span> real = <span class=\"hljs-number\">0.f</span>, imag = <span class=\"hljs-number\">0.f</span>;\n    <span class=\"hljs-type\">int</span> n;\n\n    <span class=\"hljs-comment\">// #ifdef _OPENMP</span>\n    <span class=\"hljs-comment\">// #pragma omp target teams distribute reduction(+ : real, imag)</span>\n    <span class=\"hljs-comment\">// #endif</span>\n    <span class=\"hljs-keyword\">for</span> (n = <span class=\"hljs-number\">0</span>; n &lt; coeffs.<span class=\"hljs-built_in\">size</span>(); n++) {\n        std::complex&lt;<span class=\"hljs-type\">double</span>&gt; tmp =\n            coeffs[n] * std::<span class=\"hljs-built_in\">pow</span>(x, coeffs.<span class=\"hljs-built_in\">size</span>() - n - <span class=\"hljs-number\">1</span>);\n        real += tmp.<span class=\"hljs-built_in\">real</span>();\n        imag += tmp.<span class=\"hljs-built_in\">imag</span>();\n    }\n\n    <span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">complex</span>&lt;<span class=\"hljs-type\">double</span>&gt;(real, imag);\n}\n\n<span class=\"hljs-comment\">/**\n * create a textual form of complex number\n * \\param[in] x point at which to evaluate the polynomial\n * \\returns pointer to converted string\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> *<span class=\"hljs-title\">complex_str</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::complex&lt;<span class=\"hljs-type\">double</span>&gt; &amp;x)</span> </span>{\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> MAX_BUFF_SIZE 50</span>\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">char</span> msg[MAX_BUFF_SIZE];\n\n    std::<span class=\"hljs-built_in\">snprintf</span>(msg, MAX_BUFF_SIZE, <span class=\"hljs-string\">&quot;% 7.04g%+7.04gj&quot;</span>, x.<span class=\"hljs-built_in\">real</span>(), x.<span class=\"hljs-built_in\">imag</span>());\n\n    <span class=\"hljs-keyword\">return</span> msg;\n}\n\n<span class=\"hljs-comment\">/**\n * check for termination condition\n * \\param[in] delta point at which to evaluate the polynomial\n * \\returns `false` if termination not reached\n * \\returns `true` if termination reached\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">check_termination</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span> delta)</span> </span>{\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span> past_delta = INFINITY;\n    <span class=\"hljs-keyword\">if</span> (std::<span class=\"hljs-built_in\">abs</span>(past_delta - delta) &lt;= ACCURACY || delta &lt; ACCURACY)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    past_delta = delta;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * Implements Durand Kerner iterative algorithm to compute all roots of a\n * polynomial.\n *\n * \\param[in] coeffs coefficients of the polynomial\n * \\param[out] roots the computed roots of the polynomial\n * \\param[in] write_log flag whether to save the log file (default = `false`)\n * \\returns pair of values - number of iterations taken and final accuracy\n * achieved\n */</span>\n<span class=\"hljs-function\">std::pair&lt;<span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">durand_kerner_algo</span><span class=\"hljs-params\">(\n    <span class=\"hljs-keyword\">const</span> std::valarray&lt;<span class=\"hljs-type\">double</span>&gt; &amp;coeffs,\n    std::valarray&lt;std::complex&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *roots, <span class=\"hljs-type\">bool</span> write_log = <span class=\"hljs-literal\">false</span>)</span> </span>{\n    <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span> tol_condition = <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-type\">uint32_t</span> iter = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">int</span> n;\n    std::ofstream log_file;\n\n    <span class=\"hljs-keyword\">if</span> (write_log) {\n        <span class=\"hljs-comment\">/*\n         * store intermediate values to a CSV file\n         */</span>\n        log_file.<span class=\"hljs-built_in\">open</span>(<span class=\"hljs-string\">&quot;durand_kerner.log.csv&quot;</span>);\n        <span class=\"hljs-keyword\">if</span> (!log_file.<span class=\"hljs-built_in\">is_open</span>()) {\n            <span class=\"hljs-built_in\">perror</span>(<span class=\"hljs-string\">&quot;Unable to create a storage log file!&quot;</span>);\n            std::<span class=\"hljs-built_in\">exit</span>(EXIT_FAILURE);\n        }\n        log_file &lt;&lt; <span class=\"hljs-string\">&quot;iter#,&quot;</span>;\n\n        <span class=\"hljs-keyword\">for</span> (n = <span class=\"hljs-number\">0</span>; n &lt; roots-&gt;<span class=\"hljs-built_in\">size</span>(); n++) log_file &lt;&lt; <span class=\"hljs-string\">&quot;root_&quot;</span> &lt;&lt; n &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span>;\n\n        log_file &lt;&lt; <span class=\"hljs-string\">&quot;avg. correction&quot;</span>;\n        log_file &lt;&lt; <span class=\"hljs-string\">&quot;\\n0,&quot;</span>;\n        <span class=\"hljs-keyword\">for</span> (n = <span class=\"hljs-number\">0</span>; n &lt; roots-&gt;<span class=\"hljs-built_in\">size</span>(); n++)\n            log_file &lt;&lt; <span class=\"hljs-built_in\">complex_str</span>((*roots)[n]) &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span>;\n    }\n\n    <span class=\"hljs-type\">bool</span> break_loop = <span class=\"hljs-literal\">false</span>;\n    <span class=\"hljs-keyword\">while</span> (!<span class=\"hljs-built_in\">check_termination</span>(tol_condition) &amp;&amp; iter &lt; INT16_MAX &amp;&amp;\n           !break_loop) {\n        tol_condition = <span class=\"hljs-number\">0</span>;\n        iter++;\n        break_loop = <span class=\"hljs-literal\">false</span>;\n\n        <span class=\"hljs-keyword\">if</span> (log_file.<span class=\"hljs-built_in\">is_open</span>())\n            log_file &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span> &lt;&lt; iter &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span>;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp parallel for shared(break_loop, tol_condition)</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n        <span class=\"hljs-keyword\">for</span> (n = <span class=\"hljs-number\">0</span>; n &lt; roots-&gt;<span class=\"hljs-built_in\">size</span>(); n++) {\n            <span class=\"hljs-keyword\">if</span> (break_loop)\n                <span class=\"hljs-keyword\">continue</span>;\n\n            std::complex&lt;<span class=\"hljs-type\">double</span>&gt; numerator, denominator;\n            numerator = <span class=\"hljs-built_in\">poly_function</span>(coeffs, (*roots)[n]);\n            denominator = <span class=\"hljs-number\">1.0</span>;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; roots-&gt;<span class=\"hljs-built_in\">size</span>(); i++)\n                <span class=\"hljs-keyword\">if</span> (i != n)\n                    denominator *= (*roots)[n] - (*roots)[i];\n\n            std::complex&lt;<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span>&gt; delta = numerator / denominator;\n\n            <span class=\"hljs-keyword\">if</span> (std::<span class=\"hljs-built_in\">isnan</span>(std::<span class=\"hljs-built_in\">abs</span>(delta)) || std::<span class=\"hljs-built_in\">isinf</span>(std::<span class=\"hljs-built_in\">abs</span>(delta))) {\n                std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;\\n\\nOverflow/underrun error - got value = &quot;</span>\n                          &lt;&lt; std::<span class=\"hljs-built_in\">abs</span>(delta) &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n                <span class=\"hljs-comment\">// return std::pair&lt;uint32_t, double&gt;(iter, tol_condition);</span>\n                break_loop = <span class=\"hljs-literal\">true</span>;\n            }\n\n            (*roots)[n] -= delta;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp critical</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n            tol_condition = std::<span class=\"hljs-built_in\">max</span>(tol_condition, std::<span class=\"hljs-built_in\">abs</span>(std::<span class=\"hljs-built_in\">abs</span>(delta)));\n        }\n        <span class=\"hljs-comment\">// tol_condition /= (degree - 1);</span>\n\n        <span class=\"hljs-keyword\">if</span> (break_loop)\n            <span class=\"hljs-keyword\">break</span>;\n\n        <span class=\"hljs-keyword\">if</span> (log_file.<span class=\"hljs-built_in\">is_open</span>()) {\n            <span class=\"hljs-keyword\">for</span> (n = <span class=\"hljs-number\">0</span>; n &lt; roots-&gt;<span class=\"hljs-built_in\">size</span>(); n++)\n                log_file &lt;&lt; <span class=\"hljs-built_in\">complex_str</span>((*roots)[n]) &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span>;\n        }\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined(DEBUG) || !defined(NDEBUG)</span>\n        <span class=\"hljs-keyword\">if</span> (iter % <span class=\"hljs-number\">500</span> == <span class=\"hljs-number\">0</span>) {\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Iter: &quot;</span> &lt;&lt; iter &lt;&lt; <span class=\"hljs-string\">&quot;\\t&quot;</span>;\n            <span class=\"hljs-keyword\">for</span> (n = <span class=\"hljs-number\">0</span>; n &lt; roots-&gt;<span class=\"hljs-built_in\">size</span>(); n++)\n                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\t&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">complex_str</span>((*roots)[n]);\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\t\\tabsolute average change: &quot;</span> &lt;&lt; tol_condition\n                      &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n        }\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n        <span class=\"hljs-keyword\">if</span> (log_file.<span class=\"hljs-built_in\">is_open</span>())\n            log_file &lt;&lt; tol_condition;\n    }\n\n    <span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">pair</span>&lt;<span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span>&gt;(iter, tol_condition);\n}\n\n<span class=\"hljs-comment\">/**\n * Self test the algorithm by checking the roots for \\f$x^2+4=0\\f$ to which the\n * roots are \\f$0 \\pm 2i\\f$\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test1</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">const</span> std::valarray&lt;<span class=\"hljs-type\">double</span>&gt; coeffs = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">4</span>};  <span class=\"hljs-comment\">// x^2 - 2 = 0</span>\n    std::valarray&lt;std::complex&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">roots</span>(<span class=\"hljs-number\">2</span>);\n    std::valarray&lt;std::complex&lt;<span class=\"hljs-type\">double</span>&gt;&gt; expected = {\n        std::<span class=\"hljs-built_in\">complex</span>&lt;<span class=\"hljs-type\">double</span>&gt;(<span class=\"hljs-number\">0.</span>, <span class=\"hljs-number\">2.</span>),\n        std::<span class=\"hljs-built_in\">complex</span>&lt;<span class=\"hljs-type\">double</span>&gt;(<span class=\"hljs-number\">0.</span>, <span class=\"hljs-number\">-2.</span>)  <span class=\"hljs-comment\">// known expected roots</span>\n    };\n\n    <span class=\"hljs-comment\">/* initialize root approximations with random values */</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> n = <span class=\"hljs-number\">0</span>; n &lt; roots.<span class=\"hljs-built_in\">size</span>(); n++) {\n        roots[n] = std::<span class=\"hljs-built_in\">complex</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span>, std::<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span>);\n        roots[n] -= <span class=\"hljs-number\">50.f</span>;\n        roots[n] /= <span class=\"hljs-number\">25.f</span>;\n    }\n\n    <span class=\"hljs-keyword\">auto</span> result = <span class=\"hljs-built_in\">durand_kerner_algo</span>(coeffs, &amp;roots, <span class=\"hljs-literal\">false</span>);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; roots.<span class=\"hljs-built_in\">size</span>(); i++) {\n        <span class=\"hljs-comment\">// check if approximations are have &lt; 0.1% error with one of the</span>\n        <span class=\"hljs-comment\">// expected roots</span>\n        <span class=\"hljs-type\">bool</span> err1 = <span class=\"hljs-literal\">false</span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; roots.<span class=\"hljs-built_in\">size</span>(); j++)\n            err1 |= std::<span class=\"hljs-built_in\">abs</span>(std::<span class=\"hljs-built_in\">abs</span>(roots[i] - expected[j])) &lt; <span class=\"hljs-number\">1e-3</span>;\n        <span class=\"hljs-built_in\">assert</span>(err1);\n    }\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 1 passed! - &quot;</span> &lt;&lt; result.first &lt;&lt; <span class=\"hljs-string\">&quot; iterations, &quot;</span>\n              &lt;&lt; result.second &lt;&lt; <span class=\"hljs-string\">&quot; accuracy&quot;</span>\n              &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * Self test the algorithm by checking the roots for \\f$0.015625x^3-1=0\\f$ to\n * which the roots are \\f$(4+0i),\\,(-2\\pm3.464i)\\f$\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test2</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">const</span> std::valarray&lt;<span class=\"hljs-type\">double</span>&gt; coeffs = {<span class=\"hljs-comment\">// 0.015625 x^3 - 1 = 0</span>\n                                          <span class=\"hljs-number\">1.</span> / <span class=\"hljs-number\">64.</span>, <span class=\"hljs-number\">0.</span>, <span class=\"hljs-number\">0.</span>, <span class=\"hljs-number\">-1.</span>};\n    std::valarray&lt;std::complex&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">roots</span>(<span class=\"hljs-number\">3</span>);\n    <span class=\"hljs-keyword\">const</span> std::valarray&lt;std::complex&lt;<span class=\"hljs-type\">double</span>&gt;&gt; expected = {\n        std::<span class=\"hljs-built_in\">complex</span>&lt;<span class=\"hljs-type\">double</span>&gt;(<span class=\"hljs-number\">4.</span>, <span class=\"hljs-number\">0.</span>), std::<span class=\"hljs-built_in\">complex</span>&lt;<span class=\"hljs-type\">double</span>&gt;(<span class=\"hljs-number\">-2.</span>, <span class=\"hljs-number\">3.46410162</span>),\n        std::<span class=\"hljs-built_in\">complex</span>&lt;<span class=\"hljs-type\">double</span>&gt;(<span class=\"hljs-number\">-2.</span>, <span class=\"hljs-number\">-3.46410162</span>)  <span class=\"hljs-comment\">// known expected roots</span>\n    };\n\n    <span class=\"hljs-comment\">/* initialize root approximations with random values */</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> n = <span class=\"hljs-number\">0</span>; n &lt; roots.<span class=\"hljs-built_in\">size</span>(); n++) {\n        roots[n] = std::<span class=\"hljs-built_in\">complex</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span>, std::<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span>);\n        roots[n] -= <span class=\"hljs-number\">50.f</span>;\n        roots[n] /= <span class=\"hljs-number\">25.f</span>;\n    }\n\n    <span class=\"hljs-keyword\">auto</span> result = <span class=\"hljs-built_in\">durand_kerner_algo</span>(coeffs, &amp;roots, <span class=\"hljs-literal\">false</span>);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; roots.<span class=\"hljs-built_in\">size</span>(); i++) {\n        <span class=\"hljs-comment\">// check if approximations are have &lt; 0.1% error with one of the</span>\n        <span class=\"hljs-comment\">// expected roots</span>\n        <span class=\"hljs-type\">bool</span> err1 = <span class=\"hljs-literal\">false</span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; roots.<span class=\"hljs-built_in\">size</span>(); j++)\n            err1 |= std::<span class=\"hljs-built_in\">abs</span>(std::<span class=\"hljs-built_in\">abs</span>(roots[i] - expected[j])) &lt; <span class=\"hljs-number\">1e-3</span>;\n        <span class=\"hljs-built_in\">assert</span>(err1);\n    }\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 2 passed! - &quot;</span> &lt;&lt; result.first &lt;&lt; <span class=\"hljs-string\">&quot; iterations, &quot;</span>\n              &lt;&lt; result.second &lt;&lt; <span class=\"hljs-string\">&quot; accuracy&quot;</span>\n              &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n}\n\n<span class=\"hljs-comment\">/***\n * Main function.\n * The comandline input arguments are taken as coeffiecients of a\n *polynomial. For example, this command\n * ```sh\n * ./durand_kerner_roots 1 0 -4\n * ```\n * will find roots of the polynomial \\f$1\\cdot x^2 + 0\\cdot x^1 + (-4)=0\\f$\n **/</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span> </span>{\n    <span class=\"hljs-comment\">/* initialize random seed: */</span>\n    std::<span class=\"hljs-built_in\">srand</span>(std::<span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">nullptr</span>));\n\n    <span class=\"hljs-keyword\">if</span> (argc &lt; <span class=\"hljs-number\">2</span>) {\n        <span class=\"hljs-built_in\">test1</span>();  <span class=\"hljs-comment\">// run tests when no input is provided</span>\n        <span class=\"hljs-built_in\">test2</span>();  <span class=\"hljs-comment\">// and skip tests when input polynomial is provided</span>\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Please pass the coefficients of the polynomial as &quot;</span>\n                     <span class=\"hljs-string\">&quot;commandline &quot;</span>\n                     <span class=\"hljs-string\">&quot;arguments.\\n&quot;</span>;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n    }\n\n    <span class=\"hljs-type\">int</span> n, degree = argc - <span class=\"hljs-number\">1</span>;              <span class=\"hljs-comment\">// detected polynomial degree</span>\n    <span class=\"hljs-function\">std::valarray&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">coeffs</span><span class=\"hljs-params\">(degree)</span></span>;  <span class=\"hljs-comment\">// create coefficiencts array</span>\n\n    <span class=\"hljs-comment\">// number of roots = degree - 1</span>\n    std::valarray&lt;std::complex&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">s0</span>(degree - <span class=\"hljs-number\">1</span>);\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Computing the roots for:\\n\\t&quot;</span>;\n    <span class=\"hljs-keyword\">for</span> (n = <span class=\"hljs-number\">0</span>; n &lt; degree; n++) {\n        coeffs[n] = <span class=\"hljs-built_in\">strtod</span>(argv[n + <span class=\"hljs-number\">1</span>], <span class=\"hljs-literal\">nullptr</span>);\n        <span class=\"hljs-keyword\">if</span> (n &lt; degree - <span class=\"hljs-number\">1</span> &amp;&amp; coeffs[n] != <span class=\"hljs-number\">0</span>)\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;(&quot;</span> &lt;&lt; coeffs[n] &lt;&lt; <span class=\"hljs-string\">&quot;) x^&quot;</span> &lt;&lt; degree - n - <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-string\">&quot; + &quot;</span>;\n        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (coeffs[n] != <span class=\"hljs-number\">0</span>)\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;(&quot;</span> &lt;&lt; coeffs[n] &lt;&lt; <span class=\"hljs-string\">&quot;) x^&quot;</span> &lt;&lt; degree - n - <span class=\"hljs-number\">1</span>\n                      &lt;&lt; <span class=\"hljs-string\">&quot; = 0\\n&quot;</span>;\n\n        <span class=\"hljs-comment\">/* initialize root approximations with random values */</span>\n        <span class=\"hljs-keyword\">if</span> (n &lt; degree - <span class=\"hljs-number\">1</span>) {\n            s0[n] = std::<span class=\"hljs-built_in\">complex</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span>, std::<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span>);\n            s0[n] -= <span class=\"hljs-number\">50.f</span>;\n            s0[n] /= <span class=\"hljs-number\">50.f</span>;\n        }\n    }\n\n    <span class=\"hljs-comment\">// numerical errors less when the first coefficient is &quot;1&quot;</span>\n    <span class=\"hljs-comment\">// hence, we normalize the first coefficient</span>\n    {\n        <span class=\"hljs-type\">double</span> tmp = coeffs[<span class=\"hljs-number\">0</span>];\n        coeffs /= tmp;\n    }\n\n    <span class=\"hljs-type\">clock_t</span> end_time, start_time = <span class=\"hljs-built_in\">clock</span>();\n    <span class=\"hljs-keyword\">auto</span> result = <span class=\"hljs-built_in\">durand_kerner_algo</span>(coeffs, &amp;s0, <span class=\"hljs-literal\">true</span>);\n    end_time = <span class=\"hljs-built_in\">clock</span>();\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nIterations: &quot;</span> &lt;&lt; result.first &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n    <span class=\"hljs-keyword\">for</span> (n = <span class=\"hljs-number\">0</span>; n &lt; degree - <span class=\"hljs-number\">1</span>; n++)\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\t&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">complex_str</span>(s0[n]) &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;absolute average change: &quot;</span> &lt;&lt; result.second &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Time taken: &quot;</span>\n              &lt;&lt; <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(end_time - start_time) / CLOCKS_PER_SEC\n              &lt;&lt; <span class=\"hljs-string\">&quot; sec\\n&quot;</span>;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "c": {
      "dir": "numerical_methods/durand_kerner_roots.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/numerical_methods/durand_kerner_roots.c",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * \\brief Compute all possible approximate roots of any given polynomial using\n * [Durand Kerner\n * algorithm](https://en.wikipedia.org/wiki/Durand%E2%80%93Kerner_method)\n *\n * \\author [Krishna Vedala](https://github.com/kvedala)\n *\n * Test the algorithm online:\n * https://gist.github.com/kvedala/27f1b0b6502af935f6917673ec43bcd7\n *\n * Try the highly unstable Wilkinson&#x27;s polynomial:\n * ```\n * ./numerical_methods/durand_kerner_roots.c 1 -210 20615 -1256850 53327946\n * -1672280820 40171771630 -756111184500 11310276995381 -135585182899530\n * 1307535010540395 -10142299865511450 63030812099294896 -311333643161390640\n * 1206647803780373360 -3599979517947607200 8037811822645051776\n * -12870931245150988800 13803759753640704000 -8752948036761600000\n * 2432902008176640000\n * ```\n * Sample implementation results to compute approximate roots of the equation\n * \\f$x^4-1=0\\f$:\\n\n * &lt;img\n * src=&quot;https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/durand_kerner_error.svg&quot;\n * width=&quot;400&quot; alt=&quot;Error evolution during root approximations computed every\n * iteration.&quot;/&gt; &lt;img\n * src=&quot;https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/durand_kerner_roots.svg&quot;\n * width=&quot;400&quot; alt=&quot;Roots evolution - shows the initial approximation of the\n * roots and their convergence to a final approximation along with the iterative\n * approximations&quot; /&gt;\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;complex.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;limits.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;math.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;time.h&gt;</span></span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ACCURACY 1e-10 <span class=\"hljs-comment\">/**&lt; maximum accuracy limit */</span></span>\n\n<span class=\"hljs-comment\">/**\n * Evaluate the value of a polynomial with given coefficients\n * \\param[in] coeffs coefficients of the polynomial\n * \\param[in] degree degree of polynomial\n * \\param[in] x point at which to evaluate the polynomial\n * \\returns \\f$f(x)\\f$\n */</span>\n<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-type\">complex</span> <span class=\"hljs-title function_\">poly_function</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span> *coeffs, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> degree,\n                                  <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-type\">complex</span> x)</span>\n{\n    <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-type\">complex</span> out = <span class=\"hljs-number\">0.</span>;\n    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> n;\n\n    <span class=\"hljs-keyword\">for</span> (n = <span class=\"hljs-number\">0</span>; n &lt; degree; n++) out += coeffs[n] * cpow(x, degree - n - <span class=\"hljs-number\">1</span>);\n\n    <span class=\"hljs-keyword\">return</span> out;\n}\n\n<span class=\"hljs-comment\">/**\n * create a textual form of complex number\n * \\param[in] x point at which to evaluate the polynomial\n * \\returns pointer to converted string\n */</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> *<span class=\"hljs-title function_\">complex_str</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-type\">complex</span> x)</span>\n{\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">char</span> msg[<span class=\"hljs-number\">50</span>];\n    <span class=\"hljs-type\">double</span> r = creal(x);\n    <span class=\"hljs-type\">double</span> c = cimag(x);\n\n    <span class=\"hljs-built_in\">sprintf</span>(msg, <span class=\"hljs-string\">&quot;% 7.04g%+7.04gj&quot;</span>, r, c);\n\n    <span class=\"hljs-keyword\">return</span> msg;\n}\n\n<span class=\"hljs-comment\">/**\n * check for termination condition\n * \\param[in] delta point at which to evaluate the polynomial\n * \\returns 0 if termination not reached\n * \\returns 1 if termination reached\n */</span>\n<span class=\"hljs-type\">char</span> <span class=\"hljs-title function_\">check_termination</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span> delta)</span>\n{\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span> past_delta = INFINITY;\n    <span class=\"hljs-keyword\">if</span> (fabsl(past_delta - delta) &lt;= ACCURACY || delta &lt; ACCURACY)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n    past_delta = delta;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n\n<span class=\"hljs-comment\">/***\n * the comandline inputs are taken as coeffiecients of a polynomial\n */</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span>\n{\n    <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span> *coeffs = <span class=\"hljs-literal\">NULL</span>;\n    <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-type\">complex</span> *s0 = <span class=\"hljs-literal\">NULL</span>;\n    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> degree = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> n, i;\n\n    <span class=\"hljs-keyword\">if</span> (argc &lt; <span class=\"hljs-number\">2</span>)\n    {\n        <span class=\"hljs-built_in\">printf</span>(\n            <span class=\"hljs-string\">&quot;Please pass the coefficients of the polynomial as commandline &quot;</span>\n            <span class=\"hljs-string\">&quot;arguments.\\n&quot;</span>);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n    }\n\n    degree = argc - <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">/* detected polynomial degree */</span>\n    coeffs = (<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(\n        degree * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span>)); <span class=\"hljs-comment\">/* store all input coefficients */</span>\n    s0 = (<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-type\">complex</span> *)<span class=\"hljs-built_in\">malloc</span>(\n        (degree - <span class=\"hljs-number\">1</span>) *\n        <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-type\">complex</span>)); <span class=\"hljs-comment\">/* number of roots = degree-1 */</span>\n\n    <span class=\"hljs-comment\">/* initialize random seed: */</span>\n    srand(time(<span class=\"hljs-literal\">NULL</span>));\n\n    <span class=\"hljs-keyword\">if</span> (!coeffs || !s0)\n    {\n        perror(<span class=\"hljs-string\">&quot;Unable to allocate memory!&quot;</span>);\n        <span class=\"hljs-keyword\">if</span> (coeffs)\n            <span class=\"hljs-built_in\">free</span>(coeffs);\n        <span class=\"hljs-keyword\">if</span> (s0)\n            <span class=\"hljs-built_in\">free</span>(s0);\n        <span class=\"hljs-keyword\">return</span> EXIT_FAILURE;\n    }\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined(DEBUG) || !defined(NDEBUG)</span>\n    <span class=\"hljs-comment\">/**\n     * store intermediate values to a CSV file\n     */</span>\n    FILE *log_file = fopen(<span class=\"hljs-string\">&quot;durand_kerner.log.csv&quot;</span>, <span class=\"hljs-string\">&quot;wt&quot;</span>);\n    <span class=\"hljs-keyword\">if</span> (!log_file)\n    {\n        perror(<span class=\"hljs-string\">&quot;Unable to create a storage log file!&quot;</span>);\n        <span class=\"hljs-built_in\">free</span>(coeffs);\n        <span class=\"hljs-built_in\">free</span>(s0);\n        <span class=\"hljs-keyword\">return</span> EXIT_FAILURE;\n    }\n    <span class=\"hljs-built_in\">fprintf</span>(log_file, <span class=\"hljs-string\">&quot;iter#,&quot;</span>);\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Computing the roots for:\\n\\t&quot;</span>);\n    <span class=\"hljs-keyword\">for</span> (n = <span class=\"hljs-number\">0</span>; n &lt; degree; n++)\n    {\n        coeffs[n] = strtod(argv[n + <span class=\"hljs-number\">1</span>], <span class=\"hljs-literal\">NULL</span>);\n        <span class=\"hljs-keyword\">if</span> (n &lt; degree - <span class=\"hljs-number\">1</span> &amp;&amp; coeffs[n] != <span class=\"hljs-number\">0</span>)\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;(%Lg) x^%d + &quot;</span>, coeffs[n], degree - n - <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (coeffs[n] != <span class=\"hljs-number\">0</span>)\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;(%Lg) x^%d = 0\\n&quot;</span>, coeffs[n], degree - n - <span class=\"hljs-number\">1</span>);\n\n        <span class=\"hljs-type\">double</span> tmp;\n        <span class=\"hljs-keyword\">if</span> (n &gt; <span class=\"hljs-number\">0</span>)\n            coeffs[n] /= tmp; <span class=\"hljs-comment\">/* numerical errors less when the first\n                                 coefficient is &quot;1&quot; */</span>\n        <span class=\"hljs-keyword\">else</span>\n        {\n            tmp = coeffs[<span class=\"hljs-number\">0</span>];\n            coeffs[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;\n        }\n\n        <span class=\"hljs-comment\">/* initialize root approximations with random values */</span>\n        <span class=\"hljs-keyword\">if</span> (n &lt; degree - <span class=\"hljs-number\">1</span>)\n        {\n            s0[n] = (<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span>)rand() + (<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span>)rand() * I;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined(DEBUG) || !defined(NDEBUG)</span>\n            <span class=\"hljs-built_in\">fprintf</span>(log_file, <span class=\"hljs-string\">&quot;root_%d,&quot;</span>, n);\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n        }\n    }\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined(DEBUG) || !defined(NDEBUG)</span>\n    <span class=\"hljs-built_in\">fprintf</span>(log_file, <span class=\"hljs-string\">&quot;avg. correction&quot;</span>);\n    <span class=\"hljs-built_in\">fprintf</span>(log_file, <span class=\"hljs-string\">&quot;\\n0,&quot;</span>);\n    <span class=\"hljs-keyword\">for</span> (n = <span class=\"hljs-number\">0</span>; n &lt; degree - <span class=\"hljs-number\">1</span>; n++)\n        <span class=\"hljs-built_in\">fprintf</span>(log_file, <span class=\"hljs-string\">&quot;%s,&quot;</span>, complex_str(s0[n]));\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n    <span class=\"hljs-type\">double</span> tol_condition = <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> iter = <span class=\"hljs-number\">0</span>;\n\n    <span class=\"hljs-type\">clock_t</span> end_time, start_time = clock();\n    <span class=\"hljs-keyword\">while</span> (!check_termination(tol_condition) &amp;&amp; iter &lt; INT_MAX)\n    {\n        <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-type\">complex</span> delta = <span class=\"hljs-number\">0</span>;\n        tol_condition = <span class=\"hljs-number\">0</span>;\n        iter++;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined(DEBUG) || !defined(NDEBUG)</span>\n        <span class=\"hljs-built_in\">fprintf</span>(log_file, <span class=\"hljs-string\">&quot;\\n%ld,&quot;</span>, iter);\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n        <span class=\"hljs-keyword\">for</span> (n = <span class=\"hljs-number\">0</span>; n &lt; degree - <span class=\"hljs-number\">1</span>; n++)\n        {\n            <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-type\">complex</span> numerator =\n                poly_function(coeffs, degree, s0[n]);\n            <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-type\">complex</span> denominator = <span class=\"hljs-number\">1.0</span>;\n            <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; degree - <span class=\"hljs-number\">1</span>; i++)\n                <span class=\"hljs-keyword\">if</span> (i != n)\n                    denominator *= s0[n] - s0[i];\n\n            delta = numerator / denominator;\n\n            <span class=\"hljs-keyword\">if</span> (isnan(cabsl(delta)) || isinf(cabsl(delta)))\n            {\n                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\n\\nOverflow/underrun error - got value = %Lg&quot;</span>,\n                       cabsl(delta));\n                <span class=\"hljs-keyword\">goto</span> end;\n            }\n\n            s0[n] -= delta;\n\n            tol_condition = fmaxl(tol_condition, fabsl(cabsl(delta)));\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined(DEBUG) || !defined(NDEBUG)</span>\n            <span class=\"hljs-built_in\">fprintf</span>(log_file, <span class=\"hljs-string\">&quot;%s,&quot;</span>, complex_str(s0[n]));\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n        }\n        <span class=\"hljs-comment\">// tol_condition /= (degree - 1);</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined(DEBUG) || !defined(NDEBUG)</span>\n        <span class=\"hljs-keyword\">if</span> (iter % <span class=\"hljs-number\">500</span> == <span class=\"hljs-number\">0</span>)\n        {\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Iter: %lu\\t&quot;</span>, iter);\n            <span class=\"hljs-keyword\">for</span> (n = <span class=\"hljs-number\">0</span>; n &lt; degree - <span class=\"hljs-number\">1</span>; n++) <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\t%s&quot;</span>, complex_str(s0[n]));\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\t\\tabsolute average change: %.4g\\n&quot;</span>, tol_condition);\n        }\n\n        <span class=\"hljs-built_in\">fprintf</span>(log_file, <span class=\"hljs-string\">&quot;%.4g&quot;</span>, tol_condition);\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    }\nend:\n\n    end_time = clock();\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined(DEBUG) || !defined(NDEBUG)</span>\n    fclose(log_file);\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\nIterations: %lu\\n&quot;</span>, iter);\n    <span class=\"hljs-keyword\">for</span> (n = <span class=\"hljs-number\">0</span>; n &lt; degree - <span class=\"hljs-number\">1</span>; n++) <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\t%s\\n&quot;</span>, complex_str(s0[n]));\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;absolute average change: %.4g\\n&quot;</span>, tol_condition);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Time taken: %.4g sec\\n&quot;</span>,\n           (end_time - start_time) / (<span class=\"hljs-type\">double</span>)CLOCKS_PER_SEC);\n\n    <span class=\"hljs-built_in\">free</span>(coeffs);\n    <span class=\"hljs-built_in\">free</span>(s0);\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 12
    },
    {
      "name": "Krishna Vedala",
      "email": "krishna.vedala@ieee.org",
      "commits": 23
    }
  ],
  "explanationUrl": {}
}
