{
  "slug": "thin-singular-vector-decomposition",
  "name": "Thin Singular Vector Decomposition",
  "categories": ["datastructures", "linkedlist"],
  "body": {},
  "implementations": {
    "c-sharp": {
      "dir": "Algorithms/Numeric/Decomposition/ThinSVD.cs",
      "url": "https://github.com/TheAlgorithms/C-Sharp/blob/master/Algorithms/Numeric/Decomposition/ThinSVD.cs",
      "code": "<span class=\"hljs-keyword\">using</span> System;\n<span class=\"hljs-keyword\">using</span> Utilities.Extensions;\n<span class=\"hljs-keyword\">using</span> M = Utilities.Extensions.MatrixExtensions;\n<span class=\"hljs-keyword\">using</span> V = Utilities.Extensions.VectorExtensions;\n\n<span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">Algorithms.Numeric.Decomposition</span>\n{\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Singular Vector Decomposition decomposes any general matrix into its</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     singular values and a set of orthonormal bases.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ThinSvd</span>\n    {\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Computes a random unit vector.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;dimensions&quot;&gt;</span>The dimensions of the required vector.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>The unit vector.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">double</span>[] <span class=\"hljs-title\">RandomUnitVector</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span> dimensions</span>)</span>\n        {\n            Random random = <span class=\"hljs-keyword\">new</span>();\n            <span class=\"hljs-built_in\">double</span>[] result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">double</span>[dimensions];\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; dimensions; i++)\n            {\n                result[i] = <span class=\"hljs-number\">2</span> * random.NextDouble() - <span class=\"hljs-number\">1</span>;\n            }\n\n            <span class=\"hljs-keyword\">var</span> magnitude = result.Magnitude();\n            result = result.Scale(<span class=\"hljs-number\">1</span> / magnitude);\n            <span class=\"hljs-keyword\">return</span> result;\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Computes a single singular vector for the given matrix, corresponding to the largest singular value.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;matrix&quot;&gt;</span>The matrix.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>A singular vector, with dimension equal to number of columns of the matrix.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">double</span>[] <span class=\"hljs-title\">Decompose1D</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">double</span>[,] matrix</span>)</span> =&gt;\n            Decompose1D(matrix, <span class=\"hljs-number\">1E-5</span>, <span class=\"hljs-number\">100</span>);\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Computes a single singular vector for the given matrix, corresponding to the largest singular value.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;matrix&quot;&gt;</span>The matrix.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;epsilon&quot;&gt;</span>The error margin.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;maxIterations&quot;&gt;</span>The maximum number of iterations.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>A singular vector, with dimension equal to number of columns of the matrix.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">double</span>[] <span class=\"hljs-title\">Decompose1D</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">double</span>[,] matrix, <span class=\"hljs-built_in\">double</span> epsilon, <span class=\"hljs-built_in\">int</span> maxIterations</span>)</span>\n        {\n            <span class=\"hljs-keyword\">var</span> n = matrix.GetLength(<span class=\"hljs-number\">1</span>);\n            <span class=\"hljs-keyword\">var</span> iterations = <span class=\"hljs-number\">0</span>;\n            <span class=\"hljs-built_in\">double</span> mag;\n            <span class=\"hljs-built_in\">double</span>[] lastIteration;\n            <span class=\"hljs-built_in\">double</span>[] currIteration = RandomUnitVector(n);\n            <span class=\"hljs-built_in\">double</span>[,] b = matrix.Transpose().Multiply(matrix);\n            <span class=\"hljs-keyword\">do</span>\n            {\n                lastIteration = currIteration.Copy();\n                currIteration = b.MultiplyVector(lastIteration);\n                currIteration = currIteration.Scale(<span class=\"hljs-number\">100</span>);\n                mag = currIteration.Magnitude();\n                <span class=\"hljs-keyword\">if</span> (mag &gt; epsilon)\n                {\n                    currIteration = currIteration.Scale(<span class=\"hljs-number\">1</span> / mag);\n                }\n\n                iterations++;\n            }\n            <span class=\"hljs-keyword\">while</span> (lastIteration.Dot(currIteration) &lt; <span class=\"hljs-number\">1</span> - epsilon &amp;&amp; iterations &lt; maxIterations);\n\n            <span class=\"hljs-keyword\">return</span> currIteration;\n        }\n\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> (<span class=\"hljs-params\"><span class=\"hljs-built_in\">double</span>[,] U, <span class=\"hljs-built_in\">double</span>[] S, <span class=\"hljs-built_in\">double</span>[,] V</span>) <span class=\"hljs-title\">Decompose</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">double</span>[,] matrix</span>)</span> =&gt;\n            Decompose(matrix, <span class=\"hljs-number\">1E-5</span>, <span class=\"hljs-number\">100</span>);\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Computes the SVD for the given matrix, with singular values arranged from greatest to least.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;matrix&quot;&gt;</span>The matrix.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;epsilon&quot;&gt;</span>The error margin.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;maxIterations&quot;&gt;</span>The maximum number of iterations.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>The SVD.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> (<span class=\"hljs-params\"><span class=\"hljs-built_in\">double</span>[,] U, <span class=\"hljs-built_in\">double</span>[] S, <span class=\"hljs-built_in\">double</span>[,] V</span>) <span class=\"hljs-title\">Decompose</span>(<span class=\"hljs-params\">\n            <span class=\"hljs-built_in\">double</span>[,] matrix,\n            <span class=\"hljs-built_in\">double</span> epsilon,\n            <span class=\"hljs-built_in\">int</span> maxIterations</span>)</span>\n        {\n            <span class=\"hljs-keyword\">var</span> m = matrix.GetLength(<span class=\"hljs-number\">0</span>);\n            <span class=\"hljs-keyword\">var</span> n = matrix.GetLength(<span class=\"hljs-number\">1</span>);\n            <span class=\"hljs-keyword\">var</span> numValues = Math.Min(m, n);\n\n            <span class=\"hljs-comment\">// sigmas is be a diagonal matrix, hence only a vector is needed</span>\n            <span class=\"hljs-built_in\">double</span>[] sigmas = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">double</span>[numValues];\n            <span class=\"hljs-built_in\">double</span>[,] us = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">double</span>[m, numValues];\n            <span class=\"hljs-built_in\">double</span>[,] vs = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">double</span>[n, numValues];\n\n            <span class=\"hljs-comment\">// keep track of progress</span>\n            <span class=\"hljs-built_in\">double</span>[,] remaining = matrix.Copy();\n\n            <span class=\"hljs-comment\">// for each singular value</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; numValues; i++)\n            {\n                <span class=\"hljs-comment\">// compute the v singular vector</span>\n                <span class=\"hljs-built_in\">double</span>[] v = Decompose1D(remaining, epsilon, maxIterations);\n                <span class=\"hljs-built_in\">double</span>[] u = matrix.MultiplyVector(v);\n\n                <span class=\"hljs-comment\">// compute the contribution of this pair of singular vectors</span>\n                <span class=\"hljs-built_in\">double</span>[,] contrib = u.OuterProduct(v);\n\n                <span class=\"hljs-comment\">// extract the singular value</span>\n                <span class=\"hljs-keyword\">var</span> s = u.Magnitude();\n\n                <span class=\"hljs-comment\">// v and u should be unit vectors</span>\n                <span class=\"hljs-keyword\">if</span> (s &lt; epsilon)\n                {\n                    u = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">double</span>[m];\n                    v = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">double</span>[n];\n                }\n                <span class=\"hljs-keyword\">else</span>\n                {\n                    u = u.Scale(<span class=\"hljs-number\">1</span> / s);\n                }\n\n                <span class=\"hljs-comment\">// save u, v and s into the result</span>\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; u.Length; j++)\n                {\n                    us[j, i] = u[j];\n                }\n\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; v.Length; j++)\n                {\n                    vs[j, i] = v[j];\n                }\n\n                sigmas[i] = s;\n\n                <span class=\"hljs-comment\">// remove the contribution of this pair and compute the rest</span>\n                remaining = remaining.Subtract(contrib);\n            }\n\n            <span class=\"hljs-keyword\">return</span> (U: us, S: sigmas, V: vs);\n        }\n    }\n}\n"
    }
  },
  "contributors": [],
  "explanationUrl": {}
}
