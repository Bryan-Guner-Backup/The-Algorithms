{
  "slug": "qr-eigen-values",
  "name": "Qr Eigen Values",
  "categories": ["numericalmethods"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "numerical_methods/qr_eigen_values.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/numerical_methods/qr_eigen_values.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * \\brief Compute real eigen values and eigen vectors of a symmetric matrix\n * using [QR decomposition](https://en.wikipedia.org/wiki/QR_decomposition)\n * method.\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdlib&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ctime&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;omp.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;./qr_decompose.h&quot;</span></span>\n<span class=\"hljs-keyword\">using</span> qr_algorithm::<span class=\"hljs-keyword\">operator</span>&lt;&lt;;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> LIMS 9 <span class=\"hljs-comment\">/**&lt; limit of range of matrix values */</span></span>\n\n<span class=\"hljs-comment\">/**\n * create a symmetric square matrix of given size with random elements. A\n * symmetric square matrix will *always* have real eigen values.\n *\n * \\param[out] A matrix to create (must be pre-allocated in memory)\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">create_matrix</span><span class=\"hljs-params\">(std::valarray&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *A)</span> </span>{\n    <span class=\"hljs-type\">int</span> i, j, tmp, lim2 = LIMS &gt;&gt; <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-type\">int</span> N = A-&gt;<span class=\"hljs-built_in\">size</span>();\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n        A[<span class=\"hljs-number\">0</span>][i][i] = (std::<span class=\"hljs-built_in\">rand</span>() % LIMS) - lim2;\n        <span class=\"hljs-keyword\">for</span> (j = i + <span class=\"hljs-number\">1</span>; j &lt; N; j++) {\n            tmp = (std::<span class=\"hljs-built_in\">rand</span>() % LIMS) - lim2;\n            A[<span class=\"hljs-number\">0</span>][i][j] = tmp;  <span class=\"hljs-comment\">// summetrically distribute random values</span>\n            A[<span class=\"hljs-number\">0</span>][j][i] = tmp;\n        }\n    }\n}\n\n<span class=\"hljs-comment\">/**\n * Perform multiplication of two matrices.\n * * R2 must be equal to C1\n * * Resultant matrix size should be R1xC2\n * \\param[in] A first matrix to multiply\n * \\param[in] B second matrix to multiply\n * \\param[out] OUT output matrix (must be pre-allocated)\n * \\returns pointer to resultant matrix\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">mat_mul</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::valarray&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; &amp;A,\n             <span class=\"hljs-keyword\">const</span> std::valarray&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; &amp;B,\n             std::valarray&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *OUT)</span> </span>{\n    <span class=\"hljs-type\">int</span> R1 = A.<span class=\"hljs-built_in\">size</span>();\n    <span class=\"hljs-type\">int</span> C1 = A[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>();\n    <span class=\"hljs-type\">int</span> R2 = B.<span class=\"hljs-built_in\">size</span>();\n    <span class=\"hljs-type\">int</span> C2 = B[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>();\n    <span class=\"hljs-keyword\">if</span> (C1 != R2) {\n        <span class=\"hljs-built_in\">perror</span>(<span class=\"hljs-string\">&quot;Matrix dimensions mismatch!&quot;</span>);\n        <span class=\"hljs-keyword\">return</span>;\n    }\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; R1; i++) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; C2; j++) {\n            OUT[<span class=\"hljs-number\">0</span>][i][j] = <span class=\"hljs-number\">0.f</span>;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; C1; k++) {\n                OUT[<span class=\"hljs-number\">0</span>][i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">namespace</span> qr_algorithm {\n<span class=\"hljs-comment\">/** Compute eigen values using iterative shifted QR decomposition algorithm as\n * follows:\n * 1. Use last diagonal element of A as eigen value approximation \\f$c\\f$\n * 2. Shift diagonals of matrix \\f$A&#x27; = A - cI\\f$\n * 3. Decompose matrix \\f$A&#x27;=QR\\f$\n * 4. Compute next approximation \\f$A&#x27;_1 = RQ \\f$\n * 5. Shift diagonals back \\f$A_1 = A&#x27;_1 + cI\\f$\n * 6. Termination condition check: last element below diagonal is almost 0\n *   1. If not 0, go back to step 1 with the new approximation \\f$A_1\\f$\n *   2. If 0, continue to step 7\n * 7. Save last known \\f$c\\f$ as the eigen value.\n * 8. Are all eigen values found?\n *   1. If not, remove last row and column of \\f$A_1\\f$ and go back to step 1.\n *   2. If yes, stop.\n *\n * \\note The matrix \\f$A\\f$ gets modified\n *\n * \\param[in,out] A matrix to compute eigen values for\n * \\param[in] print_intermediates (optional) whether to print intermediate A, Q\n * and R matrices (default = `false`)\n */</span>\n<span class=\"hljs-function\">std::valarray&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">eigen_values</span><span class=\"hljs-params\">(std::valarray&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *A,\n                                   <span class=\"hljs-type\">bool</span> print_intermediates = <span class=\"hljs-literal\">false</span>)</span> </span>{\n    <span class=\"hljs-type\">int</span> rows = A-&gt;<span class=\"hljs-built_in\">size</span>();\n    <span class=\"hljs-type\">int</span> columns = rows;\n    <span class=\"hljs-type\">int</span> counter = <span class=\"hljs-number\">0</span>, num_eigs = rows - <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-type\">double</span> last_eig = <span class=\"hljs-number\">0</span>;\n\n    std::valarray&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">Q</span>(rows);\n    std::valarray&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">R</span>(columns);\n\n    <span class=\"hljs-comment\">/* number of eigen values = matrix size */</span>\n    <span class=\"hljs-function\">std::valarray&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">eigen_vals</span><span class=\"hljs-params\">(rows)</span></span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; rows; i++) {\n        Q[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(columns);\n        R[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(columns);\n    }\n\n    <span class=\"hljs-comment\">/* continue till all eigen values are found */</span>\n    <span class=\"hljs-keyword\">while</span> (num_eigs &gt; <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-comment\">/* iterate with QR decomposition */</span>\n        <span class=\"hljs-keyword\">while</span> (std::<span class=\"hljs-built_in\">abs</span>(A[<span class=\"hljs-number\">0</span>][num_eigs][num_eigs - <span class=\"hljs-number\">1</span>]) &gt;\n               std::numeric_limits&lt;<span class=\"hljs-type\">double</span>&gt;::<span class=\"hljs-built_in\">epsilon</span>()) {\n            <span class=\"hljs-comment\">// initial approximation = last diagonal element</span>\n            last_eig = A[<span class=\"hljs-number\">0</span>][num_eigs][num_eigs];\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; rows; i++) {\n                A[<span class=\"hljs-number\">0</span>][i][i] -= last_eig; <span class=\"hljs-comment\">/* A - cI */</span>\n            }\n\n            <span class=\"hljs-built_in\">qr_decompose</span>(*A, &amp;Q, &amp;R);\n\n            <span class=\"hljs-keyword\">if</span> (print_intermediates) {\n                std::cout &lt;&lt; *A &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n                std::cout &lt;&lt; Q &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n                std::cout &lt;&lt; R &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-------------------- %d ---------------------\\n&quot;</span>,\n                       ++counter);\n            }\n\n            <span class=\"hljs-comment\">// new approximation A&#x27; = R * Q</span>\n            <span class=\"hljs-built_in\">mat_mul</span>(R, Q, A);\n\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; rows; i++) {\n                A[<span class=\"hljs-number\">0</span>][i][i] += last_eig; <span class=\"hljs-comment\">/* A + cI */</span>\n            }\n        }\n\n        <span class=\"hljs-comment\">/* store the converged eigen value */</span>\n        eigen_vals[num_eigs] = last_eig;\n        <span class=\"hljs-comment\">// A[0][num_eigs][num_eigs];</span>\n        <span class=\"hljs-keyword\">if</span> (print_intermediates) {\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;========================\\n&quot;</span>;\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Eigen value: &quot;</span> &lt;&lt; last_eig &lt;&lt; <span class=\"hljs-string\">&quot;,\\n&quot;</span>;\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;========================\\n&quot;</span>;\n        }\n\n        num_eigs--;\n        rows--;\n        columns--;\n    }\n    eigen_vals[<span class=\"hljs-number\">0</span>] = A[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>];\n\n    <span class=\"hljs-keyword\">if</span> (print_intermediates) {\n        std::cout &lt;&lt; Q &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n        std::cout &lt;&lt; R &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n    }\n\n    <span class=\"hljs-keyword\">return</span> eigen_vals;\n}\n\n}  <span class=\"hljs-comment\">// namespace qr_algorithm</span>\n\n<span class=\"hljs-comment\">/**\n * test function to compute eigen values of a 2x2 matrix\n * \\f[\\begin{bmatrix}\n * 5 &amp; 7\\\\\n * 7 &amp; 11\n * \\end{bmatrix}\\f]\n * which are approximately, {15.56158, 0.384227}\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test1</span><span class=\"hljs-params\">()</span> </span>{\n    std::valarray&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; X = {{<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>}, {<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>}};\n    <span class=\"hljs-type\">double</span> y[] = {<span class=\"hljs-number\">15.56158</span>, <span class=\"hljs-number\">0.384227</span>};  <span class=\"hljs-comment\">// corresponding y-values</span>\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;------- Test 1 -------&quot;</span> &lt;&lt; std::endl;\n    std::valarray&lt;<span class=\"hljs-type\">double</span>&gt; eig_vals = qr_algorithm::<span class=\"hljs-built_in\">eigen_values</span>(&amp;X);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">2</span>; i++) {\n        std::cout &lt;&lt; i + <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-string\">&quot;/2 Checking for &quot;</span> &lt;&lt; y[i] &lt;&lt; <span class=\"hljs-string\">&quot; --&gt; &quot;</span>;\n        <span class=\"hljs-type\">bool</span> result = <span class=\"hljs-literal\">false</span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">2</span> &amp;&amp; !result; j++) {\n            <span class=\"hljs-keyword\">if</span> (std::<span class=\"hljs-built_in\">abs</span>(y[i] - eig_vals[j]) &lt; <span class=\"hljs-number\">0.1</span>) {\n                result = <span class=\"hljs-literal\">true</span>;\n                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;(&quot;</span> &lt;&lt; eig_vals[j] &lt;&lt; <span class=\"hljs-string\">&quot;) &quot;</span>;\n            }\n        }\n        <span class=\"hljs-built_in\">assert</span>(result);  <span class=\"hljs-comment\">// ensure that i^th expected eigen value was computed</span>\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;found\\n&quot;</span>;\n    }\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 1 Passed\\n\\n&quot;</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * test function to compute eigen values of a 2x2 matrix\n * \\f[\\begin{bmatrix}\n * -4&amp; 4&amp; 2&amp; 0&amp; -3\\\\\n * 4&amp; -4&amp; 4&amp; -3&amp; -1\\\\\n * 2&amp; 4&amp; 4&amp; 3&amp; -3\\\\\n * 0&amp; -3&amp; 3&amp; -1&amp;-1\\\\\n * -3&amp; -1&amp; -3&amp; -3&amp; 0\n * \\end{bmatrix}\\f]\n * which are approximately, {9.27648, -9.26948, 2.0181, -1.03516, -5.98994}\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test2</span><span class=\"hljs-params\">()</span> </span>{\n    std::valarray&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; X = {{<span class=\"hljs-number\">-4</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-3</span>},\n                                              {<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">-4</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">-3</span>, <span class=\"hljs-number\">-1</span>},\n                                              {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">-3</span>},\n                                              {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-3</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-3</span>},\n                                              {<span class=\"hljs-number\">-3</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-3</span>, <span class=\"hljs-number\">-3</span>, <span class=\"hljs-number\">0</span>}};\n    <span class=\"hljs-type\">double</span> y[] = {<span class=\"hljs-number\">9.27648</span>, <span class=\"hljs-number\">-9.26948</span>, <span class=\"hljs-number\">2.0181</span>, <span class=\"hljs-number\">-1.03516</span>,\n                  <span class=\"hljs-number\">-5.98994</span>};  <span class=\"hljs-comment\">// corresponding y-values</span>\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;------- Test 2 -------&quot;</span> &lt;&lt; std::endl;\n    std::valarray&lt;<span class=\"hljs-type\">double</span>&gt; eig_vals = qr_algorithm::<span class=\"hljs-built_in\">eigen_values</span>(&amp;X);\n\n    std::cout &lt;&lt; X &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>\n              &lt;&lt; <span class=\"hljs-string\">&quot;Eigen values: &quot;</span> &lt;&lt; eig_vals &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5</span>; i++) {\n        std::cout &lt;&lt; i + <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-string\">&quot;/5 Checking for &quot;</span> &lt;&lt; y[i] &lt;&lt; <span class=\"hljs-string\">&quot; --&gt; &quot;</span>;\n        <span class=\"hljs-type\">bool</span> result = <span class=\"hljs-literal\">false</span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">5</span> &amp;&amp; !result; j++) {\n            <span class=\"hljs-keyword\">if</span> (std::<span class=\"hljs-built_in\">abs</span>(y[i] - eig_vals[j]) &lt; <span class=\"hljs-number\">0.1</span>) {\n                result = <span class=\"hljs-literal\">true</span>;\n                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;(&quot;</span> &lt;&lt; eig_vals[j] &lt;&lt; <span class=\"hljs-string\">&quot;) &quot;</span>;\n            }\n        }\n        <span class=\"hljs-built_in\">assert</span>(result);  <span class=\"hljs-comment\">// ensure that i^th expected eigen value was computed</span>\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;found\\n&quot;</span>;\n    }\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 2 Passed\\n\\n&quot;</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * main function\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span> </span>{\n    <span class=\"hljs-type\">int</span> mat_size = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-keyword\">if</span> (argc == <span class=\"hljs-number\">2</span>) {\n        mat_size = <span class=\"hljs-built_in\">atoi</span>(argv[<span class=\"hljs-number\">1</span>]);\n    } <span class=\"hljs-keyword\">else</span> {  <span class=\"hljs-comment\">// if invalid input argument is given run tests</span>\n        <span class=\"hljs-built_in\">test1</span>();\n        <span class=\"hljs-built_in\">test2</span>();\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Usage: ./qr_eigen_values [mat_size]\\n&quot;</span>;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n    }\n\n    <span class=\"hljs-keyword\">if</span> (mat_size &lt; <span class=\"hljs-number\">2</span>) {\n        <span class=\"hljs-built_in\">fprintf</span>(stderr, <span class=\"hljs-string\">&quot;Matrix size should be &gt; 2\\n&quot;</span>);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    }\n\n    <span class=\"hljs-comment\">// initialize random number generator</span>\n    std::<span class=\"hljs-built_in\">srand</span>(std::<span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">nullptr</span>));\n\n    <span class=\"hljs-type\">int</span> i, rows = mat_size, columns = mat_size;\n\n    std::valarray&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">A</span>(rows);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; rows; i++) {\n        A[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(columns);\n    }\n\n    <span class=\"hljs-comment\">/* create a random matrix */</span>\n    <span class=\"hljs-built_in\">create_matrix</span>(&amp;A);\n\n    std::cout &lt;&lt; A &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n\n    <span class=\"hljs-type\">clock_t</span> t1 = <span class=\"hljs-built_in\">clock</span>();\n    std::valarray&lt;<span class=\"hljs-type\">double</span>&gt; eigen_vals = qr_algorithm::<span class=\"hljs-built_in\">eigen_values</span>(&amp;A);\n    <span class=\"hljs-type\">double</span> dtime = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(<span class=\"hljs-built_in\">clock</span>() - t1) / CLOCKS_PER_SEC;\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Eigen vals: &quot;</span>;\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; mat_size; i++) std::cout &lt;&lt; eigen_vals[i] &lt;&lt; <span class=\"hljs-string\">&quot;\\t&quot;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nTime taken to compute: &quot;</span> &lt;&lt; dtime &lt;&lt; <span class=\"hljs-string\">&quot; sec\\n&quot;</span>;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "c": {
      "dir": "numerical_methods/qr_eigen_values.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/numerical_methods/qr_eigen_values.c",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * \\brief Compute real eigen values and eigen vectors of a symmetric matrix\n * using [QR decomposition](https://en.wikipedia.org/wiki/QR_decomposition)\n * method.\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;math.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;time.h&gt;</span></span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;qr_decompose.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;omp.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> LIMS 9        <span class=\"hljs-comment\">/**&lt; limit of range of matrix values */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> EPSILON 1e-10 <span class=\"hljs-comment\">/**&lt; accuracy tolerance limit */</span></span>\n\n<span class=\"hljs-comment\">/**\n * create a square matrix of given size with random elements\n * \\param[out] A matrix to create (must be pre-allocated in memory)\n * \\param[in] N matrix size\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">create_matrix</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> **A, <span class=\"hljs-type\">int</span> N)</span>\n{\n    <span class=\"hljs-type\">int</span> i, j, tmp, lim2 = LIMS &gt;&gt; <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\n    {\n        A[i][i] = (rand() % LIMS) - lim2;\n        <span class=\"hljs-keyword\">for</span> (j = i + <span class=\"hljs-number\">1</span>; j &lt; N; j++)\n        {\n            tmp = (rand() % LIMS) - lim2;\n            A[i][j] = tmp;\n            A[j][i] = tmp;\n        }\n    }\n}\n\n<span class=\"hljs-comment\">/**\n * Perform multiplication of two matrices.\n * * R2 must be equal to C1\n * * Resultant matrix size should be R1xC2\n * \\param[in] A first matrix to multiply\n * \\param[in] B second matrix to multiply\n * \\param[out] OUT output matrix (must be pre-allocated)\n * \\param[in] R1 number of rows of first matrix\n * \\param[in] C1 number of columns of first matrix\n * \\param[in] R2 number of rows of second matrix\n * \\param[in] C2 number of columns of second matrix\n * \\returns pointer to resultant matrix\n */</span>\n<span class=\"hljs-type\">double</span> **<span class=\"hljs-title function_\">mat_mul</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> **A, <span class=\"hljs-type\">double</span> **B, <span class=\"hljs-type\">double</span> **OUT, <span class=\"hljs-type\">int</span> R1, <span class=\"hljs-type\">int</span> C1, <span class=\"hljs-type\">int</span> R2,\n                 <span class=\"hljs-type\">int</span> C2)</span>\n{\n    <span class=\"hljs-keyword\">if</span> (C1 != R2)\n    {\n        perror(<span class=\"hljs-string\">&quot;Matrix dimensions mismatch!&quot;</span>);\n        <span class=\"hljs-keyword\">return</span> OUT;\n    }\n\n    <span class=\"hljs-type\">int</span> i;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; R1; i++)\n    {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; C2; j++)\n        {\n            OUT[i][j] = <span class=\"hljs-number\">0.f</span>;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; C1; k++) OUT[i][j] += A[i][k] * B[k][j];\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> OUT;\n}\n\n<span class=\"hljs-comment\">/** Compute eigen values using iterative shifted QR decomposition algorithm as\n * follows:\n * 1. Use last diagonal element of A as eigen value approximation \\f$c\\f$\n * 2. Shift diagonals of matrix \\f$A&#x27; = A - cI\\f$\n * 3. Decompose matrix \\f$A&#x27;=QR\\f$\n * 4. Compute next approximation \\f$A&#x27;_1 = RQ \\f$\n * 5. Shift diagonals back \\f$A_1 = A&#x27;_1 + cI\\f$\n * 6. Termination condition check: last element below diagonal is almost 0\n *   1. If not 0, go back to step 1 with the new approximation \\f$A_1\\f$\n *   2. If 0, continue to step 7\n * 7. Save last known \\f$c\\f$ as the eigen value.\n * 8. Are all eigen values found?\n *   1. If not, remove last row and column of \\f$A_1\\f$ and go back to step 1.\n *   2. If yes, stop.\n *\n * \\note The matrix \\f$A\\f$ gets modified\n *\n * \\param[in,out] A matrix to compute eigen values for\n * \\param[out] eigen_vals resultant vector containing computed eigen values\n * \\param[in] mat_size matrix size\n * \\param[in] debug_print 1 to print intermediate Q &amp; R matrices, 0 for not to\n * \\returns time for computation in seconds\n */</span>\n<span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">eigen_values</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> **A, <span class=\"hljs-type\">double</span> *eigen_vals, <span class=\"hljs-type\">int</span> mat_size,\n                    <span class=\"hljs-type\">char</span> debug_print)</span>\n{\n    <span class=\"hljs-keyword\">if</span> (!eigen_vals)\n    {\n        perror(<span class=\"hljs-string\">&quot;Output eigen value vector cannot be NULL!&quot;</span>);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    }\n    <span class=\"hljs-type\">double</span> **R = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *) * mat_size);\n    <span class=\"hljs-type\">double</span> **Q = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *) * mat_size);\n    <span class=\"hljs-keyword\">if</span> (!Q || !R)\n    {\n        perror(<span class=\"hljs-string\">&quot;Unable to allocate memory for Q &amp; R!&quot;</span>);\n        <span class=\"hljs-keyword\">if</span> (Q)\n        {\n            <span class=\"hljs-built_in\">free</span>(Q);\n        }\n        <span class=\"hljs-keyword\">if</span> (R)\n        {\n            <span class=\"hljs-built_in\">free</span>(R);\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    }\n\n    <span class=\"hljs-comment\">/* allocate dynamic memory for matrices */</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; mat_size; i++)\n    {\n        R[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>) * mat_size);\n        Q[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>) * mat_size);\n        <span class=\"hljs-keyword\">if</span> (!Q[i] || !R[i])\n        {\n            perror(<span class=\"hljs-string\">&quot;Unable to allocate memory for Q &amp; R.&quot;</span>);\n            <span class=\"hljs-keyword\">for</span> (; i &gt;= <span class=\"hljs-number\">0</span>; i--)\n            {\n                <span class=\"hljs-built_in\">free</span>(R[i]);\n                <span class=\"hljs-built_in\">free</span>(Q[i]);\n            }\n            <span class=\"hljs-built_in\">free</span>(Q);\n            <span class=\"hljs-built_in\">free</span>(R);\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n        }\n    }\n\n    <span class=\"hljs-keyword\">if</span> (debug_print)\n    {\n        print_matrix(A, mat_size, mat_size);\n    }\n\n    <span class=\"hljs-type\">int</span> rows = mat_size, columns = mat_size;\n    <span class=\"hljs-type\">int</span> counter = <span class=\"hljs-number\">0</span>, num_eigs = rows - <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-type\">double</span> last_eig = <span class=\"hljs-number\">0</span>;\n\n    <span class=\"hljs-type\">clock_t</span> t1 = clock();\n    <span class=\"hljs-keyword\">while</span> (num_eigs &gt; <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">/* continue till all eigen values are found */</span>\n    {\n        <span class=\"hljs-comment\">/* iterate with QR decomposition */</span>\n        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">fabs</span>(A[num_eigs][num_eigs - <span class=\"hljs-number\">1</span>]) &gt; EPSILON)\n        {\n            last_eig = A[num_eigs][num_eigs];\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; rows; i++) A[i][i] -= last_eig; <span class=\"hljs-comment\">/* A - cI */</span>\n            qr_decompose(A, Q, R, rows, columns);\n\n            <span class=\"hljs-keyword\">if</span> (debug_print)\n            {\n                print_matrix(A, rows, columns);\n                print_matrix(Q, rows, columns);\n                print_matrix(R, columns, columns);\n                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-------------------- %d ---------------------\\n&quot;</span>,\n                       ++counter);\n            }\n\n            mat_mul(R, Q, A, columns, columns, rows, columns);\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; rows; i++) A[i][i] += last_eig; <span class=\"hljs-comment\">/* A + cI */</span>\n        }\n\n        <span class=\"hljs-comment\">/* store the converged eigen value */</span>\n        eigen_vals[num_eigs] = last_eig;\n\n        <span class=\"hljs-keyword\">if</span> (debug_print)\n        {\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;========================\\n&quot;</span>);\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Eigen value: % g,\\n&quot;</span>, last_eig);\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;========================\\n&quot;</span>);\n        }\n\n        num_eigs--;\n        rows--;\n        columns--;\n    }\n    eigen_vals[<span class=\"hljs-number\">0</span>] = A[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>];\n    <span class=\"hljs-type\">double</span> dtime = (<span class=\"hljs-type\">double</span>)(clock() - t1) / CLOCKS_PER_SEC;\n\n    <span class=\"hljs-keyword\">if</span> (debug_print)\n    {\n        print_matrix(R, mat_size, mat_size);\n        print_matrix(Q, mat_size, mat_size);\n    }\n\n    <span class=\"hljs-comment\">/* cleanup dynamic memory */</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; mat_size; i++)\n    {\n        <span class=\"hljs-built_in\">free</span>(R[i]);\n        <span class=\"hljs-built_in\">free</span>(Q[i]);\n    }\n    <span class=\"hljs-built_in\">free</span>(R);\n    <span class=\"hljs-built_in\">free</span>(Q);\n\n    <span class=\"hljs-keyword\">return</span> dtime;\n}\n\n<span class=\"hljs-comment\">/**\n * test function to compute eigen values of a 2x2 matrix\n * \\f[\\begin{bmatrix}\n * 5 &amp; 7\\\\\n * 7 &amp; 11\n * \\end{bmatrix}\\f]\n * which are approximately, {15.56158, 0.384227}\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test1</span><span class=\"hljs-params\">()</span>\n{\n    <span class=\"hljs-type\">int</span> mat_size = <span class=\"hljs-number\">2</span>;\n    <span class=\"hljs-type\">double</span> X[][<span class=\"hljs-number\">2</span>] = {{<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>}, {<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>}};\n    <span class=\"hljs-type\">double</span> y[] = {<span class=\"hljs-number\">15.56158</span>, <span class=\"hljs-number\">0.384227</span>};  <span class=\"hljs-comment\">// corresponding y-values</span>\n    <span class=\"hljs-type\">double</span> eig_vals[<span class=\"hljs-number\">2</span>] = {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>};\n\n    <span class=\"hljs-comment\">// The following steps are to convert a &quot;double[][]&quot; to &quot;double **&quot;</span>\n    <span class=\"hljs-type\">double</span> **A = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(mat_size * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; mat_size; i++) A[i] = X[i];\n\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;------- Test 1 -------\\n&quot;</span>);\n\n    <span class=\"hljs-type\">double</span> dtime = eigen_values(A, eig_vals, mat_size, <span class=\"hljs-number\">0</span>);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; mat_size; i++)\n    {\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d/5 Checking for %.3g --&gt; &quot;</span>, i + <span class=\"hljs-number\">1</span>, y[i]);\n        <span class=\"hljs-type\">char</span> result = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; mat_size &amp;&amp; !result; j++)\n        {\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">fabs</span>(y[i] - eig_vals[j]) &lt; <span class=\"hljs-number\">0.1</span>)\n            {\n                result = <span class=\"hljs-number\">1</span>;\n                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;(%.3g) &quot;</span>, eig_vals[j]);\n            }\n        }\n\n        <span class=\"hljs-comment\">// ensure that i^th expected eigen value was computed</span>\n        assert(result != <span class=\"hljs-number\">0</span>);\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;found\\n&quot;</span>);\n    }\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Test 1 Passed in %.3g sec\\n\\n&quot;</span>, dtime);\n    <span class=\"hljs-built_in\">free</span>(A);\n}\n\n<span class=\"hljs-comment\">/**\n * test function to compute eigen values of a 2x2 matrix\n * \\f[\\begin{bmatrix}\n * -4&amp; 4&amp; 2&amp; 0&amp; -3\\\\\n * 4&amp; -4&amp; 4&amp; -3&amp; -1\\\\\n * 2&amp; 4&amp; 4&amp; 3&amp; -3\\\\\n * 0&amp; -3&amp; 3&amp; -1&amp;-1\\\\\n * -3&amp; -1&amp; -3&amp; -3&amp; 0\n * \\end{bmatrix}\\f]\n * which are approximately, {9.27648, -9.26948, 2.0181, -1.03516, -5.98994}\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test2</span><span class=\"hljs-params\">()</span>\n{\n    <span class=\"hljs-type\">int</span> mat_size = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-type\">double</span> X[][<span class=\"hljs-number\">5</span>] = {{<span class=\"hljs-number\">-4</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-3</span>},\n                     {<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">-4</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">-3</span>, <span class=\"hljs-number\">-1</span>},\n                     {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">-3</span>},\n                     {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-3</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-3</span>},\n                     {<span class=\"hljs-number\">-3</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-3</span>, <span class=\"hljs-number\">-3</span>, <span class=\"hljs-number\">0</span>}};\n    <span class=\"hljs-type\">double</span> y[] = {<span class=\"hljs-number\">9.27648</span>, <span class=\"hljs-number\">-9.26948</span>, <span class=\"hljs-number\">2.0181</span>, <span class=\"hljs-number\">-1.03516</span>,\n                  <span class=\"hljs-number\">-5.98994</span>};  <span class=\"hljs-comment\">// corresponding y-values</span>\n    <span class=\"hljs-type\">double</span> eig_vals[<span class=\"hljs-number\">5</span>];\n\n    <span class=\"hljs-comment\">// The following steps are to convert a &quot;double[][]&quot; to &quot;double **&quot;</span>\n    <span class=\"hljs-type\">double</span> **A = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(mat_size * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; mat_size; i++) A[i] = X[i];\n\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;------- Test 2 -------\\n&quot;</span>);\n\n    <span class=\"hljs-type\">double</span> dtime = eigen_values(A, eig_vals, mat_size, <span class=\"hljs-number\">0</span>);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; mat_size; i++)\n    {\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d/5 Checking for %.3g --&gt; &quot;</span>, i + <span class=\"hljs-number\">1</span>, y[i]);\n        <span class=\"hljs-type\">char</span> result = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; mat_size &amp;&amp; !result; j++)\n        {\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">fabs</span>(y[i] - eig_vals[j]) &lt; <span class=\"hljs-number\">0.1</span>)\n            {\n                result = <span class=\"hljs-number\">1</span>;\n                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;(%.3g) &quot;</span>, eig_vals[j]);\n            }\n        }\n\n        <span class=\"hljs-comment\">// ensure that i^th expected eigen value was computed</span>\n        assert(result != <span class=\"hljs-number\">0</span>);\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;found\\n&quot;</span>);\n    }\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Test 2 Passed in %.3g sec\\n\\n&quot;</span>, dtime);\n    <span class=\"hljs-built_in\">free</span>(A);\n}\n\n<span class=\"hljs-comment\">/**\n * main function\n */</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span>\n{\n    srand(time(<span class=\"hljs-literal\">NULL</span>));\n\n    <span class=\"hljs-type\">int</span> mat_size = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-keyword\">if</span> (argc == <span class=\"hljs-number\">2</span>)\n    {\n        mat_size = atoi(argv[<span class=\"hljs-number\">1</span>]);\n    }\n    <span class=\"hljs-keyword\">else</span>\n    {  <span class=\"hljs-comment\">// if invalid input argument is given run tests</span>\n        test1();\n        test2();\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Usage: ./qr_eigen_values [mat_size]\\n&quot;</span>);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n    }\n\n    <span class=\"hljs-keyword\">if</span> (mat_size &lt; <span class=\"hljs-number\">2</span>)\n    {\n        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Matrix size should be &gt; 2\\n&quot;</span>);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    }\n\n    <span class=\"hljs-type\">int</span> i;\n\n    <span class=\"hljs-type\">double</span> **A = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *) * mat_size);\n    <span class=\"hljs-comment\">/* number of eigen values = matrix size */</span>\n    <span class=\"hljs-type\">double</span> *eigen_vals = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>) * mat_size);\n    <span class=\"hljs-keyword\">if</span> (!eigen_vals)\n    {\n        perror(<span class=\"hljs-string\">&quot;Unable to allocate memory for eigen values!&quot;</span>);\n        <span class=\"hljs-built_in\">free</span>(A);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    }\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; mat_size; i++)\n    {\n        A[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>) * mat_size);\n        eigen_vals[i] = <span class=\"hljs-number\">0.f</span>;\n    }\n\n    <span class=\"hljs-comment\">/* create a random matrix */</span>\n    create_matrix(A, mat_size);\n\n    print_matrix(A, mat_size, mat_size);\n\n    <span class=\"hljs-type\">double</span> dtime = eigen_values(A, eigen_vals, mat_size, <span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Eigen vals: &quot;</span>);\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; mat_size; i++) <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;% 9.4g\\t&quot;</span>, eigen_vals[i]);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\nTime taken to compute: % .4g sec\\n&quot;</span>, dtime);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; mat_size; i++) <span class=\"hljs-built_in\">free</span>(A[i]);\n    <span class=\"hljs-built_in\">free</span>(A);\n    <span class=\"hljs-built_in\">free</span>(eigen_vals);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 8
    },
    {
      "name": "Krishna Vedala",
      "email": "krishna.vedala@ieee.org",
      "commits": 9
    }
  ],
  "explanationUrl": {}
}
