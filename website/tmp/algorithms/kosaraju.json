{
  "slug": "kosaraju",
  "name": "Kosaraju",
  "categories": ["graphs"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "graph/kosaraju.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph/kosaraju.cpp",
      "code": "<span class=\"hljs-comment\">/* Implementation of Kosaraju&#x27;s Algorithm to find out the strongly connected\n   components (SCCs) in a graph. Author:Anirban166\n*/</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\n\n<span class=\"hljs-comment\">/**\n * Iterative function/method to print graph:\n * @param a adjacency list representation of the graph\n * @param V number of vertices\n * @return void\n **/</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; &amp;a, <span class=\"hljs-type\">int</span> V)</span> </span>{\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++) {\n        <span class=\"hljs-keyword\">if</span> (!a[i].<span class=\"hljs-built_in\">empty</span>()) {\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot;--&gt;&quot;</span>;\n        }\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j : a[i]) {\n            std::cout &lt;&lt; j &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;\n        }\n        <span class=\"hljs-keyword\">if</span> (!a[i].<span class=\"hljs-built_in\">empty</span>()) {\n            std::cout &lt;&lt; std::endl;\n        }\n    }\n}\n\n<span class=\"hljs-comment\">/**\n * //Recursive function/method to push vertices into stack passed as parameter:\n * @param v vertices\n * @param st stack passed by reference\n * @param vis array to keep track of visited nodes (boolean type)\n * @param adj adjacency list representation of the graph\n * @return void\n **/</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_vertex</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> v, std::stack&lt;<span class=\"hljs-type\">int</span>&gt; *st, std::vector&lt;<span class=\"hljs-type\">bool</span>&gt; *vis,\n                 <span class=\"hljs-keyword\">const</span> std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; &amp;adj)</span> </span>{\n    (*vis)[v] = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i = adj[v].<span class=\"hljs-built_in\">begin</span>(); i != adj[v].<span class=\"hljs-built_in\">end</span>(); i++) {\n        <span class=\"hljs-keyword\">if</span> ((*vis)[*i] == <span class=\"hljs-literal\">false</span>) {\n            <span class=\"hljs-built_in\">push_vertex</span>(*i, st, vis, adj);\n        }\n    }\n    st-&gt;<span class=\"hljs-built_in\">push</span>(v);\n}\n\n<span class=\"hljs-comment\">/**\n * //Recursive function/method to implement depth first traversal(dfs):\n * @param v vertices\n * @param vis array to keep track of visited nodes (boolean type)\n * @param grev graph with reversed edges\n * @return void\n **/</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> v, std::vector&lt;<span class=\"hljs-type\">bool</span>&gt; *vis,\n         <span class=\"hljs-keyword\">const</span> std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; &amp;grev)</span> </span>{\n    (*vis)[v] = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-comment\">// cout&lt;&lt;v&lt;&lt;&quot; &quot;;</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i = grev[v].<span class=\"hljs-built_in\">begin</span>(); i != grev[v].<span class=\"hljs-built_in\">end</span>(); i++) {\n        <span class=\"hljs-keyword\">if</span> ((*vis)[*i] == <span class=\"hljs-literal\">false</span>) {\n            <span class=\"hljs-built_in\">dfs</span>(*i, vis, grev);\n        }\n    }\n}\n\n<span class=\"hljs-comment\">// function/method to implement Kosaraju&#x27;s Algorithm:</span>\n<span class=\"hljs-comment\">/**\n* Info about the method\n* @param V vertices in graph\n* @param adj array of vectors that represent a graph (adjacency list/array)\n* @return int ( 0, 1, 2..and so on, only unsigned values as either there can be\nno SCCs i.e. none(0) or there will be x no. of SCCs (x&gt;0)) i.e. it returns the\ncount of (number of) strongly connected components (SCCs) in the graph.\n(variable &#x27;count_scc&#x27; within function)\n**/</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">kosaraju</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> V, <span class=\"hljs-keyword\">const</span> std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; &amp;adj)</span> </span>{\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">bool</span>&gt; <span class=\"hljs-title\">vis</span><span class=\"hljs-params\">(V, <span class=\"hljs-literal\">false</span>)</span></span>;\n    std::stack&lt;<span class=\"hljs-type\">int</span>&gt; st;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v = <span class=\"hljs-number\">0</span>; v &lt; V; v++) {\n        <span class=\"hljs-keyword\">if</span> (vis[v] == <span class=\"hljs-literal\">false</span>) {\n            <span class=\"hljs-built_in\">push_vertex</span>(v, &amp;st, &amp;vis, adj);\n        }\n    }\n    <span class=\"hljs-comment\">// making new graph (grev) with reverse edges as in adj[]:</span>\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; <span class=\"hljs-built_in\">grev</span>(V);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V + <span class=\"hljs-number\">1</span>; i++) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> j = adj[i].<span class=\"hljs-built_in\">begin</span>(); j != adj[i].<span class=\"hljs-built_in\">end</span>(); j++) {\n            grev[*j].<span class=\"hljs-built_in\">push_back</span>(i);\n        }\n    }\n    <span class=\"hljs-comment\">// cout&lt;&lt;&quot;grev=&quot;&lt;&lt;endl; -&gt;debug statement</span>\n    <span class=\"hljs-comment\">// print(grev,V);       -&gt;debug statement</span>\n    <span class=\"hljs-comment\">// reinitialise visited to 0</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++) vis[i] = <span class=\"hljs-literal\">false</span>;\n    <span class=\"hljs-type\">int</span> count_scc = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">while</span> (!st.<span class=\"hljs-built_in\">empty</span>()) {\n        <span class=\"hljs-type\">int</span> t = st.<span class=\"hljs-built_in\">top</span>();\n        st.<span class=\"hljs-built_in\">pop</span>();\n        <span class=\"hljs-keyword\">if</span> (vis[t] == <span class=\"hljs-literal\">false</span>) {\n            <span class=\"hljs-built_in\">dfs</span>(t, &amp;vis, grev);\n            count_scc++;\n        }\n    }\n    <span class=\"hljs-comment\">// cout&lt;&lt;&quot;count_scc=&quot;&lt;&lt;count_scc&lt;&lt;endl; //in case you want to print here</span>\n    <span class=\"hljs-comment\">// itself, uncomment &amp; change return type of function to void.</span>\n    <span class=\"hljs-keyword\">return</span> count_scc;\n}\n\n<span class=\"hljs-comment\">// All critical/corner cases have been taken care of.</span>\n<span class=\"hljs-comment\">// Input your required values: (not hardcoded)</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-type\">int</span> t = <span class=\"hljs-number\">0</span>;\n    std::cin &gt;&gt; t;\n    <span class=\"hljs-keyword\">while</span> (t--) {\n        <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">0</span>, b = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// a-&gt;number of nodes, b-&gt;directed edges.</span>\n        std::cin &gt;&gt; a &gt;&gt; b;\n        <span class=\"hljs-type\">int</span> m = <span class=\"hljs-number\">0</span>, n = <span class=\"hljs-number\">0</span>;\n        std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; <span class=\"hljs-built_in\">adj</span>(a + <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; b; i++)  <span class=\"hljs-comment\">// take total b inputs of 2 vertices each</span>\n                                     <span class=\"hljs-comment\">// required to form an edge.</span>\n        {\n            std::cin &gt;&gt; m &gt;&gt; n;  <span class=\"hljs-comment\">// take input m,n denoting edge from m-&gt;n.</span>\n            adj[m].<span class=\"hljs-built_in\">push_back</span>(n);\n        }\n        <span class=\"hljs-comment\">// pass number of nodes and adjacency array as parameters to function:</span>\n        std::cout &lt;&lt; <span class=\"hljs-built_in\">kosaraju</span>(a, adj) &lt;&lt; std::endl;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Ayaan Khan",
      "email": "ayaankhan98@gmail.com",
      "commits": 1
    },
    {
      "name": "Anirban166",
      "email": "bloodraven166@gmail.com",
      "commits": 3
    },
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 3
    }
  ],
  "explanationUrl": {}
}
