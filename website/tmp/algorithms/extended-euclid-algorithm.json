{
  "slug": "extended-euclid-algorithm",
  "name": "Extended Euclid Algorithm",
  "categories": ["math"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "math/extended_euclid_algorithm.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/math/extended_euclid_algorithm.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * @brief GCD using [extended Euclid&#x27;s algorithm]\n * (https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)\n *\n * Finding coefficients of a and b ie x and y in  BÃ©zout&#x27;s identity\n * \\f[\\text{gcd}(a, b) = a \\times x + b \\times y \\f]\n * This is also used in finding Modular\n * multiplicative inverse of a number. (A * B)%M == 1 Here B is the MMI of A for\n * given M, so extendedEuclid (A, M) gives B.\n */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span>  <span class=\"hljs-comment\">// for swap function</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n\n<span class=\"hljs-comment\">/**\n * function to update the coefficients per iteration\n * \\f[r_0,\\,r = r,\\, r_0 - \\text{quotient}\\times r\\f]\n *\n * @param[in,out] r signed or unsigned\n * @param[in,out] r0 signed or unsigned\n * @param[in] quotient  unsigned\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> T2&gt;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">update_step</span><span class=\"hljs-params\">(T *r, T *r0, <span class=\"hljs-keyword\">const</span> T2 quotient)</span> </span>{\n    T temp = *r;\n    *r = *r0 - (quotient * temp);\n    *r0 = temp;\n}\n\n<span class=\"hljs-comment\">/**\n * Implementation using iterative algorithm from\n * [Wikipedia](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Pseudocode)\n *\n * @param[in] A unsigned\n * @param[in] B unsigned\n * @param[out] GCD unsigned\n * @param[out] x signed\n * @param[out] y signed\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T1, <span class=\"hljs-keyword\">typename</span> T2&gt;\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">extendedEuclid_1</span><span class=\"hljs-params\">(T1 A, T1 B, T1 *GCD, T2 *x, T2 *y)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (B &gt; A)\n        std::<span class=\"hljs-built_in\">swap</span>(A, B);  <span class=\"hljs-comment\">// Ensure that A &gt;= B</span>\n\n    T2 s = <span class=\"hljs-number\">0</span>, s0 = <span class=\"hljs-number\">1</span>;\n    T2 t = <span class=\"hljs-number\">1</span>, t0 = <span class=\"hljs-number\">0</span>;\n    T1 r = B, r0 = A;\n\n    <span class=\"hljs-keyword\">while</span> (r != <span class=\"hljs-number\">0</span>) {\n        T1 quotient = r0 / r;\n        <span class=\"hljs-built_in\">update_step</span>(&amp;r, &amp;r0, quotient);\n        <span class=\"hljs-built_in\">update_step</span>(&amp;s, &amp;s0, quotient);\n        <span class=\"hljs-built_in\">update_step</span>(&amp;t, &amp;t0, quotient);\n    }\n    *GCD = r0;\n    *x = s0;\n    *y = t0;\n}\n\n<span class=\"hljs-comment\">/**\n * Implementation using recursive algorithm\n *\n * @param[in] A unsigned\n * @param[in] B unsigned\n * @param[out] GCD unsigned\n * @param[in,out] x signed\n * @param[in,out] y signed\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> T2&gt;\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">extendedEuclid</span><span class=\"hljs-params\">(T A, T B, T *GCD, T2 *x, T2 *y)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (B &gt; A)\n        std::<span class=\"hljs-built_in\">swap</span>(A, B);  <span class=\"hljs-comment\">// Ensure that A &gt;= B</span>\n\n    <span class=\"hljs-keyword\">if</span> (B == <span class=\"hljs-number\">0</span>) {\n        *GCD = A;\n        *x = <span class=\"hljs-number\">1</span>;\n        *y = <span class=\"hljs-number\">0</span>;\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-built_in\">extendedEuclid</span>(B, A % B, GCD, x, y);\n        T2 temp = *x;\n        *x = *y;\n        *y = temp - (A / B) * (*y);\n    }\n}\n\n<span class=\"hljs-comment\">/// Main function</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-type\">uint32_t</span> a, b, gcd;\n    <span class=\"hljs-type\">int32_t</span> x, y;\n    std::cin &gt;&gt; a &gt;&gt; b;\n    <span class=\"hljs-built_in\">extendedEuclid</span>(a, b, &amp;gcd, &amp;x, &amp;y);\n    std::cout &lt;&lt; gcd &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; y &lt;&lt; std::endl;\n    <span class=\"hljs-built_in\">extendedEuclid_1</span>(a, b, &amp;gcd, &amp;x, &amp;y);\n    std::cout &lt;&lt; gcd &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; x &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; y &lt;&lt; std::endl;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [],
  "explanationUrl": {}
}
