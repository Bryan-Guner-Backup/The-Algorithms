{
  "slug": "breadth-first-search",
  "name": "Breadth First Search",
  "categories": ["graphs"],
  "body": {},
  "implementations": {
    "python": {
      "dir": "graphs/breadth_first_search.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/graphs/breadth_first_search.py",
      "code": "<span class=\"hljs-comment\">#!/usr/bin/python</span>\n\n<span class=\"hljs-string\">&quot;&quot;&quot; Author: OMKAR PATHAK &quot;&quot;&quot;</span>\n\n<span class=\"hljs-keyword\">from</span> typing <span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">Dict</span>, <span class=\"hljs-type\">List</span>, <span class=\"hljs-type\">Set</span>\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Graph</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self</span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        self.vertices: <span class=\"hljs-type\">Dict</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">int</span>]] = {}\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">print_graph</span>(<span class=\"hljs-params\">self</span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        prints adjacency list representation of graaph\n        &gt;&gt;&gt; g = Graph()\n        &gt;&gt;&gt; g.print_graph()\n        &gt;&gt;&gt; g.add_edge(0, 1)\n        &gt;&gt;&gt; g.print_graph()\n        0  :  1\n        &quot;&quot;&quot;</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> self.vertices:\n            <span class=\"hljs-built_in\">print</span>(i, <span class=\"hljs-string\">&quot; : &quot;</span>, <span class=\"hljs-string\">&quot; -&gt; &quot;</span>.join([<span class=\"hljs-built_in\">str</span>(j) <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> self.vertices[i]]))\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add_edge</span>(<span class=\"hljs-params\">self, from_vertex: <span class=\"hljs-built_in\">int</span>, to_vertex: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        adding the edge between two vertices\n        &gt;&gt;&gt; g = Graph()\n        &gt;&gt;&gt; g.print_graph()\n        &gt;&gt;&gt; g.add_edge(0, 1)\n        &gt;&gt;&gt; g.print_graph()\n        0  :  1\n        &quot;&quot;&quot;</span>\n        <span class=\"hljs-keyword\">if</span> from_vertex <span class=\"hljs-keyword\">in</span> self.vertices:\n            self.vertices[from_vertex].append(to_vertex)\n        <span class=\"hljs-keyword\">else</span>:\n            self.vertices[from_vertex] = [to_vertex]\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">bfs</span>(<span class=\"hljs-params\">self, start_vertex: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-type\">Set</span>[<span class=\"hljs-built_in\">int</span>]:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        &gt;&gt;&gt; g = Graph()\n        &gt;&gt;&gt; g.add_edge(0, 1)\n        &gt;&gt;&gt; g.add_edge(0, 1)\n        &gt;&gt;&gt; g.add_edge(0, 2)\n        &gt;&gt;&gt; g.add_edge(1, 2)\n        &gt;&gt;&gt; g.add_edge(2, 0)\n        &gt;&gt;&gt; g.add_edge(2, 3)\n        &gt;&gt;&gt; g.add_edge(3, 3)\n        &gt;&gt;&gt; sorted(g.bfs(2))\n        [0, 1, 2, 3]\n        &quot;&quot;&quot;</span>\n        <span class=\"hljs-comment\"># initialize set for storing already visited vertices</span>\n        visited = <span class=\"hljs-built_in\">set</span>()\n\n        <span class=\"hljs-comment\"># create a first in first out queue to store all the vertices for BFS</span>\n        queue = []\n\n        <span class=\"hljs-comment\"># mark the source node as visited and enqueue it</span>\n        visited.add(start_vertex)\n        queue.append(start_vertex)\n\n        <span class=\"hljs-keyword\">while</span> queue:\n            vertex = queue.pop(<span class=\"hljs-number\">0</span>)\n\n            <span class=\"hljs-comment\"># loop through all adjacent vertex and enqueue it if not yet visited</span>\n            <span class=\"hljs-keyword\">for</span> adjacent_vertex <span class=\"hljs-keyword\">in</span> self.vertices[vertex]:\n                <span class=\"hljs-keyword\">if</span> adjacent_vertex <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> visited:\n                    queue.append(adjacent_vertex)\n                    visited.add(adjacent_vertex)\n        <span class=\"hljs-keyword\">return</span> visited\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    <span class=\"hljs-keyword\">from</span> doctest <span class=\"hljs-keyword\">import</span> testmod\n\n    testmod(verbose=<span class=\"hljs-literal\">True</span>)\n\n    g = Graph()\n    g.add_edge(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>)\n    g.add_edge(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>)\n    g.add_edge(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)\n    g.add_edge(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>)\n    g.add_edge(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)\n    g.add_edge(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>)\n\n    g.print_graph()\n    <span class=\"hljs-comment\"># 0  :  1 -&gt; 2</span>\n    <span class=\"hljs-comment\"># 1  :  2</span>\n    <span class=\"hljs-comment\"># 2  :  0 -&gt; 3</span>\n    <span class=\"hljs-comment\"># 3  :  3</span>\n\n    <span class=\"hljs-keyword\">assert</span> <span class=\"hljs-built_in\">sorted</span>(g.bfs(<span class=\"hljs-number\">2</span>)) == [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n"
    },
    "javascript": {
      "dir": "Graphs/BreadthFirstSearch.js",
      "url": "https://github.com/TheAlgorithms/javascript/tree/master/Graphs/BreadthFirstSearch.js",
      "code": "<span class=\"hljs-comment\">/*\r\nBreadth-first search is an algorithm for traversing a graph. It&#x27;s discovers all nodes reachable from the starting position by exploring all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.\r\n(description adapted from https://en.wikipedia.org/wiki/Breadth-first_search )\r\n(see also: https://www.koderdojo.com/blog/breadth-first-search-and-shortest-path-in-csharp-and-net-core )\r\n*/</span>\r\n\r\n<span class=\"hljs-comment\">/*\r\nDoctests\r\n&gt; Array.from(breadthFirstSearch(graph, &quot;C&quot;))\r\n[ &#x27;C&#x27;, &#x27;D&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;E&#x27; ]\r\n&gt; Array.from(breadthFirstSearch(graph, &quot;A&quot;))\r\n[ &#x27;A&#x27;, &#x27;B&#x27;, &#x27;D&#x27;, &#x27;E&#x27; ]\r\n&gt; Array.from(breadthFirstSearch(graph, &quot;F&quot;))\r\n[ &#x27;F&#x27;, &#x27;G&#x27; ]\r\n*/</span>\r\n\r\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">breadthFirstSearch</span> (graph, startingNode) {\r\n  <span class=\"hljs-comment\">// visited keeps track of all nodes visited</span>\r\n  <span class=\"hljs-keyword\">const</span> visited = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>()\r\n\r\n  <span class=\"hljs-comment\">// queue contains the nodes to be explored in the future</span>\r\n  <span class=\"hljs-keyword\">const</span> queue = [startingNode]\r\n\r\n  <span class=\"hljs-keyword\">while</span> (queue.<span class=\"hljs-property\">length</span> &gt; <span class=\"hljs-number\">0</span>) {\r\n    <span class=\"hljs-comment\">// start with the queue&#x27;s first node</span>\r\n    <span class=\"hljs-keyword\">const</span> node = queue.<span class=\"hljs-title function_\">shift</span>()\r\n\r\n    <span class=\"hljs-keyword\">if</span> (!visited.<span class=\"hljs-title function_\">has</span>(node)) {\r\n      <span class=\"hljs-comment\">// mark the node as visited</span>\r\n      visited.<span class=\"hljs-title function_\">add</span>(node)\r\n      <span class=\"hljs-keyword\">const</span> neighbors = graph[node]\r\n\r\n      <span class=\"hljs-comment\">// put all its neighbors into the queue</span>\r\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; neighbors.<span class=\"hljs-property\">length</span>; i++) {\r\n        queue.<span class=\"hljs-title function_\">push</span>(neighbors[i])\r\n      }\r\n    }\r\n  }\r\n\r\n  <span class=\"hljs-keyword\">return</span> visited\r\n}\r\n\r\n<span class=\"hljs-keyword\">const</span> graph = {\r\n  <span class=\"hljs-attr\">A</span>: [<span class=\"hljs-string\">&#x27;B&#x27;</span>, <span class=\"hljs-string\">&#x27;D&#x27;</span>],\r\n  <span class=\"hljs-attr\">B</span>: [<span class=\"hljs-string\">&#x27;E&#x27;</span>],\r\n  <span class=\"hljs-attr\">C</span>: [<span class=\"hljs-string\">&#x27;D&#x27;</span>],\r\n  <span class=\"hljs-attr\">D</span>: [<span class=\"hljs-string\">&#x27;A&#x27;</span>],\r\n  <span class=\"hljs-attr\">E</span>: [<span class=\"hljs-string\">&#x27;D&#x27;</span>],\r\n  <span class=\"hljs-attr\">F</span>: [<span class=\"hljs-string\">&#x27;G&#x27;</span>],\r\n  <span class=\"hljs-attr\">G</span>: []\r\n}\r\n<span class=\"hljs-comment\">/*\r\n      A &lt;-&gt; B\r\n      ÊŒ     |\r\n      |     |\r\n      v     v\r\nC --&gt; D &lt;-- E\r\n\r\nF --&gt; G\r\n*/</span>\r\n\r\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">breadthFirstSearch</span>(graph, <span class=\"hljs-string\">&#x27;C&#x27;</span>))\r\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">breadthFirstSearch</span>(graph, <span class=\"hljs-string\">&#x27;A&#x27;</span>))\r\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">breadthFirstSearch</span>(graph, <span class=\"hljs-string\">&#x27;F&#x27;</span>))\n"
    },
    "c-plus-plus": {
      "dir": "graph/breadth_first_search.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph/breadth_first_search.cpp",
      "code": "<span class=\"hljs-comment\">/**\n *\n * \\file\n * \\brief [Breadth First Search Algorithm\n * (Breadth First Search)](https://en.wikipedia.org/wiki/Breadth-first_search)\n *\n * \\author [Ayaan Khan](https://github.com/ayaankhan98)\n * \\author [Aman Kumar Pandey](https://github.com/gpamangkp)\n *\n *\n * \\details\n * Breadth First Search also quoted as BFS is a Graph Traversal Algorithm.\n * Time Complexity O(|V| + |E|) where V are the number of vertices and E\n * are the number of edges in the graph.\n *\n * Applications of Breadth First Search are\n *\n * 1. Finding shortest path between two vertices say u and v, with path\n *    length measured by number of edges (an advantage over depth first\n *    search algorithm)\n * 2. Ford-Fulkerson Method for computing the maximum flow in a flow network.\n * 3. Testing bipartiteness of a graph.\n * 4. Cheney&#x27;s Algorithm, Copying garbage collection.\n *\n * And there are many more...\n *\n * &lt;h4&gt;working&lt;/h4&gt;\n * In the implementation below we first created a graph using the adjacency\n * list representation of graph.\n * Breadth First Search Works as follows\n * it requires a vertex as a start vertex, Start vertex is that vertex\n * from where you want to start traversing the graph.\n * We maintain a bool array or a vector to keep track of the vertices\n * which we have visited so that we do not traverse the visited vertices\n * again and again and eventually fall into an infinite loop. Along with this\n * boolen array we use a Queue.\n *\n * 1. First we mark the start vertex as visited.\n * 2. Push this visited vertex in the Queue.\n * 3. while the queue is not empty we repeat the following steps\n *\n *      1. Take out an element from the front of queue\n *      2. Explore the adjacency list of this vertex\n *         if element in the adjacency list is not visited then we\n *         push that element into the queue and mark this as visited\n *\n */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;list&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;map&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\n\n<span class=\"hljs-comment\">/**\n * \\namespace graph\n * \\brief Graph algorithms\n */</span>\n<span class=\"hljs-keyword\">namespace</span> graph {\n<span class=\"hljs-comment\">/* Class Graph definition */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Graph</span> {\n    <span class=\"hljs-comment\">/**\n     *  adjacency_list maps every vertex to the list of its neighbours in the\n     * order in which they are added.\n     */</span>\n    std::map&lt;T, std::list&lt;T&gt; &gt; adjacency_list;\n\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-built_in\">Graph</span>() = <span class=\"hljs-keyword\">default</span>;\n    ;\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">add_edge</span><span class=\"hljs-params\">(T u, T v, <span class=\"hljs-type\">bool</span> bidir = <span class=\"hljs-literal\">true</span>)</span> </span>{\n        <span class=\"hljs-comment\">/**\n         *  add_edge(u,v,bidir) is used to add an edge between node u and\n         * node v by default , bidir is made true , i.e graph is\n         * bidirectional . It means if edge(u,v) is added then u--&gt;v  and\n         * v--&gt;u both edges exist.\n         *\n         *  to make the graph unidirectional pass the third parameter of\n         * add_edge as false which will\n         */</span>\n        adjacency_list[u].<span class=\"hljs-built_in\">push_back</span>(v);  <span class=\"hljs-comment\">// u--&gt;v edge added</span>\n        <span class=\"hljs-keyword\">if</span> (bidir == <span class=\"hljs-literal\">true</span>) {\n            <span class=\"hljs-comment\">// if graph is bidirectional</span>\n            adjacency_list[v].<span class=\"hljs-built_in\">push_back</span>(u);  <span class=\"hljs-comment\">// v--&gt;u edge added</span>\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     *  this function performs the breadth first search on graph and return a\n     *  mapping which maps the nodes to a boolean value representing whether the\n     *  node was traversed or not.\n     */</span>\n    <span class=\"hljs-function\">std::map&lt;T, <span class=\"hljs-type\">bool</span>&gt; <span class=\"hljs-title\">breadth_first_search</span><span class=\"hljs-params\">(T src)</span> </span>{\n        <span class=\"hljs-comment\">/// mapping to keep track of all visited nodes</span>\n        std::map&lt;T, <span class=\"hljs-type\">bool</span>&gt; visited;\n        <span class=\"hljs-comment\">/// initialise every possible vertex to map to false</span>\n        <span class=\"hljs-comment\">/// initially none of the vertices are unvisited</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> <span class=\"hljs-keyword\">const</span> &amp;adjlist : adjacency_list) {\n            visited[adjlist.first] = <span class=\"hljs-literal\">false</span>;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> <span class=\"hljs-keyword\">const</span> &amp;node : adjacency_list[adjlist.first]) {\n                visited[node] = <span class=\"hljs-literal\">false</span>;\n            }\n        }\n\n        <span class=\"hljs-comment\">/// queue to store the nodes which are yet to be traversed</span>\n        std::queue&lt;T&gt; tracker;\n\n        <span class=\"hljs-comment\">/// push the source vertex to queue to begin traversing</span>\n        tracker.<span class=\"hljs-built_in\">push</span>(src);\n        <span class=\"hljs-comment\">/// mark the source vertex as visited</span>\n        visited[src] = <span class=\"hljs-literal\">true</span>;\n        <span class=\"hljs-keyword\">while</span> (!tracker.<span class=\"hljs-built_in\">empty</span>()) {\n            <span class=\"hljs-comment\">/// traverse the graph till no connected vertex are left</span>\n            <span class=\"hljs-comment\">/// extract a node from queue for further traversal</span>\n            T node = tracker.<span class=\"hljs-built_in\">front</span>();\n            <span class=\"hljs-comment\">/// remove the node from the queue</span>\n            tracker.<span class=\"hljs-built_in\">pop</span>();\n            <span class=\"hljs-keyword\">for</span> (T <span class=\"hljs-keyword\">const</span> &amp;neighbour : adjacency_list[node]) {\n                <span class=\"hljs-comment\">/// check every vertex connected to the node which are still</span>\n                <span class=\"hljs-comment\">/// unvisited</span>\n                <span class=\"hljs-keyword\">if</span> (!visited[neighbour]) {\n                    <span class=\"hljs-comment\">/// if the neighbour is unvisited , push it into the queue</span>\n                    tracker.<span class=\"hljs-built_in\">push</span>(neighbour);\n                    <span class=\"hljs-comment\">/// mark the neighbour as visited</span>\n                    visited[neighbour] = <span class=\"hljs-literal\">true</span>;\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> visited;\n    }\n};\n<span class=\"hljs-comment\">/* Class definition ends */</span>\n}  <span class=\"hljs-comment\">// namespace graph</span>\n\n<span class=\"hljs-comment\">/** Test function */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">tests</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">/// Test 1 Begin</span>\n    graph::Graph&lt;<span class=\"hljs-type\">int</span>&gt; g;\n    std::map&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">bool</span>&gt; correct_result;\n    g.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>);\n    g.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n    g.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\n    correct_result[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-literal\">true</span>;\n    correct_result[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-literal\">true</span>;\n    correct_result[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-literal\">true</span>;\n    correct_result[<span class=\"hljs-number\">3</span>] = <span class=\"hljs-literal\">true</span>;\n\n    std::map&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">bool</span>&gt; returned_result = g.<span class=\"hljs-built_in\">breadth_first_search</span>(<span class=\"hljs-number\">2</span>);\n\n    <span class=\"hljs-built_in\">assert</span>(returned_result == correct_result);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 1 Passed...&quot;</span> &lt;&lt; std::endl;\n\n    <span class=\"hljs-comment\">/// Test 2 Begin</span>\n    returned_result = g.<span class=\"hljs-built_in\">breadth_first_search</span>(<span class=\"hljs-number\">0</span>);\n\n    <span class=\"hljs-built_in\">assert</span>(returned_result == correct_result);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 2 Passed...&quot;</span> &lt;&lt; std::endl;\n\n    <span class=\"hljs-comment\">/// Test 3 Begins</span>\n    graph::Graph&lt;std::string&gt; g2;\n\n    g2.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-string\">&quot;Gorakhpur&quot;</span>, <span class=\"hljs-string\">&quot;Lucknow&quot;</span>, <span class=\"hljs-literal\">false</span>);\n    g2.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-string\">&quot;Gorakhpur&quot;</span>, <span class=\"hljs-string\">&quot;Kanpur&quot;</span>, <span class=\"hljs-literal\">false</span>);\n    g2.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-string\">&quot;Lucknow&quot;</span>, <span class=\"hljs-string\">&quot;Agra&quot;</span>, <span class=\"hljs-literal\">false</span>);\n    g2.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-string\">&quot;Kanpur&quot;</span>, <span class=\"hljs-string\">&quot;Agra&quot;</span>, <span class=\"hljs-literal\">false</span>);\n    g2.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-string\">&quot;Lucknow&quot;</span>, <span class=\"hljs-string\">&quot;Prayagraj&quot;</span>, <span class=\"hljs-literal\">false</span>);\n    g2.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-string\">&quot;Agra&quot;</span>, <span class=\"hljs-string\">&quot;Noida&quot;</span>, <span class=\"hljs-literal\">false</span>);\n\n    std::map&lt;std::string, <span class=\"hljs-type\">bool</span>&gt; correct_res;\n    std::map&lt;std::string, <span class=\"hljs-type\">bool</span>&gt; returned_res =\n        g2.<span class=\"hljs-built_in\">breadth_first_search</span>(<span class=\"hljs-string\">&quot;Kanpur&quot;</span>);\n    correct_res[<span class=\"hljs-string\">&quot;Gorakhpur&quot;</span>] = <span class=\"hljs-literal\">false</span>;\n    correct_res[<span class=\"hljs-string\">&quot;Lucknow&quot;</span>] = <span class=\"hljs-literal\">false</span>;\n    correct_res[<span class=\"hljs-string\">&quot;Kanpur&quot;</span>] = <span class=\"hljs-literal\">true</span>;\n    correct_res[<span class=\"hljs-string\">&quot;Agra&quot;</span>] = <span class=\"hljs-literal\">true</span>;\n    correct_res[<span class=\"hljs-string\">&quot;Prayagraj&quot;</span>] = <span class=\"hljs-literal\">false</span>;\n    correct_res[<span class=\"hljs-string\">&quot;Noida&quot;</span>] = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-built_in\">assert</span>(correct_res == returned_res);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 3 Passed...&quot;</span> &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-comment\">/** Main function */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">tests</span>();\n    <span class=\"hljs-type\">size_t</span> edges = <span class=\"hljs-number\">0</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the number of edges: &quot;</span>;\n    std::cin &gt;&gt; edges;\n\n    graph::Graph&lt;<span class=\"hljs-type\">int</span>&gt; g;\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter space-separated pairs of vertices that form edges: &quot;</span>\n              &lt;&lt; std::endl;\n    <span class=\"hljs-keyword\">while</span> (edges--) {\n        <span class=\"hljs-type\">int</span> u = <span class=\"hljs-number\">0</span>, v = <span class=\"hljs-number\">0</span>;\n        std::cin &gt;&gt; u &gt;&gt; v;\n        g.<span class=\"hljs-built_in\">add_edge</span>(u, v);\n    }\n\n    g.<span class=\"hljs-built_in\">breadth_first_search</span>(<span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "go": {
      "dir": "graphs/search/breadthFirstSearch.go",
      "url": "https://github.com/TheAlgorithms/go/tree/master/graphs/search/breadthFirstSearch.go",
      "code": "<span class=\"hljs-comment\">// Package search Graph search algorithms</span>\n<span class=\"hljs-comment\">// reference: https://en.wikipedia.org/wiki/Tree_traversal</span>\n<span class=\"hljs-keyword\">package</span> search\n\n<span class=\"hljs-comment\">/*BreadthFirstSearch is an algorithm for traversing and searching graph data structures.\n\tIt starts at an arbitrary node of a graph, and explores all of the neighbor nodes\n\tat the present depth prior to moving on to the nodes at the next depth level.\n\tWorst-case performance\t \t\tO(|V|+|E|)=O(b^{d})}O(|V|+|E|)=O(b^{d})\n\tWorst-case space complexity\t \tO(|V|)=O(b^{d})}O(|V|)=O(b^{d})\nreference: https://en.wikipedia.org/wiki/Breadth-first_search\n*/</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">BreadthFirstSearch</span><span class=\"hljs-params\">(start, end, nodes <span class=\"hljs-keyword\">int</span>, edges [][]<span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-params\">(isConnected <span class=\"hljs-keyword\">bool</span>, distance <span class=\"hljs-keyword\">int</span>)</span></span> {\n\tqueue := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-number\">0</span>)\n\tdiscovered := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">int</span>, nodes)\n\tdiscovered[start] = <span class=\"hljs-number\">1</span>\n\tqueue = <span class=\"hljs-built_in\">append</span>(queue, start)\n\t<span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">len</span>(queue) &gt; <span class=\"hljs-number\">0</span> {\n\t\tv := queue[<span class=\"hljs-number\">0</span>]\n\t\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(queue) &gt; <span class=\"hljs-number\">0</span> {\n\t\t\tqueue = queue[<span class=\"hljs-number\">1</span>:]\n\t\t}\n\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(edges[v]); i++ {\n\t\t\t<span class=\"hljs-keyword\">if</span> discovered[i] == <span class=\"hljs-number\">0</span> &amp;&amp; edges[v][i] &gt; <span class=\"hljs-number\">0</span> {\n\t\t\t\t<span class=\"hljs-keyword\">if</span> i == end {\n\t\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>, discovered[v]\n\t\t\t\t}\n\t\t\t\tdiscovered[i] = discovered[v] + <span class=\"hljs-number\">1</span>\n\t\t\t\tqueue = <span class=\"hljs-built_in\">append</span>(queue, i)\n\t\t\t}\n\t\t}\n\t}\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>, <span class=\"hljs-number\">0</span>\n}\n"
    },
    "dart": {
      "dir": "graphs/breadth_first_search.dart",
      "url": "https://github.com/TheAlgorithms/dart/tree/master/graphs/breadth_first_search.dart",
      "code": "<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;dart:collection&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;package:test/test.dart&#x27;</span>;\n\n<span class=\"hljs-comment\">/// <span class=\"language-markdown\">Implementation of Breadth First Search</span></span>\n<span class=\"hljs-comment\">/// <span class=\"language-markdown\">https://en.wikipedia.org/wiki/Breadth-first<span class=\"hljs-emphasis\">_search</span></span></span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Graph</span> </span>{\n  <span class=\"hljs-comment\">/// <span class=\"language-markdown\"><span class=\"hljs-emphasis\">Adjacency List representation using dynamic list and HashMap</span></span></span>\n  HashMap graph = <span class=\"hljs-keyword\">new</span> HashMap&lt;<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">dynamic</span>&gt;&gt;();\n  <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; nodes;\n\n  <span class=\"hljs-keyword\">void</span> makeGraph() {\n    <span class=\"hljs-comment\">/// <span class=\"language-markdown\"><span class=\"hljs-emphasis\">initialise all nodes with empty lists.</span></span></span>\n    <span class=\"hljs-comment\">/// <span class=\"language-markdown\"><span class=\"hljs-emphasis\">each node will have a list as value which stores</span></span></span>\n    <span class=\"hljs-comment\">/// <span class=\"language-markdown\"><span class=\"hljs-emphasis\">the nodes to which it is connected to</span></span></span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-keyword\">this</span>.nodes.length; i++) {\n      <span class=\"hljs-keyword\">this</span>.graph[nodes[i]] = <span class=\"hljs-built_in\">List</span>();\n    }\n  }\n\n  Graph(<span class=\"hljs-keyword\">this</span>.nodes) {\n    <span class=\"hljs-keyword\">this</span>.makeGraph();\n  }\n\n  <span class=\"hljs-built_in\">int</span> <span class=\"hljs-keyword\">get</span> numberOfNodesInGraph {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.nodes.length;\n  }\n\n  HashMap <span class=\"hljs-keyword\">get</span> graphDataStructure {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.graph;\n  }\n\n  <span class=\"hljs-keyword\">void</span> addNodes(<span class=\"hljs-built_in\">int</span> newNode) {\n    <span class=\"hljs-keyword\">this</span>.nodes.add(newNode);\n    <span class=\"hljs-keyword\">this</span>.graph[newNode] = <span class=\"hljs-built_in\">List</span>();\n  }\n\n  <span class=\"hljs-keyword\">void</span> addEdges(<span class=\"hljs-built_in\">int</span> start, <span class=\"hljs-built_in\">int</span> end) {\n    <span class=\"hljs-keyword\">this</span>.graph[start].add(end);\n  }\n}\n\n<span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; breadthFirstSearch(Graph graph, <span class=\"hljs-built_in\">int</span> numberOfNodes, <span class=\"hljs-built_in\">int</span> startNode) {\n  Queue queue = <span class=\"hljs-keyword\">new</span> Queue&lt;<span class=\"hljs-built_in\">int</span>&gt;();\n  <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; answer = <span class=\"hljs-built_in\">List</span>();\n  queue.add(startNode);\n  <span class=\"hljs-keyword\">while</span> (queue.isNotEmpty) {\n    <span class=\"hljs-built_in\">int</span> node = queue.removeFirst();\n    answer.add(node);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> child <span class=\"hljs-keyword\">in</span> graph.graph[node]) {\n      queue.add(child);\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> answer;\n}\n\n<span class=\"hljs-keyword\">void</span> main() {\n  test((<span class=\"hljs-string\">&#x27;Test case 1:&#x27;</span>), () {\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; nodes = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n    <span class=\"hljs-built_in\">int</span> numberOfEdges = <span class=\"hljs-number\">2</span>;\n\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt;&gt; edges = [\n      [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>],\n      [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>]\n    ];\n    Graph graph = Graph(nodes);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; numberOfEdges; i++) {\n      <span class=\"hljs-built_in\">int</span> start = edges[i][<span class=\"hljs-number\">0</span>];\n      <span class=\"hljs-built_in\">int</span> end = edges[i][<span class=\"hljs-number\">1</span>];\n      graph.addEdges(start, end);\n    }\n    <span class=\"hljs-built_in\">int</span> startNode = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; answer =\n        breadthFirstSearch(graph, graph.numberOfNodesInGraph, startNode);\n    expect(answer, equals([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]));\n  });\n\n  test((<span class=\"hljs-string\">&#x27;Test case 2:&#x27;</span>), () {\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; nodes = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];\n    <span class=\"hljs-built_in\">int</span> numberOfEdges = <span class=\"hljs-number\">4</span>;\n\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt;&gt; edges = [\n      [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>],\n      [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>],\n      [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>],\n      [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>]\n    ];\n    Graph graph = Graph(nodes);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; numberOfEdges; i++) {\n      <span class=\"hljs-built_in\">int</span> start = edges[i][<span class=\"hljs-number\">0</span>];\n      <span class=\"hljs-built_in\">int</span> end = edges[i][<span class=\"hljs-number\">1</span>];\n      graph.addEdges(start, end);\n    }\n    <span class=\"hljs-built_in\">int</span> startNode = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; answer =\n        breadthFirstSearch(graph, graph.numberOfNodesInGraph, startNode);\n    expect(answer, equals([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]));\n  });\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Anup Kumar Panwar",
      "email": "1anuppanwar@gmail.com",
      "commits": 1
    },
    {
      "name": "AlexDvorak",
      "email": "opti.jawsome@gmail.com",
      "commits": 1
    },
    {
      "name": "Brayo",
      "email": "vukubrian@gmail.com",
      "commits": 1
    },
    {
      "name": "Kaveh Fazaeli",
      "email": "kaveh.fazaeli@gmail.com",
      "commits": 1
    },
    {
      "name": "Akash G Krishnan",
      "email": "krishnanag1996@gmail.com",
      "commits": 1
    },
    {
      "name": "hasan",
      "email": "hasanuli10@gmail.com",
      "commits": 1
    },
    {
      "name": "ParthS007",
      "email": "parth1989shandilya@gmail.com",
      "commits": 1
    },
    {
      "name": "Kaustubh Damania",
      "email": "kaustubh.damania@gmail.com",
      "commits": 1
    },
    {
      "name": "gpamangkp",
      "email": "gpamangkp.18je0087@mc.iitism.ac.in",
      "commits": 1
    },
    {
      "name": "Lewis Tian",
      "email": "taseikyo@gmail.com",
      "commits": 1
    },
    {
      "name": "Sanders Lin",
      "email": "45224617+SandersLin@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "cclauss",
      "email": "cclauss@bluewin.ch",
      "commits": 1
    },
    {
      "name": "97arushisharma",
      "email": "97arushisharma@gmail.com",
      "commits": 1
    },
    {
      "name": "mounaim",
      "email": "mounaim.zaryouhi@gmail.com",
      "commits": 1
    },
    {
      "name": "rxaru",
      "email": "ai.kanaria.ai@gmail.com",
      "commits": 2
    },
    {
      "name": "algobytewise",
      "email": "algobytewise@gmail.com",
      "commits": 2
    },
    {
      "name": "Alvin Nguyen",
      "email": "alvin@D-10-16-24-223.dhcp4.washington.edu",
      "commits": 2
    },
    {
      "name": "Francisco Matias",
      "email": "franciscomatias@alu.ufc.br",
      "commits": 2
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 3
    },
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 3
    },
    {
      "name": "Gpamangkp",
      "email": "41160734+Gpamangkp@users.noreply.github.com",
      "commits": 7
    }
  ],
  "explanationUrl": {}
}
