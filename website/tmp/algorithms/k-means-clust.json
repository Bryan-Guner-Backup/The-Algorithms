{
  "slug": "k-means-clust",
  "name": "K Means Clust",
  "categories": ["machinelearning"],
  "body": {},
  "implementations": {
    "python": {
      "dir": "machine_learning/k_means_clust.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/machine_learning/k_means_clust.py",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;README, Author - Anurag Kumar(mailto:anuragkumarak95@gmail.com)\nRequirements:\n  - sklearn\n  - numpy\n  - matplotlib\nPython:\n  - 3.5\nInputs:\n  - X , a 2D numpy array of features.\n  - k , number of clusters to create.\n  - initial_centroids , initial centroid values generated by utility function(mentioned\n    in usage).\n  - maxiter , maximum number of iterations to process.\n  - heterogeneity , empty list that will be filled with hetrogeneity values if passed\n    to kmeans func.\nUsage:\n  1. define &#x27;k&#x27; value, &#x27;X&#x27; features array and &#x27;hetrogeneity&#x27; empty list\n  2. create initial_centroids,\n        initial_centroids = get_initial_centroids(\n            X,\n            k,\n            seed=0 # seed value for initial centroid generation,\n                   # None for randomness(default=None)\n            )\n  3. find centroids and clusters using kmeans function.\n        centroids, cluster_assignment = kmeans(\n            X,\n            k,\n            initial_centroids,\n            maxiter=400,\n            record_heterogeneity=heterogeneity,\n            verbose=True # whether to print logs in console or not.(default=False)\n            )\n  4. Plot the loss function, hetrogeneity values for every iteration saved in\n     hetrogeneity list.\n        plot_heterogeneity(\n            heterogeneity,\n            k\n        )\n  5. Transfers Dataframe into excel format it must have feature called\n      &#x27;Clust&#x27; with k means clustering numbers in it.\n&quot;&quot;&quot;</span>\n<span class=\"hljs-keyword\">import</span> warnings\n\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n<span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd\n<span class=\"hljs-keyword\">from</span> matplotlib <span class=\"hljs-keyword\">import</span> pyplot <span class=\"hljs-keyword\">as</span> plt\n<span class=\"hljs-keyword\">from</span> sklearn.metrics <span class=\"hljs-keyword\">import</span> pairwise_distances\n\nwarnings.filterwarnings(<span class=\"hljs-string\">&quot;ignore&quot;</span>)\n\nTAG = <span class=\"hljs-string\">&quot;K-MEANS-CLUST/ &quot;</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_initial_centroids</span>(<span class=\"hljs-params\">data, k, seed=<span class=\"hljs-literal\">None</span></span>):\n    <span class=\"hljs-string\">&quot;&quot;&quot;Randomly choose k data points as initial centroids&quot;&quot;&quot;</span>\n    <span class=\"hljs-keyword\">if</span> seed <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span>:  <span class=\"hljs-comment\"># useful for obtaining consistent results</span>\n        np.random.seed(seed)\n    n = data.shape[<span class=\"hljs-number\">0</span>]  <span class=\"hljs-comment\"># number of data points</span>\n\n    <span class=\"hljs-comment\"># Pick K indices from range [0, N).</span>\n    rand_indices = np.random.randint(<span class=\"hljs-number\">0</span>, n, k)\n\n    <span class=\"hljs-comment\"># Keep centroids as dense format, as many entries will be nonzero due to averaging.</span>\n    <span class=\"hljs-comment\"># As long as at least one document in a cluster contains a word,</span>\n    <span class=\"hljs-comment\"># it will carry a nonzero weight in the TF-IDF vector of the centroid.</span>\n    centroids = data[rand_indices, :]\n\n    <span class=\"hljs-keyword\">return</span> centroids\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">centroid_pairwise_dist</span>(<span class=\"hljs-params\">X, centroids</span>):\n    <span class=\"hljs-keyword\">return</span> pairwise_distances(X, centroids, metric=<span class=\"hljs-string\">&quot;euclidean&quot;</span>)\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">assign_clusters</span>(<span class=\"hljs-params\">data, centroids</span>):\n\n    <span class=\"hljs-comment\"># Compute distances between each data point and the set of centroids:</span>\n    <span class=\"hljs-comment\"># Fill in the blank (RHS only)</span>\n    distances_from_centroids = centroid_pairwise_dist(data, centroids)\n\n    <span class=\"hljs-comment\"># Compute cluster assignments for each data point:</span>\n    <span class=\"hljs-comment\"># Fill in the blank (RHS only)</span>\n    cluster_assignment = np.argmin(distances_from_centroids, axis=<span class=\"hljs-number\">1</span>)\n\n    <span class=\"hljs-keyword\">return</span> cluster_assignment\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">revise_centroids</span>(<span class=\"hljs-params\">data, k, cluster_assignment</span>):\n    new_centroids = []\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(k):\n        <span class=\"hljs-comment\"># Select all data points that belong to cluster i. Fill in the blank (RHS only)</span>\n        member_data_points = data[cluster_assignment == i]\n        <span class=\"hljs-comment\"># Compute the mean of the data points. Fill in the blank (RHS only)</span>\n        centroid = member_data_points.mean(axis=<span class=\"hljs-number\">0</span>)\n        new_centroids.append(centroid)\n    new_centroids = np.array(new_centroids)\n\n    <span class=\"hljs-keyword\">return</span> new_centroids\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">compute_heterogeneity</span>(<span class=\"hljs-params\">data, k, centroids, cluster_assignment</span>):\n\n    heterogeneity = <span class=\"hljs-number\">0.0</span>\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(k):\n\n        <span class=\"hljs-comment\"># Select all data points that belong to cluster i. Fill in the blank (RHS only)</span>\n        member_data_points = data[cluster_assignment == i, :]\n\n        <span class=\"hljs-keyword\">if</span> member_data_points.shape[<span class=\"hljs-number\">0</span>] &gt; <span class=\"hljs-number\">0</span>:  <span class=\"hljs-comment\"># check if i-th cluster is non-empty</span>\n            <span class=\"hljs-comment\"># Compute distances from centroid to data points (RHS only)</span>\n            distances = pairwise_distances(\n                member_data_points, [centroids[i]], metric=<span class=\"hljs-string\">&quot;euclidean&quot;</span>\n            )\n            squared_distances = distances ** <span class=\"hljs-number\">2</span>\n            heterogeneity += np.<span class=\"hljs-built_in\">sum</span>(squared_distances)\n\n    <span class=\"hljs-keyword\">return</span> heterogeneity\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">plot_heterogeneity</span>(<span class=\"hljs-params\">heterogeneity, k</span>):\n    plt.figure(figsize=(<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">4</span>))\n    plt.plot(heterogeneity, linewidth=<span class=\"hljs-number\">4</span>)\n    plt.xlabel(<span class=\"hljs-string\">&quot;# Iterations&quot;</span>)\n    plt.ylabel(<span class=\"hljs-string\">&quot;Heterogeneity&quot;</span>)\n    plt.title(<span class=\"hljs-string\">f&quot;Heterogeneity of clustering over time, K=<span class=\"hljs-subst\">{k:d}</span>&quot;</span>)\n    plt.rcParams.update({<span class=\"hljs-string\">&quot;font.size&quot;</span>: <span class=\"hljs-number\">16</span>})\n    plt.show()\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">kmeans</span>(<span class=\"hljs-params\">\n    data, k, initial_centroids, maxiter=<span class=\"hljs-number\">500</span>, record_heterogeneity=<span class=\"hljs-literal\">None</span>, verbose=<span class=\"hljs-literal\">False</span>\n</span>):\n    <span class=\"hljs-string\">&quot;&quot;&quot;This function runs k-means on given data and initial set of centroids.\n    maxiter: maximum number of iterations to run.(default=500)\n    record_heterogeneity: (optional) a list, to store the history of heterogeneity\n                          as function of iterations\n                          if None, do not store the history.\n    verbose: if True, print how many data points changed their cluster labels in\n                          each iteration&quot;&quot;&quot;</span>\n    centroids = initial_centroids[:]\n    prev_cluster_assignment = <span class=\"hljs-literal\">None</span>\n\n    <span class=\"hljs-keyword\">for</span> itr <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(maxiter):\n        <span class=\"hljs-keyword\">if</span> verbose:\n            <span class=\"hljs-built_in\">print</span>(itr, end=<span class=\"hljs-string\">&quot;&quot;</span>)\n\n        <span class=\"hljs-comment\"># 1. Make cluster assignments using nearest centroids</span>\n        cluster_assignment = assign_clusters(data, centroids)\n\n        <span class=\"hljs-comment\"># 2. Compute a new centroid for each of the k clusters, averaging all data</span>\n        <span class=\"hljs-comment\">#    points assigned to that cluster.</span>\n        centroids = revise_centroids(data, k, cluster_assignment)\n\n        <span class=\"hljs-comment\"># Check for convergence: if none of the assignments changed, stop</span>\n        <span class=\"hljs-keyword\">if</span> (\n            prev_cluster_assignment <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span>\n            <span class=\"hljs-keyword\">and</span> (prev_cluster_assignment == cluster_assignment).<span class=\"hljs-built_in\">all</span>()\n        ):\n            <span class=\"hljs-keyword\">break</span>\n\n        <span class=\"hljs-comment\"># Print number of new assignments</span>\n        <span class=\"hljs-keyword\">if</span> prev_cluster_assignment <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span>:\n            num_changed = np.<span class=\"hljs-built_in\">sum</span>(prev_cluster_assignment != cluster_assignment)\n            <span class=\"hljs-keyword\">if</span> verbose:\n                <span class=\"hljs-built_in\">print</span>(\n                    <span class=\"hljs-string\">&quot;    {:5d} elements changed their cluster assignment.&quot;</span>.<span class=\"hljs-built_in\">format</span>(\n                        num_changed\n                    )\n                )\n\n        <span class=\"hljs-comment\"># Record heterogeneity convergence metric</span>\n        <span class=\"hljs-keyword\">if</span> record_heterogeneity <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span>:\n            <span class=\"hljs-comment\"># YOUR CODE HERE</span>\n            score = compute_heterogeneity(data, k, centroids, cluster_assignment)\n            record_heterogeneity.append(score)\n\n        prev_cluster_assignment = cluster_assignment[:]\n\n    <span class=\"hljs-keyword\">return</span> centroids, cluster_assignment\n\n\n<span class=\"hljs-comment\"># Mock test below</span>\n<span class=\"hljs-keyword\">if</span> <span class=\"hljs-literal\">False</span>:  <span class=\"hljs-comment\"># change to true to run this test case.</span>\n    <span class=\"hljs-keyword\">from</span> sklearn <span class=\"hljs-keyword\">import</span> datasets <span class=\"hljs-keyword\">as</span> ds\n\n    dataset = ds.load_iris()\n    k = <span class=\"hljs-number\">3</span>\n    heterogeneity = []\n    initial_centroids = get_initial_centroids(dataset[<span class=\"hljs-string\">&quot;data&quot;</span>], k, seed=<span class=\"hljs-number\">0</span>)\n    centroids, cluster_assignment = kmeans(\n        dataset[<span class=\"hljs-string\">&quot;data&quot;</span>],\n        k,\n        initial_centroids,\n        maxiter=<span class=\"hljs-number\">400</span>,\n        record_heterogeneity=heterogeneity,\n        verbose=<span class=\"hljs-literal\">True</span>,\n    )\n    plot_heterogeneity(heterogeneity, k)\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">ReportGenerator</span>(<span class=\"hljs-params\">\n    df: pd.DataFrame, ClusteringVariables: np.ndarray, FillMissingReport=<span class=\"hljs-literal\">None</span>\n</span>) -&gt; pd.DataFrame:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Function generates easy-erading clustering report. It takes 2 arguments as an input:\n        DataFrame - dataframe with predicted cluester column;\n        FillMissingReport - dictionary of rules how we are going to fill missing\n        values of for final report generate (not included in modeling);\n    in order to run the function following libraries must be imported:\n        import pandas as pd\n        import numpy as np\n    &gt;&gt;&gt; data = pd.DataFrame()\n    &gt;&gt;&gt; data[&#x27;numbers&#x27;] = [1, 2, 3]\n    &gt;&gt;&gt; data[&#x27;col1&#x27;] = [0.5, 2.5, 4.5]\n    &gt;&gt;&gt; data[&#x27;col2&#x27;] = [100, 200, 300]\n    &gt;&gt;&gt; data[&#x27;col3&#x27;] = [10, 20, 30]\n    &gt;&gt;&gt; data[&#x27;Cluster&#x27;] = [1, 1, 2]\n    &gt;&gt;&gt; ReportGenerator(data, [&#x27;col1&#x27;, &#x27;col2&#x27;], 0)\n               Features               Type   Mark           1           2\n    0    # of Customers        ClusterSize  False    2.000000    1.000000\n    1    % of Customers  ClusterProportion  False    0.666667    0.333333\n    2              col1    mean_with_zeros   True    1.500000    4.500000\n    3              col2    mean_with_zeros   True  150.000000  300.000000\n    4           numbers    mean_with_zeros  False    1.500000    3.000000\n    ..              ...                ...    ...         ...         ...\n    99            dummy                 5%  False    1.000000    1.000000\n    100           dummy                95%  False    1.000000    1.000000\n    101           dummy              stdev  False    0.000000         NaN\n    102           dummy               mode  False    1.000000    1.000000\n    103           dummy             median  False    1.000000    1.000000\n    &lt;BLANKLINE&gt;\n    [104 rows x 5 columns]\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-comment\"># Fill missing values with given rules</span>\n    <span class=\"hljs-keyword\">if</span> FillMissingReport:\n        df.fillna(value=FillMissingReport, inplace=<span class=\"hljs-literal\">True</span>)\n    df[<span class=\"hljs-string\">&quot;dummy&quot;</span>] = <span class=\"hljs-number\">1</span>\n    numeric_cols = df.select_dtypes(np.number).columns\n    report = (\n        df.groupby([<span class=\"hljs-string\">&quot;Cluster&quot;</span>])[  <span class=\"hljs-comment\"># construct report dataframe</span>\n            numeric_cols\n        ]  <span class=\"hljs-comment\"># group by cluster number</span>\n        .agg(\n            [\n                (<span class=\"hljs-string\">&quot;sum&quot;</span>, np.<span class=\"hljs-built_in\">sum</span>),\n                (<span class=\"hljs-string\">&quot;mean_with_zeros&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: np.mean(np.nan_to_num(x))),\n                (<span class=\"hljs-string\">&quot;mean_without_zeros&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.replace(<span class=\"hljs-number\">0</span>, np.NaN).mean()),\n                (\n                    <span class=\"hljs-string\">&quot;mean_25-75&quot;</span>,\n                    <span class=\"hljs-keyword\">lambda</span> x: np.mean(\n                        np.nan_to_num(\n                            <span class=\"hljs-built_in\">sorted</span>(x)[\n                                <span class=\"hljs-built_in\">round</span>(<span class=\"hljs-built_in\">len</span>(x) * <span class=\"hljs-number\">25</span> / <span class=\"hljs-number\">100</span>) : <span class=\"hljs-built_in\">round</span>(<span class=\"hljs-built_in\">len</span>(x) * <span class=\"hljs-number\">75</span> / <span class=\"hljs-number\">100</span>)\n                            ]\n                        )\n                    ),\n                ),\n                (<span class=\"hljs-string\">&quot;mean_with_na&quot;</span>, np.mean),\n                (<span class=\"hljs-string\">&quot;min&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.<span class=\"hljs-built_in\">min</span>()),\n                (<span class=\"hljs-string\">&quot;5%&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.quantile(<span class=\"hljs-number\">0.05</span>)),\n                (<span class=\"hljs-string\">&quot;25%&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.quantile(<span class=\"hljs-number\">0.25</span>)),\n                (<span class=\"hljs-string\">&quot;50%&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.quantile(<span class=\"hljs-number\">0.50</span>)),\n                (<span class=\"hljs-string\">&quot;75%&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.quantile(<span class=\"hljs-number\">0.75</span>)),\n                (<span class=\"hljs-string\">&quot;95%&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.quantile(<span class=\"hljs-number\">0.95</span>)),\n                (<span class=\"hljs-string\">&quot;max&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.<span class=\"hljs-built_in\">max</span>()),\n                (<span class=\"hljs-string\">&quot;count&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.count()),\n                (<span class=\"hljs-string\">&quot;stdev&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.std()),\n                (<span class=\"hljs-string\">&quot;mode&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.mode()[<span class=\"hljs-number\">0</span>]),\n                (<span class=\"hljs-string\">&quot;median&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: x.median()),\n                (<span class=\"hljs-string\">&quot;# &gt; 0&quot;</span>, <span class=\"hljs-keyword\">lambda</span> x: (x &gt; <span class=\"hljs-number\">0</span>).<span class=\"hljs-built_in\">sum</span>()),\n            ]\n        )\n        .T.reset_index()\n        .rename(index=<span class=\"hljs-built_in\">str</span>, columns={<span class=\"hljs-string\">&quot;level_0&quot;</span>: <span class=\"hljs-string\">&quot;Features&quot;</span>, <span class=\"hljs-string\">&quot;level_1&quot;</span>: <span class=\"hljs-string\">&quot;Type&quot;</span>})\n    )  <span class=\"hljs-comment\"># rename columns</span>\n    <span class=\"hljs-comment\"># calculate the size of cluster(count of clientID&#x27;s)</span>\n    clustersize = report[\n        (report[<span class=\"hljs-string\">&quot;Features&quot;</span>] == <span class=\"hljs-string\">&quot;dummy&quot;</span>) &amp; (report[<span class=\"hljs-string\">&quot;Type&quot;</span>] == <span class=\"hljs-string\">&quot;count&quot;</span>)\n    ].copy()  <span class=\"hljs-comment\"># avoid SettingWithCopyWarning</span>\n    clustersize.<span class=\"hljs-type\">Type</span> = (\n        <span class=\"hljs-string\">&quot;ClusterSize&quot;</span>  <span class=\"hljs-comment\"># rename created cluster df to match report column names</span>\n    )\n    clustersize.Features = <span class=\"hljs-string\">&quot;# of Customers&quot;</span>\n    clusterproportion = pd.DataFrame(\n        clustersize.iloc[:, <span class=\"hljs-number\">2</span>:].values\n        / clustersize.iloc[:, <span class=\"hljs-number\">2</span>:].values.<span class=\"hljs-built_in\">sum</span>()  <span class=\"hljs-comment\"># calculating the proportion of cluster</span>\n    )\n    clusterproportion[\n        <span class=\"hljs-string\">&quot;Type&quot;</span>\n    ] = <span class=\"hljs-string\">&quot;% of Customers&quot;</span>  <span class=\"hljs-comment\"># rename created cluster df to match report column names</span>\n    clusterproportion[<span class=\"hljs-string\">&quot;Features&quot;</span>] = <span class=\"hljs-string\">&quot;ClusterProportion&quot;</span>\n    cols = clusterproportion.columns.tolist()\n    cols = cols[-<span class=\"hljs-number\">2</span>:] + cols[:-<span class=\"hljs-number\">2</span>]\n    clusterproportion = clusterproportion[cols]  <span class=\"hljs-comment\"># rearrange columns to match report</span>\n    clusterproportion.columns = report.columns\n    a = pd.DataFrame(\n        <span class=\"hljs-built_in\">abs</span>(\n            report[report[<span class=\"hljs-string\">&quot;Type&quot;</span>] == <span class=\"hljs-string\">&quot;count&quot;</span>].iloc[:, <span class=\"hljs-number\">2</span>:].values\n            - clustersize.iloc[:, <span class=\"hljs-number\">2</span>:].values\n        )\n    )  <span class=\"hljs-comment\"># generating df with count of nan values</span>\n    a[<span class=\"hljs-string\">&quot;Features&quot;</span>] = <span class=\"hljs-number\">0</span>\n    a[<span class=\"hljs-string\">&quot;Type&quot;</span>] = <span class=\"hljs-string\">&quot;# of nan&quot;</span>\n    a.Features = report[\n        report[<span class=\"hljs-string\">&quot;Type&quot;</span>] == <span class=\"hljs-string\">&quot;count&quot;</span>\n    ].Features.tolist()  <span class=\"hljs-comment\"># filling values in order to match report</span>\n    cols = a.columns.tolist()\n    cols = cols[-<span class=\"hljs-number\">2</span>:] + cols[:-<span class=\"hljs-number\">2</span>]\n    a = a[cols]  <span class=\"hljs-comment\"># rearrange columns to match report</span>\n    a.columns = report.columns  <span class=\"hljs-comment\"># rename columns to match report</span>\n    report = report.drop(\n        report[report.<span class=\"hljs-type\">Type</span> == <span class=\"hljs-string\">&quot;count&quot;</span>].index\n    )  <span class=\"hljs-comment\"># drop count values except cluster size</span>\n    report = pd.concat(\n        [report, a, clustersize, clusterproportion], axis=<span class=\"hljs-number\">0</span>\n    )  <span class=\"hljs-comment\"># concat report with clustert size and nan values</span>\n    report[<span class=\"hljs-string\">&quot;Mark&quot;</span>] = report[<span class=\"hljs-string\">&quot;Features&quot;</span>].isin(ClusteringVariables)\n    cols = report.columns.tolist()\n    cols = cols[<span class=\"hljs-number\">0</span>:<span class=\"hljs-number\">2</span>] + cols[-<span class=\"hljs-number\">1</span>:] + cols[<span class=\"hljs-number\">2</span>:-<span class=\"hljs-number\">1</span>]\n    report = report[cols]\n    sorter1 = {\n        <span class=\"hljs-string\">&quot;ClusterSize&quot;</span>: <span class=\"hljs-number\">9</span>,\n        <span class=\"hljs-string\">&quot;ClusterProportion&quot;</span>: <span class=\"hljs-number\">8</span>,\n        <span class=\"hljs-string\">&quot;mean_with_zeros&quot;</span>: <span class=\"hljs-number\">7</span>,\n        <span class=\"hljs-string\">&quot;mean_with_na&quot;</span>: <span class=\"hljs-number\">6</span>,\n        <span class=\"hljs-string\">&quot;max&quot;</span>: <span class=\"hljs-number\">5</span>,\n        <span class=\"hljs-string\">&quot;50%&quot;</span>: <span class=\"hljs-number\">4</span>,\n        <span class=\"hljs-string\">&quot;min&quot;</span>: <span class=\"hljs-number\">3</span>,\n        <span class=\"hljs-string\">&quot;25%&quot;</span>: <span class=\"hljs-number\">2</span>,\n        <span class=\"hljs-string\">&quot;75%&quot;</span>: <span class=\"hljs-number\">1</span>,\n        <span class=\"hljs-string\">&quot;# of nan&quot;</span>: <span class=\"hljs-number\">0</span>,\n        <span class=\"hljs-string\">&quot;# &gt; 0&quot;</span>: -<span class=\"hljs-number\">1</span>,\n        <span class=\"hljs-string\">&quot;sum_with_na&quot;</span>: -<span class=\"hljs-number\">2</span>,\n    }\n    report = (\n        report.assign(\n            Sorter1=<span class=\"hljs-keyword\">lambda</span> x: x.<span class=\"hljs-type\">Type</span>.<span class=\"hljs-built_in\">map</span>(sorter1),\n            Sorter2=<span class=\"hljs-keyword\">lambda</span> x: <span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">reversed</span>(<span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(x)))),\n        )\n        .sort_values([<span class=\"hljs-string\">&quot;Sorter1&quot;</span>, <span class=\"hljs-string\">&quot;Mark&quot;</span>, <span class=\"hljs-string\">&quot;Sorter2&quot;</span>], ascending=<span class=\"hljs-literal\">False</span>)\n        .drop([<span class=\"hljs-string\">&quot;Sorter1&quot;</span>, <span class=\"hljs-string\">&quot;Sorter2&quot;</span>], axis=<span class=\"hljs-number\">1</span>)\n    )\n    report.columns.name = <span class=\"hljs-string\">&quot;&quot;</span>\n    report = report.reset_index()\n    report.drop(columns=[<span class=\"hljs-string\">&quot;index&quot;</span>], inplace=<span class=\"hljs-literal\">True</span>)\n    <span class=\"hljs-keyword\">return</span> report\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    <span class=\"hljs-keyword\">import</span> doctest\n\n    doctest.testmod()\n"
    }
  },
  "contributors": [
    {
      "name": "algobytewise",
      "email": "algobytewise@gmail.com",
      "commits": 1
    },
    {
      "name": "shellhub",
      "email": "shellhub.me@gmail.com",
      "commits": 1
    },
    {
      "name": "BAKEZQ",
      "email": "zhongquan789@gmail.com",
      "commits": 1
    },
    {
      "name": "beqakd",
      "email": "39763019+beqakd@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "cclauss",
      "email": "cclauss@bluewin.ch",
      "commits": 1
    },
    {
      "name": "Anurag Kumar",
      "email": "anuragkumarak95@gmail.com",
      "commits": 1
    },
    {
      "name": "97arushisharma",
      "email": "97arushisharma@gmail.com",
      "commits": 1
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 6
    }
  ],
  "explanationUrl": {}
}
