{
  "slug": "a-star-search",
  "name": "A Star Search",
  "categories": ["machinelearning"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "machine_learning/a_star_search.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/machine_learning/a_star_search.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @brief\n * [A* search algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm)\n * @details\n * A* is an informed search algorithm, or a best-first search, meaning that it\n * is formulated in terms of weighted graphs: starting from a specific starting\n * node of a graph (initial state), it aims to find a path to the given goal\n * node having the smallest cost (least distance travelled, shortest time,\n * etc.). It evaluates by maintaining a tree of paths originating at the start\n * node and extending those paths one edge at a time until it reaches the final\n * state.\n * The weighted edges (or cost) is evaluated on two factors, G score\n * (cost required from starting node or initial state to current state) and H\n * score (cost required from current state to final state). The F(state), then\n * is evaluated as:\n * F(state) = G(state) + H(state).\n *\n * To solve the given search with shortest cost or path possible  is to inspect\n * values having minimum F(state).\n * @author [Ashish Daulatabad](https://github.com/AshishYUO)\n */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span>   <span class=\"hljs-comment\">/// for `std::reverse` function</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;array&gt;</span>       <span class=\"hljs-comment\">/// for `std::array`, representing `EightPuzzle` board</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>     <span class=\"hljs-comment\">/// for `assert`</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;functional&gt;</span>  <span class=\"hljs-comment\">/// for `std::function` STL</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>    <span class=\"hljs-comment\">/// for IO operations</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;map&gt;</span>         <span class=\"hljs-comment\">/// for `std::map` STL</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;set&gt;</span>         <span class=\"hljs-comment\">/// for `std::set` STL</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>      <span class=\"hljs-comment\">/// for `std::vector` STL</span></span>\n<span class=\"hljs-comment\">/**\n * @namespace machine_learning\n * @brief Machine learning algorithms\n */</span>\n<span class=\"hljs-keyword\">namespace</span> machine_learning {\n<span class=\"hljs-comment\">/**\n * @namespace aystar_search\n * @brief Functions for [A*\n * Search](https://en.wikipedia.org/wiki/A*_search_algorithm) implementation.\n */</span>\n<span class=\"hljs-keyword\">namespace</span> aystar_search {\n<span class=\"hljs-comment\">/**\n * @class EightPuzzle\n * @brief A class defining [EightPuzzle/15-Puzzle\n * game](https://en.wikipedia.org/wiki/15_puzzle).\n * @details\n * A well known 3 x 3 puzzle of the form\n * `\n * 1   2   3\n * 4   5   6\n * 7   8   0\n * `\n * where `0` represents an empty space in the puzzle\n * Given any random state, the goal is to achieve the above configuration\n * (or any other configuration if possible)\n * @tparam N size of the square Puzzle, default is set to 3 (since it is\n * EightPuzzle)\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-type\">size_t</span> N = <span class=\"hljs-number\">3</span>&gt;\n<span class=\"hljs-keyword\">class</span> EightPuzzle {\n    std::array&lt;std::array&lt;<span class=\"hljs-type\">uint32_t</span>, N&gt;, N&gt;\n        board;  <span class=\"hljs-comment\">/// N x N array to store the current state of the Puzzle.</span>\n\n    std::vector&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;&gt; moves = {\n        {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>},\n        {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>},\n        {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>},\n        {<span class=\"hljs-number\">-1</span>,\n         <span class=\"hljs-number\">0</span>}};  <span class=\"hljs-comment\">/// A helper array to evaluate the next state from current state;</span>\n    <span class=\"hljs-comment\">/**\n     * @brief Finds an empty space in puzzle (in this case; a zero)\n     * @returns a pair indicating integer distances from top and right\n     * respectively, else returns -1, -1\n     */</span>\n    <span class=\"hljs-function\">std::pair&lt;<span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-type\">uint32_t</span>&gt; <span class=\"hljs-title\">find_zero</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; ++i) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; N; ++j) {\n                <span class=\"hljs-keyword\">if</span> (!board[i][j]) {\n                    <span class=\"hljs-keyword\">return</span> {i, j};\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> {<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>};\n    }\n    <span class=\"hljs-comment\">/**\n     * @brief check whether the index value is bounded within the puzzle area\n     * @param value index for the current board\n     * @returns `true` if index is within the board, else `false`\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">in_range</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">uint32_t</span> value)</span> <span class=\"hljs-keyword\">const</span> </span>{\n        <span class=\"hljs-keyword\">return</span> value &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; value &lt; N;\n    }\n\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-comment\">/**\n     * @brief get the value from i units from right and j units from left side\n     * of the board\n     * @param i integer denoting ith row\n     * @param j integer denoting column\n     * @returns non-negative integer denoting the value at ith row and jth\n     * column\n     * @returns -1 if invalid i or j position\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> i, <span class=\"hljs-type\">size_t</span> j)</span> <span class=\"hljs-keyword\">const</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">in_range</span>(i) &amp;&amp; <span class=\"hljs-built_in\">in_range</span>(j)) {\n            <span class=\"hljs-keyword\">return</span> board[i][j];\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    }\n    <span class=\"hljs-comment\">/**\n     * @brief Returns the current state of the board\n     */</span>\n    std::array&lt;std::array&lt;<span class=\"hljs-type\">uint32_t</span>, N&gt;, N&gt; <span class=\"hljs-built_in\">get_state</span>() { <span class=\"hljs-keyword\">return</span> board; }\n\n    <span class=\"hljs-comment\">/**\n     * @brief returns the size of the EightPuzzle (number of row / column)\n     * @return N, the size of the puzzle.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">get_size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span> </span>{ <span class=\"hljs-keyword\">return</span> N; }\n    <span class=\"hljs-comment\">/**\n     * @brief Default constructor for EightPuzzle\n     */</span>\n    <span class=\"hljs-built_in\">EightPuzzle</span>() {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; ++i) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; N; ++j) {\n                board[i][j] = ((i * <span class=\"hljs-number\">3</span> + j + <span class=\"hljs-number\">1</span>) % (N * N));\n            }\n        }\n    }\n    <span class=\"hljs-comment\">/**\n     * @brief Parameterized Constructor for EightPuzzle\n     * @param init a 2-dimensional array denoting a puzzle configuration\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">EightPuzzle</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::array&lt;std::array&lt;<span class=\"hljs-type\">uint32_t</span>, N&gt;, N&gt; &amp;init)</span>\n        : board(init) {</span>}\n\n    <span class=\"hljs-comment\">/**\n     * @brief Copy constructor\n     * @param A a reference of an EightPuzzle\n     */</span>\n    <span class=\"hljs-built_in\">EightPuzzle</span>(<span class=\"hljs-keyword\">const</span> EightPuzzle&lt;N&gt; &amp;A) : <span class=\"hljs-built_in\">board</span>(A.board) {}\n\n    <span class=\"hljs-comment\">/**\n     * @brief Move constructor\n     * @param A a reference of an EightPuzzle\n     */</span>\n    <span class=\"hljs-built_in\">EightPuzzle</span>(<span class=\"hljs-keyword\">const</span> EightPuzzle&lt;N&gt; &amp;&amp;A) <span class=\"hljs-keyword\">noexcept</span>\n        : <span class=\"hljs-built_in\">board</span>(std::<span class=\"hljs-built_in\">move</span>(A.board)) {}\n    <span class=\"hljs-comment\">/**\n     * @brief Destructor of EightPuzzle\n     */</span>\n    ~<span class=\"hljs-built_in\">EightPuzzle</span>() = <span class=\"hljs-keyword\">default</span>;\n\n    <span class=\"hljs-comment\">/**\n     * @brief Copy assignment operator\n     * @param A a reference of an EightPuzzle\n     */</span>\n    EightPuzzle &amp;<span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-keyword\">const</span> EightPuzzle &amp;A) {\n        board = A.board;\n        <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Move assignment operator\n     * @param A a reference of an EightPuzzle\n     */</span>\n    EightPuzzle &amp;<span class=\"hljs-keyword\">operator</span>=(EightPuzzle &amp;&amp;A) <span class=\"hljs-keyword\">noexcept</span> {\n        board = std::<span class=\"hljs-built_in\">move</span>(A.board);\n        <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Find all possible states after processing all possible\n     * moves, given the current state of the puzzle\n     * @returns list of vector containing all possible next moves\n     * @note the implementation is compulsory to create A* search\n     */</span>\n    std::vector&lt;EightPuzzle&lt;N&gt;&gt; <span class=\"hljs-built_in\">generate_possible_moves</span>() {\n        <span class=\"hljs-keyword\">auto</span> zero_pos = <span class=\"hljs-built_in\">find_zero</span>();\n        <span class=\"hljs-comment\">// vector which will contain all possible state from current state</span>\n        std::vector&lt;EightPuzzle&lt;N&gt;&gt; NewStates;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;move : moves) {\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">in_range</span>(zero_pos.first + move.first) &amp;&amp;\n                <span class=\"hljs-built_in\">in_range</span>(zero_pos.second + move.second)) {\n                <span class=\"hljs-comment\">// swap with the possible moves</span>\n                std::array&lt;std::array&lt;<span class=\"hljs-type\">uint32_t</span>, N&gt;, N&gt; new_config = board;\n                std::<span class=\"hljs-built_in\">swap</span>(new_config[zero_pos.first][zero_pos.second],\n                          new_config[zero_pos.first + move.first]\n                                    [zero_pos.second + move.second]);\n                <span class=\"hljs-function\">EightPuzzle&lt;N&gt; <span class=\"hljs-title\">new_state</span><span class=\"hljs-params\">(new_config)</span></span>;\n                <span class=\"hljs-comment\">// Store new state and calculate heuristic value, and depth</span>\n                NewStates.<span class=\"hljs-built_in\">emplace_back</span>(new_state);\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> NewStates;\n    }\n    <span class=\"hljs-comment\">/**\n     * @brief check whether two boards are equal\n     * @returns `true` if check.state is equal to `this-&gt;state`, else\n     * `false`\n     */</span>\n    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>==(<span class=\"hljs-keyword\">const</span> EightPuzzle&lt;N&gt; &amp;check) <span class=\"hljs-keyword\">const</span> {\n        <span class=\"hljs-keyword\">if</span> (check.<span class=\"hljs-built_in\">get_size</span>() != N) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n        }\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; ++i) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; N; ++j) {\n                <span class=\"hljs-keyword\">if</span> (board[i][j] != check.board[i][j]) {\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    }\n    <span class=\"hljs-comment\">/**\n     * @brief check whether one board is lexicographically smaller\n     * @returns `true` if this-&gt;state is lexicographically smaller than\n     * `check.state`, else `false`\n     */</span>\n    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>&lt;(<span class=\"hljs-keyword\">const</span> EightPuzzle&lt;N&gt; &amp;check) <span class=\"hljs-keyword\">const</span> {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; ++i) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; N; ++j) {\n                <span class=\"hljs-keyword\">if</span> (board[i][j] != check.board[i][j]) {\n                    <span class=\"hljs-keyword\">return</span> board[i][j] &lt; check.board[i][j];\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    }\n    <span class=\"hljs-comment\">/**\n     * @brief check whether one board is lexicographically smaller or equal\n     * @returns `true` if this-&gt;state is lexicographically smaller than\n     * `check.state` or same, else `false`\n     */</span>\n    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>&lt;=(<span class=\"hljs-keyword\">const</span> EightPuzzle&lt;N&gt; &amp;check) <span class=\"hljs-keyword\">const</span> {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; ++i) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; N; ++j) {\n                <span class=\"hljs-keyword\">if</span> (board[i][j] != check.board[i][j]) {\n                    <span class=\"hljs-keyword\">return</span> board[i][j] &lt; check.board[i][j];\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief friend operator to display EightPuzzle&lt;&gt;\n     * @param op ostream object\n     * @param SomeState a certain state.\n     * @returns ostream operator op\n     */</span>\n    <span class=\"hljs-keyword\">friend</span> std::ostream &amp;<span class=\"hljs-keyword\">operator</span>&lt;&lt;(std::ostream &amp;op,\n                                    <span class=\"hljs-keyword\">const</span> EightPuzzle&lt;N&gt; &amp;SomeState) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; ++i) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; N; ++j) {\n                op &lt;&lt; SomeState.board[i][j] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;\n            }\n            op &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n        }\n        <span class=\"hljs-keyword\">return</span> op;\n    }\n};\n<span class=\"hljs-comment\">/**\n * @class AyStarSearch\n * @brief A class defining [A* search\n * algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm). for some\n * initial state and final state\n * @details AyStarSearch class is defined as the informed search algorithm\n * that is formulated in terms of weighted graphs: starting from a specific\n * starting node of a graph (initial state), it aims to find a path to the given\n * goal node having the smallest cost (least distance travelled, shortest time,\n * etc.)\n * The weighted edges (or cost) is evaluated on two factors, G score\n * (cost required from starting node or initial state to current state) and H\n * score (cost required from current state to final state). The `F(state)`, then\n * is evaluated as:\n * `F(state) = G(state) + H(state)`.\n * The best search would be the final state having minimum `F(state)` value\n * @tparam Puzzle denotes the puzzle or problem involving initial state and\n * final state to be solved by A* search.\n * @note 1. The algorithm is referred from pesudocode from\n * [Wikipedia page](https://en.wikipedia.org/wiki/A*_search_algorithm)\n * as is.\n * 2. For `AyStarSearch` to work, the definitions for template Puzzle is\n * compulsory.\n * a. Comparison operator for template Puzzle (`&lt;`, `==`, and `&lt;=`)\n * b. `generate_possible_moves()`\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> Puzzle&gt;\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AyStarSearch</span> {\n    <span class=\"hljs-comment\">/**\n     * @brief Struct that handles all the information related to the current\n     * state.\n     */</span>\n    <span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Info</span> {\n        Puzzle state;                <span class=\"hljs-comment\">/// Holds the current state.</span>\n        <span class=\"hljs-type\">size_t</span> heuristic_value = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">/// stores h score</span>\n        <span class=\"hljs-type\">size_t</span> depth = <span class=\"hljs-number\">0</span>;            <span class=\"hljs-comment\">/// stores g score</span>\n\n        <span class=\"hljs-comment\">/**\n         * @brief Default constructor\n         */</span>\n        <span class=\"hljs-built_in\">Info</span>() = <span class=\"hljs-keyword\">default</span>;\n\n        <span class=\"hljs-comment\">/**\n         * @brief constructor having Puzzle as parameter\n         * @param A a puzzle object\n         */</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">Info</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> Puzzle &amp;A)</span> : state(std::move(A)) {</span>}\n\n        <span class=\"hljs-comment\">/**\n         * @brief constructor having three parameters\n         * @param A a puzzle object\n         * @param h_value heuristic value of this puzzle object\n         * @param depth the depth at which this node was found during traversal\n         */</span>\n        <span class=\"hljs-built_in\">Info</span>(<span class=\"hljs-keyword\">const</span> Puzzle &amp;A, <span class=\"hljs-type\">size_t</span> h_value, <span class=\"hljs-type\">size_t</span> d)\n            : <span class=\"hljs-built_in\">state</span>(std::<span class=\"hljs-built_in\">move</span>(A)), <span class=\"hljs-built_in\">heuristic_value</span>(h_value), <span class=\"hljs-built_in\">depth</span>(d) {}\n\n        <span class=\"hljs-comment\">/**\n         * @brief Copy constructor\n         * @param A Info object reference\n         */</span>\n        <span class=\"hljs-built_in\">Info</span>(<span class=\"hljs-keyword\">const</span> Info &amp;A)\n            : <span class=\"hljs-built_in\">state</span>(A.state),\n              <span class=\"hljs-built_in\">heuristic_value</span>(A.heuristic_value),\n              <span class=\"hljs-built_in\">depth</span>(A.depth) {}\n\n        <span class=\"hljs-comment\">/**\n         * @brief Move constructor\n         * @param A Info object reference\n         */</span>\n        <span class=\"hljs-built_in\">Info</span>(<span class=\"hljs-keyword\">const</span> Info &amp;&amp;A) <span class=\"hljs-keyword\">noexcept</span>\n            : <span class=\"hljs-built_in\">state</span>(std::<span class=\"hljs-built_in\">move</span>(A.state)),\n              <span class=\"hljs-built_in\">heuristic_value</span>(std::<span class=\"hljs-built_in\">move</span>(A.heuristic_value)),\n              <span class=\"hljs-built_in\">depth</span>(std::<span class=\"hljs-built_in\">move</span>(A.depth)) {}\n\n        <span class=\"hljs-comment\">/**\n         * @brief copy assignment operator\n         * @param A Info object reference\n         */</span>\n        Info &amp;<span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-keyword\">const</span> Info &amp;A) {\n            state = A.state;\n            heuristic_value = A.heuristic_value;\n            depth = A.depth;\n            <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;\n        }\n\n        <span class=\"hljs-comment\">/**\n         * @brief move assignment operator\n         * @param A Info object reference\n         */</span>\n        Info &amp;<span class=\"hljs-keyword\">operator</span>=(Info &amp;&amp;A) <span class=\"hljs-keyword\">noexcept</span> {\n            state = std::<span class=\"hljs-built_in\">move</span>(A.state);\n            heuristic_value = std::<span class=\"hljs-built_in\">move</span>(A.heuristic_value);\n            depth = std::<span class=\"hljs-built_in\">move</span>(A.depth);\n            <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;\n        }\n        <span class=\"hljs-comment\">/**\n         * @brief Destructor for Info\n         */</span>\n        ~<span class=\"hljs-built_in\">Info</span>() = <span class=\"hljs-keyword\">default</span>;\n    } Info;\n\n    Info Initial;  <span class=\"hljs-comment\">// Initial state of the AyStarSearch</span>\n    Info Final;    <span class=\"hljs-comment\">// Final state of the AyStarSearch</span>\n    <span class=\"hljs-comment\">/**\n     * @brief Custom comparator for open_list\n     */</span>\n    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">comparison_operator</span> {\n        <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> Info &amp;a, <span class=\"hljs-keyword\">const</span> Info &amp;b)</span> <span class=\"hljs-keyword\">const</span> </span>{\n            <span class=\"hljs-keyword\">return</span> a.state &lt; b.state;\n        }\n    };\n\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-comment\">/**\n     * @brief Parameterized constructor for AyStarSearch\n     * @param initial denoting initial state of the puzzle\n     * @param final denoting final state of the puzzle\n     */</span>\n    <span class=\"hljs-built_in\">AyStarSearch</span>(<span class=\"hljs-keyword\">const</span> Puzzle &amp;initial, <span class=\"hljs-keyword\">const</span> Puzzle &amp;<span class=\"hljs-keyword\">final</span>) {\n        Initial = <span class=\"hljs-built_in\">Info</span>(initial);\n        Final = <span class=\"hljs-built_in\">Info</span>(<span class=\"hljs-keyword\">final</span>);\n    }\n    <span class=\"hljs-comment\">/**\n     * @brief A helper solution: launches when a solution for AyStarSearch\n     * is found\n     * @param FinalState the pointer to the obtained final state\n     * @param parent_of the list of all parents of nodes stored during A*\n     * search\n     * @returns the list of moves denoting moves from final state to initial\n     * state (in reverse)\n     */</span>\n    <span class=\"hljs-function\">std::vector&lt;Puzzle&gt; <span class=\"hljs-title\">Solution</span><span class=\"hljs-params\">(\n        Info *FinalState,\n        <span class=\"hljs-keyword\">const</span> std::map&lt;Info, Info *, comparison_operator&gt; &amp;parent_of)</span> </span>{\n        <span class=\"hljs-comment\">//  Useful for traversing from final state to current state.</span>\n        Info *current_state = FinalState;\n        <span class=\"hljs-comment\">/*\n         * For storing the solution tree starting from initial state to\n         * final state\n         */</span>\n        std::vector&lt;Puzzle&gt; answer;\n        <span class=\"hljs-keyword\">while</span> (current_state != <span class=\"hljs-literal\">nullptr</span>) {\n            answer.<span class=\"hljs-built_in\">emplace_back</span>(current_state-&gt;state);\n            current_state = parent_of.<span class=\"hljs-built_in\">find</span>(*current_state)-&gt;second;\n        }\n        <span class=\"hljs-keyword\">return</span> answer;\n    }\n    <span class=\"hljs-comment\">/**\n     * Main algorithm for finding `FinalState`, given the `InitialState`\n     * @param dist the heuristic finction, defined by the user\n     * @param permissible_depth the depth at which the A* search discards\n     * searching for solution\n     * @returns List of moves from Final state to initial state, if\n     * evaluated, else returns an empty array\n     */</span>\n    <span class=\"hljs-function\">std::vector&lt;Puzzle&gt; <span class=\"hljs-title\">a_star_search</span><span class=\"hljs-params\">(\n        <span class=\"hljs-keyword\">const</span> std::function&lt;<span class=\"hljs-type\">uint32_t</span>(<span class=\"hljs-keyword\">const</span> Puzzle &amp;, <span class=\"hljs-keyword\">const</span> Puzzle &amp;)&gt; &amp;dist,\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">uint32_t</span> permissible_depth = <span class=\"hljs-number\">30</span>)</span> </span>{\n        std::map&lt;Info, Info *, comparison_operator&gt;\n            parent_of;  <span class=\"hljs-comment\">/// Stores the parent of the states</span>\n        std::map&lt;Info, <span class=\"hljs-type\">uint32_t</span>, comparison_operator&gt;\n            g_score;  <span class=\"hljs-comment\">/// Stores the g_score</span>\n        std::set&lt;Info, comparison_operator&gt;\n            open_list;  <span class=\"hljs-comment\">/// Stores the list to explore</span>\n        std::set&lt;Info, comparison_operator&gt;\n            closed_list;  <span class=\"hljs-comment\">/// Stores the list that are explored</span>\n\n        <span class=\"hljs-comment\">// Before starting the AyStartSearch, initialize the set and maps</span>\n        open_list.<span class=\"hljs-built_in\">emplace</span>(Initial);\n        parent_of[Initial] = <span class=\"hljs-literal\">nullptr</span>;\n        g_score[Initial] = <span class=\"hljs-number\">0</span>;\n\n        <span class=\"hljs-keyword\">while</span> (!open_list.<span class=\"hljs-built_in\">empty</span>()) {\n            <span class=\"hljs-comment\">// Iterator for state having having lowest f_score.</span>\n            <span class=\"hljs-keyword\">typename</span> std::set&lt;Info, comparison_operator&gt;::iterator\n                it_low_f_score;\n            <span class=\"hljs-type\">uint32_t</span> min_f_score = <span class=\"hljs-number\">1e9</span>;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> iter = open_list.<span class=\"hljs-built_in\">begin</span>(); iter != open_list.<span class=\"hljs-built_in\">end</span>();\n                 ++iter) {\n                <span class=\"hljs-comment\">// f score here is evaluated by g score (depth) and h score</span>\n                <span class=\"hljs-comment\">// (distance between current state and final state)</span>\n                <span class=\"hljs-type\">uint32_t</span> f_score = iter-&gt;heuristic_value + iter-&gt;depth;\n                <span class=\"hljs-keyword\">if</span> (f_score &lt; min_f_score) {\n                    min_f_score = f_score;\n                    it_low_f_score = iter;\n                }\n            }\n\n            <span class=\"hljs-comment\">// current_state, stores lowest f score so far for this state.</span>\n            Info *current_state = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Info</span>(*it_low_f_score);\n\n            <span class=\"hljs-comment\">// if this current state is equal to final, return</span>\n            <span class=\"hljs-keyword\">if</span> (current_state-&gt;state == Final.state) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Solution</span>(current_state, parent_of);\n            }\n            <span class=\"hljs-comment\">// else remove from open list as visited.</span>\n            open_list.<span class=\"hljs-built_in\">erase</span>(it_low_f_score);\n            <span class=\"hljs-comment\">// if current_state has exceeded the allowed depth, skip</span>\n            <span class=\"hljs-comment\">// neighbor checking</span>\n            <span class=\"hljs-keyword\">if</span> (current_state-&gt;depth &gt;= permissible_depth) {\n                <span class=\"hljs-keyword\">continue</span>;\n            }\n            <span class=\"hljs-comment\">// Generate all possible moves (neighbors) given the current</span>\n            <span class=\"hljs-comment\">// state</span>\n            std::vector&lt;Puzzle&gt; total_possible_moves =\n                current_state-&gt;state.<span class=\"hljs-built_in\">generate_possible_moves</span>();\n\n            <span class=\"hljs-keyword\">for</span> (Puzzle &amp;neighbor : total_possible_moves) {\n                <span class=\"hljs-comment\">// calculate score of neighbors with respect to</span>\n                <span class=\"hljs-comment\">// current_state</span>\n                Info Neighbor = {neighbor, <span class=\"hljs-built_in\">dist</span>(neighbor, Final.state),\n                                 current_state-&gt;depth + <span class=\"hljs-number\">1</span>};\n                <span class=\"hljs-type\">uint32_t</span> temp_g_score = Neighbor.depth;\n\n                <span class=\"hljs-comment\">// Check whether this state is explored.</span>\n                <span class=\"hljs-comment\">// If this state is discovered at greater depth, then discard,</span>\n                <span class=\"hljs-comment\">// else remove from closed list and explore the node</span>\n                <span class=\"hljs-keyword\">auto</span> closed_list_iter = closed_list.<span class=\"hljs-built_in\">find</span>(Neighbor);\n                <span class=\"hljs-keyword\">if</span> (closed_list_iter != closed_list.<span class=\"hljs-built_in\">end</span>()) {\n                    <span class=\"hljs-comment\">// 1. If state in closed list has higher depth, then remove</span>\n                    <span class=\"hljs-comment\">// from list since we have found better option,</span>\n                    <span class=\"hljs-comment\">// 2. Else don&#x27;t explore this state.</span>\n                    <span class=\"hljs-keyword\">if</span> (Neighbor.depth &lt; closed_list_iter-&gt;depth) {\n                        closed_list.<span class=\"hljs-built_in\">erase</span>(closed_list_iter);\n                    } <span class=\"hljs-keyword\">else</span> {\n                        <span class=\"hljs-keyword\">continue</span>;\n                    }\n                }\n                <span class=\"hljs-keyword\">auto</span> neighbor_g_score_iter = g_score.<span class=\"hljs-built_in\">find</span>(Neighbor);\n                <span class=\"hljs-comment\">// if the neighbor is already created and has minimum</span>\n                <span class=\"hljs-comment\">// g_score, then update g_score and f_score else insert new</span>\n                <span class=\"hljs-keyword\">if</span> (neighbor_g_score_iter != g_score.<span class=\"hljs-built_in\">end</span>()) {\n                    <span class=\"hljs-keyword\">if</span> (neighbor_g_score_iter-&gt;second &gt; temp_g_score) {\n                        neighbor_g_score_iter-&gt;second = temp_g_score;\n                        parent_of[Neighbor] = current_state;\n                    }\n                } <span class=\"hljs-keyword\">else</span> {\n                    g_score[Neighbor] = temp_g_score;\n                    parent_of[Neighbor] = current_state;\n                }\n                <span class=\"hljs-comment\">// If this is a new state, insert into open_list</span>\n                <span class=\"hljs-comment\">// else update if the this state has better g score than</span>\n                <span class=\"hljs-comment\">// existing one.</span>\n                <span class=\"hljs-keyword\">auto</span> iter = open_list.<span class=\"hljs-built_in\">find</span>(Neighbor);\n                <span class=\"hljs-keyword\">if</span> (iter == open_list.<span class=\"hljs-built_in\">end</span>()) {\n                    open_list.<span class=\"hljs-built_in\">emplace</span>(Neighbor);\n                } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (iter-&gt;depth &gt; Neighbor.depth) {\n                    open_list.<span class=\"hljs-built_in\">erase</span>(iter);\n                    open_list.<span class=\"hljs-built_in\">emplace</span>(Neighbor);\n                }\n            }\n            closed_list.<span class=\"hljs-built_in\">emplace</span>(*current_state);\n        }\n        <span class=\"hljs-comment\">// Cannot find the solution, return empty vector</span>\n        <span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">vector</span>&lt;Puzzle&gt;(<span class=\"hljs-number\">0</span>);\n    }\n};\n}  <span class=\"hljs-comment\">// namespace aystar_search</span>\n}  <span class=\"hljs-comment\">// namespace machine_learning</span>\n\n<span class=\"hljs-comment\">/**\n * @brief Self test-implementations\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// Renaming for simplicity</span>\n    <span class=\"hljs-keyword\">using</span> matrix3 = std::array&lt;std::array&lt;<span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-number\">3</span>&gt;, <span class=\"hljs-number\">3</span>&gt;;\n    <span class=\"hljs-keyword\">using</span> row3 = std::array&lt;<span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-number\">3</span>&gt;;\n    <span class=\"hljs-keyword\">using</span> matrix4 = std::array&lt;std::array&lt;<span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-number\">4</span>&gt;, <span class=\"hljs-number\">4</span>&gt;;\n    <span class=\"hljs-keyword\">using</span> row4 = std::array&lt;<span class=\"hljs-type\">uint32_t</span>, <span class=\"hljs-number\">4</span>&gt;;\n    <span class=\"hljs-comment\">// 1st test: A* search for simple EightPuzzle problem</span>\n    matrix3 puzzle;\n    puzzle[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>});\n    puzzle[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>});\n    puzzle[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>});\n\n    matrix3 ideal;\n    ideal[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>});\n    ideal[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>});\n    ideal[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">0</span>});\n\n    <span class=\"hljs-comment\">/*\n     * Heuristic function: Manhattan distance\n     */</span>\n    <span class=\"hljs-keyword\">auto</span> manhattan_distance =\n        [](<span class=\"hljs-keyword\">const</span> machine_learning::aystar_search::EightPuzzle&lt;&gt; &amp;first,\n           <span class=\"hljs-keyword\">const</span> machine_learning::aystar_search::EightPuzzle&lt;&gt; &amp;second) {\n            <span class=\"hljs-type\">uint32_t</span> ret = <span class=\"hljs-number\">0</span>;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; first.<span class=\"hljs-built_in\">get_size</span>(); ++i) {\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; first.<span class=\"hljs-built_in\">get_size</span>(); ++j) {\n                    <span class=\"hljs-type\">uint32_t</span> find = first.<span class=\"hljs-built_in\">get</span>(i, j);\n                    <span class=\"hljs-type\">int</span> m = <span class=\"hljs-number\">-1</span>, n = <span class=\"hljs-number\">-1</span>;\n                    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; second.<span class=\"hljs-built_in\">get_size</span>(); ++k) {\n                        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> l = <span class=\"hljs-number\">0</span>; l &lt; second.<span class=\"hljs-built_in\">get_size</span>(); ++l) {\n                            <span class=\"hljs-keyword\">if</span> (find == second.<span class=\"hljs-built_in\">get</span>(k, l)) {\n                                std::<span class=\"hljs-built_in\">tie</span>(m, n) = std::<span class=\"hljs-built_in\">make_pair</span>(k, l);\n                                <span class=\"hljs-keyword\">break</span>;\n                            }\n                        }\n                        <span class=\"hljs-keyword\">if</span> (m != <span class=\"hljs-number\">-1</span>) {\n                            <span class=\"hljs-keyword\">break</span>;\n                        }\n                    }\n                    <span class=\"hljs-keyword\">if</span> (m != <span class=\"hljs-number\">-1</span>) {\n                        ret += <span class=\"hljs-built_in\">abs</span>(m - i) + <span class=\"hljs-built_in\">abs</span>(n - j);\n                    }\n                }\n            }\n            <span class=\"hljs-keyword\">return</span> ret;\n        };\n\n    machine_learning::aystar_search::EightPuzzle&lt;&gt; <span class=\"hljs-built_in\">Puzzle</span>(puzzle);\n    machine_learning::aystar_search::EightPuzzle&lt;&gt; <span class=\"hljs-built_in\">Ideal</span>(ideal);\n    machine_learning::aystar_search::AyStarSearch&lt;\n        machine_learning::aystar_search::EightPuzzle&lt;<span class=\"hljs-number\">3</span>&gt;&gt;\n        <span class=\"hljs-built_in\">search</span>(Puzzle, Ideal);  <span class=\"hljs-comment\">/// Search object</span>\n\n    std::vector&lt;matrix3&gt; answer;  <span class=\"hljs-comment\">/// Array that validates the answer</span>\n\n    answer.<span class=\"hljs-built_in\">push_back</span>(\n        <span class=\"hljs-built_in\">matrix3</span>({<span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}), <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>}), <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>})}));\n    answer.<span class=\"hljs-built_in\">push_back</span>(\n        <span class=\"hljs-built_in\">matrix3</span>({<span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}), <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>}), <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>})}));\n    answer.<span class=\"hljs-built_in\">push_back</span>(\n        <span class=\"hljs-built_in\">matrix3</span>({<span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}), <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>}), <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>})}));\n    answer.<span class=\"hljs-built_in\">push_back</span>(\n        <span class=\"hljs-built_in\">matrix3</span>({<span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}), <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>}), <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">8</span>})}));\n    answer.<span class=\"hljs-built_in\">push_back</span>(\n        <span class=\"hljs-built_in\">matrix3</span>({<span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}), <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>}), <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">0</span>})}));\n\n    <span class=\"hljs-keyword\">auto</span> Solution = search.<span class=\"hljs-built_in\">a_star_search</span>(manhattan_distance);\n    std::cout &lt;&lt; Solution.<span class=\"hljs-built_in\">size</span>() &lt;&lt; std::endl;\n\n    <span class=\"hljs-built_in\">assert</span>(Solution.<span class=\"hljs-built_in\">size</span>() == answer.<span class=\"hljs-built_in\">size</span>());\n\n    <span class=\"hljs-type\">uint32_t</span> i = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it = Solution.<span class=\"hljs-built_in\">rbegin</span>(); it != Solution.<span class=\"hljs-built_in\">rend</span>(); ++it) {\n        <span class=\"hljs-built_in\">assert</span>(it-&gt;<span class=\"hljs-built_in\">get_state</span>() == answer[i]);\n        ++i;\n    }\n\n    <span class=\"hljs-comment\">// 2nd test: A* search for complicated EightPuzzle problem</span>\n    <span class=\"hljs-comment\">// Initial state</span>\n    puzzle[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">3</span>});\n    puzzle[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">6</span>});\n    puzzle[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">8</span>});\n    <span class=\"hljs-comment\">// Final state</span>\n    ideal[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>});\n    ideal[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>});\n    ideal[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-built_in\">row3</span>({<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">0</span>});\n\n    Puzzle = machine_learning::aystar_search::EightPuzzle&lt;&gt;(puzzle);\n    Ideal = machine_learning::aystar_search::EightPuzzle&lt;&gt;(ideal);\n\n    <span class=\"hljs-comment\">// Initialize the search object</span>\n    search = machine_learning::aystar_search::AyStarSearch&lt;\n        machine_learning::aystar_search::EightPuzzle&lt;<span class=\"hljs-number\">3</span>&gt;&gt;(Puzzle, Ideal);\n\n    Solution = search.<span class=\"hljs-built_in\">a_star_search</span>(manhattan_distance);\n    std::cout &lt;&lt; Solution.<span class=\"hljs-built_in\">size</span>() &lt;&lt; std::endl;\n    <span class=\"hljs-comment\">// Static assertion due to large solution</span>\n    <span class=\"hljs-built_in\">assert</span>(<span class=\"hljs-number\">13</span> == Solution.<span class=\"hljs-built_in\">size</span>());\n    <span class=\"hljs-comment\">// Check whether the final state is equal to expected one</span>\n    <span class=\"hljs-built_in\">assert</span>(Solution[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">get_state</span>() == ideal);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it = Solution.<span class=\"hljs-built_in\">rbegin</span>(); it != Solution.<span class=\"hljs-built_in\">rend</span>(); ++it) {\n        std::cout &lt;&lt; *it &lt;&lt; std::endl;\n    }\n\n    <span class=\"hljs-comment\">// 3rd test: A* search for 15-Puzzle</span>\n    <span class=\"hljs-comment\">// Initial State of the puzzle</span>\n    matrix4 puzzle2;\n    puzzle2[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-built_in\">row4</span>({<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>});\n    puzzle2[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-built_in\">row4</span>({<span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">4</span>});\n    puzzle2[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-built_in\">row4</span>({<span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>});\n    puzzle2[<span class=\"hljs-number\">3</span>] = <span class=\"hljs-built_in\">row4</span>({<span class=\"hljs-number\">14</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">0</span>});\n    <span class=\"hljs-comment\">// Final state of the puzzle</span>\n    matrix4 ideal2;\n    ideal2[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-built_in\">row4</span>({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>});\n    ideal2[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-built_in\">row4</span>({<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>});\n    ideal2[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-built_in\">row4</span>({<span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">12</span>});\n    ideal2[<span class=\"hljs-number\">3</span>] = <span class=\"hljs-built_in\">row4</span>({<span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">14</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">0</span>});\n\n    <span class=\"hljs-comment\">// Instantiate states for a*, initial state and final states</span>\n    machine_learning::<span class=\"hljs-function\">aystar_search::EightPuzzle&lt;4&gt; <span class=\"hljs-title\">Puzzle2</span><span class=\"hljs-params\">(puzzle2)</span>,\n        <span class=\"hljs-title\">Ideal2</span><span class=\"hljs-params\">(ideal2)</span></span>;\n    <span class=\"hljs-comment\">// Initialize the search object</span>\n    machine_learning::aystar_search::AyStarSearch&lt;\n        machine_learning::aystar_search::EightPuzzle&lt;<span class=\"hljs-number\">4</span>&gt;&gt;\n        <span class=\"hljs-built_in\">search2</span>(Puzzle2, Ideal2);\n    <span class=\"hljs-comment\">/**\n     * Heuristic function: Manhattan distance\n     */</span>\n    <span class=\"hljs-keyword\">auto</span> manhattan_distance2 =\n        [](<span class=\"hljs-keyword\">const</span> machine_learning::aystar_search::EightPuzzle&lt;<span class=\"hljs-number\">4</span>&gt; &amp;first,\n           <span class=\"hljs-keyword\">const</span> machine_learning::aystar_search::EightPuzzle&lt;<span class=\"hljs-number\">4</span>&gt; &amp;second) {\n            <span class=\"hljs-type\">uint32_t</span> ret = <span class=\"hljs-number\">0</span>;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; first.<span class=\"hljs-built_in\">get_size</span>(); ++i) {\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; first.<span class=\"hljs-built_in\">get_size</span>(); ++j) {\n                    <span class=\"hljs-type\">uint32_t</span> find = first.<span class=\"hljs-built_in\">get</span>(i, j);\n                    <span class=\"hljs-type\">int</span> m = <span class=\"hljs-number\">-1</span>, n = <span class=\"hljs-number\">-1</span>;\n                    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; second.<span class=\"hljs-built_in\">get_size</span>(); ++k) {\n                        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> l = <span class=\"hljs-number\">0</span>; l &lt; second.<span class=\"hljs-built_in\">get_size</span>(); ++l) {\n                            <span class=\"hljs-keyword\">if</span> (find == second.<span class=\"hljs-built_in\">get</span>(k, l)) {\n                                std::<span class=\"hljs-built_in\">tie</span>(m, n) = std::<span class=\"hljs-built_in\">make_pair</span>(k, l);\n                                <span class=\"hljs-keyword\">break</span>;\n                            }\n                        }\n                        <span class=\"hljs-keyword\">if</span> (m != <span class=\"hljs-number\">-1</span>) {\n                            <span class=\"hljs-keyword\">break</span>;\n                        }\n                    }\n                    <span class=\"hljs-keyword\">if</span> (m != <span class=\"hljs-number\">-1</span>) {\n                        ret += <span class=\"hljs-built_in\">abs</span>(m - i) + <span class=\"hljs-built_in\">abs</span>(n - j);\n                    }\n                }\n            }\n            <span class=\"hljs-keyword\">return</span> ret;\n        };\n\n    <span class=\"hljs-keyword\">auto</span> sol2 = search2.<span class=\"hljs-built_in\">a_star_search</span>(manhattan_distance2);\n    std::cout &lt;&lt; sol2.<span class=\"hljs-built_in\">size</span>() &lt;&lt; std::endl;\n\n    <span class=\"hljs-comment\">// Static assertion due to large solution</span>\n    <span class=\"hljs-built_in\">assert</span>(<span class=\"hljs-number\">15</span> == sol2.<span class=\"hljs-built_in\">size</span>());\n    <span class=\"hljs-comment\">// Check whether the final state is equal to expected one</span>\n    <span class=\"hljs-built_in\">assert</span>(sol2[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">get_state</span>() == ideal2);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it = sol2.<span class=\"hljs-built_in\">rbegin</span>(); it != sol2.<span class=\"hljs-built_in\">rend</span>(); ++it) {\n        std::cout &lt;&lt; *it &lt;&lt; std::endl;\n    }\n}\n<span class=\"hljs-comment\">/**\n * @brief Main function\n * @returns 0 on exit\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">// run self-test implementations</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "David Leal",
      "email": "halfpacho@gmail.com",
      "commits": 1
    },
    {
      "name": "Ashish Bhanu Daulatabad",
      "email": "supersonic12910@gmail.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}
