{
  "slug": "vector-ops",
  "name": "Vector Ops",
  "categories": ["machinelearning"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "machine_learning/vector_ops.hpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/machine_learning/vector_ops.hpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file vector_ops.hpp\n * @author [Deep Raval](https://github.com/imdeep2905)\n *\n * @brief Various functions for vectors associated with [NeuralNetwork (aka\n * Multilayer Perceptron)]\n * (https://en.wikipedia.org/wiki/Multilayer_perceptron).\n *\n */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> VECTOR_OPS_FOR_NN</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> VECTOR_OPS_FOR_NN</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;chrono&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;random&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;valarray&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\n\n<span class=\"hljs-comment\">/**\n * @namespace machine_learning\n * @brief Machine Learning algorithms\n */</span>\n<span class=\"hljs-keyword\">namespace</span> machine_learning {\n<span class=\"hljs-comment\">/**\n * Overloaded operator &quot;&lt;&lt;&quot; to print 2D vector\n * @tparam T typename of the vector\n * @param out std::ostream to output\n * @param A 2D vector to be printed\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::ostream &amp;<span class=\"hljs-keyword\">operator</span>&lt;&lt;(std::ostream &amp;out,\n                         std::vector&lt;std::valarray&lt;T&gt;&gt; <span class=\"hljs-keyword\">const</span> &amp;A) {\n    <span class=\"hljs-comment\">// Setting output precision to 4 in case of floating point numbers</span>\n    out.<span class=\"hljs-built_in\">precision</span>(<span class=\"hljs-number\">4</span>);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;a : A) {       <span class=\"hljs-comment\">// For each row in A</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;x : a) {   <span class=\"hljs-comment\">// For each element in row</span>\n            std::cout &lt;&lt; x &lt;&lt; <span class=\"hljs-string\">&#x27; &#x27;</span>;  <span class=\"hljs-comment\">// print element</span>\n        }\n        std::cout &lt;&lt; std::endl;\n    }\n    <span class=\"hljs-keyword\">return</span> out;\n}\n\n<span class=\"hljs-comment\">/**\n * Overloaded operator &quot;&lt;&lt;&quot; to print a pair\n * @tparam T typename of the pair\n * @param out std::ostream to output\n * @param A Pair to be printed\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::ostream &amp;<span class=\"hljs-keyword\">operator</span>&lt;&lt;(std::ostream &amp;out, <span class=\"hljs-keyword\">const</span> std::pair&lt;T, T&gt; &amp;A) {\n    <span class=\"hljs-comment\">// Setting output precision to 4 in case of floating point numbers</span>\n    out.<span class=\"hljs-built_in\">precision</span>(<span class=\"hljs-number\">4</span>);\n    <span class=\"hljs-comment\">// printing pair in the form (p, q)</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;(&quot;</span> &lt;&lt; A.first &lt;&lt; <span class=\"hljs-string\">&quot;, &quot;</span> &lt;&lt; A.second &lt;&lt; <span class=\"hljs-string\">&quot;)&quot;</span>;\n    <span class=\"hljs-keyword\">return</span> out;\n}\n\n<span class=\"hljs-comment\">/**\n * Overloaded operator &quot;&lt;&lt;&quot; to print a 1D vector\n * @tparam T typename of the vector\n * @param out std::ostream to output\n * @param A 1D vector to be printed\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::ostream &amp;<span class=\"hljs-keyword\">operator</span>&lt;&lt;(std::ostream &amp;out, <span class=\"hljs-keyword\">const</span> std::valarray&lt;T&gt; &amp;A) {\n    <span class=\"hljs-comment\">// Setting output precision to 4 in case of floating point numbers</span>\n    out.<span class=\"hljs-built_in\">precision</span>(<span class=\"hljs-number\">4</span>);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;a : A) {   <span class=\"hljs-comment\">// For every element in the vector.</span>\n        std::cout &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&#x27; &#x27;</span>;  <span class=\"hljs-comment\">// Print element</span>\n    }\n    std::cout &lt;&lt; std::endl;\n    <span class=\"hljs-keyword\">return</span> out;\n}\n\n<span class=\"hljs-comment\">/**\n * Function to insert element into 1D vector\n * @tparam T typename of the 1D vector and the element\n * @param A 1D vector in which element will to be inserted\n * @param ele element to be inserted\n * @return new resultant vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n<span class=\"hljs-function\">std::valarray&lt;T&gt; <span class=\"hljs-title\">insert_element</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::valarray&lt;T&gt; &amp;A, <span class=\"hljs-keyword\">const</span> T &amp;ele)</span> </span>{\n    std::valarray&lt;T&gt; B;      <span class=\"hljs-comment\">// New 1D vector to store resultant vector</span>\n    B.<span class=\"hljs-built_in\">resize</span>(A.<span class=\"hljs-built_in\">size</span>() + <span class=\"hljs-number\">1</span>);  <span class=\"hljs-comment\">// Resizing it accordingly</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; A.<span class=\"hljs-built_in\">size</span>(); i++) {  <span class=\"hljs-comment\">// For every element in A</span>\n        B[i] = A[i];                         <span class=\"hljs-comment\">// Copy element in B</span>\n    }\n    B[B.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>] = ele;  <span class=\"hljs-comment\">// Inserting new element in last position</span>\n    <span class=\"hljs-keyword\">return</span> B;               <span class=\"hljs-comment\">// Return resultant vector</span>\n}\n\n<span class=\"hljs-comment\">/**\n * Function to remove first element from 1D vector\n * @tparam T typename of the vector\n * @param A 1D vector from which first element will be removed\n * @return new resultant vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n<span class=\"hljs-function\">std::valarray&lt;T&gt; <span class=\"hljs-title\">pop_front</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::valarray&lt;T&gt; &amp;A)</span> </span>{\n    std::valarray&lt;T&gt; B;      <span class=\"hljs-comment\">// New 1D vector to store resultant vector</span>\n    B.<span class=\"hljs-built_in\">resize</span>(A.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>);  <span class=\"hljs-comment\">// Resizing it accordingly</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">1</span>; i &lt; A.<span class=\"hljs-built_in\">size</span>();\n         i++) {           <span class=\"hljs-comment\">// // For every (except first) element in A</span>\n        B[i - <span class=\"hljs-number\">1</span>] = A[i];  <span class=\"hljs-comment\">// Copy element in B with left shifted position</span>\n    }\n    <span class=\"hljs-keyword\">return</span> B;  <span class=\"hljs-comment\">// Return resultant vector</span>\n}\n\n<span class=\"hljs-comment\">/**\n * Function to remove last element from 1D vector\n * @tparam T typename of the vector\n * @param A 1D vector from which last element will be removed\n * @return new resultant vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n<span class=\"hljs-function\">std::valarray&lt;T&gt; <span class=\"hljs-title\">pop_back</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::valarray&lt;T&gt; &amp;A)</span> </span>{\n    std::valarray&lt;T&gt; B;      <span class=\"hljs-comment\">// New 1D vector to store resultant vector</span>\n    B.<span class=\"hljs-built_in\">resize</span>(A.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>);  <span class=\"hljs-comment\">// Resizing it accordingly</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; A.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>;\n         i++) {       <span class=\"hljs-comment\">// For every (except last) element in A</span>\n        B[i] = A[i];  <span class=\"hljs-comment\">// Copy element in B</span>\n    }\n    <span class=\"hljs-keyword\">return</span> B;  <span class=\"hljs-comment\">// Return resultant vector</span>\n}\n\n<span class=\"hljs-comment\">/**\n * Function to equally shuffle two 3D vectors (used for shuffling training data)\n * @tparam T typename of the vector\n * @param A First 3D vector\n * @param B Second 3D vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">equal_shuffle</span><span class=\"hljs-params\">(std::vector&lt;std::vector&lt;std::valarray&lt;T&gt;&gt;&gt; &amp;A,\n                   std::vector&lt;std::vector&lt;std::valarray&lt;T&gt;&gt;&gt; &amp;B)</span> </span>{\n    <span class=\"hljs-comment\">// If two vectors have different sizes</span>\n    <span class=\"hljs-keyword\">if</span> (A.<span class=\"hljs-built_in\">size</span>() != B.<span class=\"hljs-built_in\">size</span>()) {\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;ERROR (&quot;</span> &lt;&lt; __func__ &lt;&lt; <span class=\"hljs-string\">&quot;) : &quot;</span>;\n        std::cerr\n            &lt;&lt; <span class=\"hljs-string\">&quot;Can not equally shuffle two vectors with different sizes: &quot;</span>;\n        std::cerr &lt;&lt; A.<span class=\"hljs-built_in\">size</span>() &lt;&lt; <span class=\"hljs-string\">&quot; and &quot;</span> &lt;&lt; B.<span class=\"hljs-built_in\">size</span>() &lt;&lt; std::endl;\n        std::<span class=\"hljs-built_in\">exit</span>(EXIT_FAILURE);\n    }\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; A.<span class=\"hljs-built_in\">size</span>(); i++) {  <span class=\"hljs-comment\">// For every element in A and B</span>\n        <span class=\"hljs-comment\">// Genrating random index &lt; size of A and B</span>\n        std::<span class=\"hljs-built_in\">srand</span>(std::chrono::system_clock::<span class=\"hljs-built_in\">now</span>().<span class=\"hljs-built_in\">time_since_epoch</span>().<span class=\"hljs-built_in\">count</span>());\n        <span class=\"hljs-type\">size_t</span> random_index = std::<span class=\"hljs-built_in\">rand</span>() % A.<span class=\"hljs-built_in\">size</span>();\n        <span class=\"hljs-comment\">// Swap elements in both A and B with same random index</span>\n        std::<span class=\"hljs-built_in\">swap</span>(A[i], A[random_index]);\n        std::<span class=\"hljs-built_in\">swap</span>(B[i], B[random_index]);\n    }\n    <span class=\"hljs-keyword\">return</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * Function to initialize given 2D vector using uniform random initialization\n * @tparam T typename of the vector\n * @param A 2D vector to be initialized\n * @param shape required shape\n * @param low lower limit on value\n * @param high upper limit on value\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">uniform_random_initialization</span><span class=\"hljs-params\">(std::vector&lt;std::valarray&lt;T&gt;&gt; &amp;A,\n                                   <span class=\"hljs-keyword\">const</span> std::pair&lt;<span class=\"hljs-type\">size_t</span>, <span class=\"hljs-type\">size_t</span>&gt; &amp;shape,\n                                   <span class=\"hljs-keyword\">const</span> T &amp;low, <span class=\"hljs-keyword\">const</span> T &amp;high)</span> </span>{\n    A.<span class=\"hljs-built_in\">clear</span>();  <span class=\"hljs-comment\">// Making A empty</span>\n    <span class=\"hljs-comment\">// Uniform distribution in range [low, high]</span>\n    <span class=\"hljs-function\">std::default_random_engine <span class=\"hljs-title\">generator</span><span class=\"hljs-params\">(\n        std::chrono::system_clock::now().time_since_epoch().count())</span></span>;\n    <span class=\"hljs-function\">std::uniform_real_distribution&lt;T&gt; <span class=\"hljs-title\">distribution</span><span class=\"hljs-params\">(low, high)</span></span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; shape.first; i++) {  <span class=\"hljs-comment\">// For every row</span>\n        std::valarray&lt;T&gt;\n            row;  <span class=\"hljs-comment\">// Making empty row which will be inserted in vector</span>\n        row.<span class=\"hljs-built_in\">resize</span>(shape.second);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;r : row) {             <span class=\"hljs-comment\">// For every element in row</span>\n            r = <span class=\"hljs-built_in\">distribution</span>(generator);  <span class=\"hljs-comment\">// copy random number</span>\n        }\n        A.<span class=\"hljs-built_in\">push_back</span>(row);  <span class=\"hljs-comment\">// Insert new row in vector</span>\n    }\n    <span class=\"hljs-keyword\">return</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * Function to Intialize 2D vector as unit matrix\n * @tparam T typename of the vector\n * @param A 2D vector to be initialized\n * @param shape required shape\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">unit_matrix_initialization</span><span class=\"hljs-params\">(std::vector&lt;std::valarray&lt;T&gt;&gt; &amp;A,\n                                <span class=\"hljs-keyword\">const</span> std::pair&lt;<span class=\"hljs-type\">size_t</span>, <span class=\"hljs-type\">size_t</span>&gt; &amp;shape)</span> </span>{\n    A.<span class=\"hljs-built_in\">clear</span>();  <span class=\"hljs-comment\">// Making A empty</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; shape.first; i++) {\n        std::valarray&lt;T&gt;\n            row;  <span class=\"hljs-comment\">// Making empty row which will be inserted in vector</span>\n        row.<span class=\"hljs-built_in\">resize</span>(shape.second);\n        row[i] = <span class=\"hljs-built_in\">T</span>(<span class=\"hljs-number\">1</span>);     <span class=\"hljs-comment\">// Insert 1 at ith position</span>\n        A.<span class=\"hljs-built_in\">push_back</span>(row);  <span class=\"hljs-comment\">// Insert new row in vector</span>\n    }\n    <span class=\"hljs-keyword\">return</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * Function to Intialize 2D vector as zeroes\n * @tparam T typename of the vector\n * @param A 2D vector to be initialized\n * @param shape required shape\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">zeroes_initialization</span><span class=\"hljs-params\">(std::vector&lt;std::valarray&lt;T&gt;&gt; &amp;A,\n                           <span class=\"hljs-keyword\">const</span> std::pair&lt;<span class=\"hljs-type\">size_t</span>, <span class=\"hljs-type\">size_t</span>&gt; &amp;shape)</span> </span>{\n    A.<span class=\"hljs-built_in\">clear</span>();  <span class=\"hljs-comment\">// Making A empty</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; shape.first; i++) {\n        std::valarray&lt;T&gt;\n            row;  <span class=\"hljs-comment\">// Making empty row which will be inserted in vector</span>\n        row.<span class=\"hljs-built_in\">resize</span>(shape.second);  <span class=\"hljs-comment\">// By default all elements are zero</span>\n        A.<span class=\"hljs-built_in\">push_back</span>(row);          <span class=\"hljs-comment\">// Insert new row in vector</span>\n    }\n    <span class=\"hljs-keyword\">return</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * Function to get sum of all elements in 2D vector\n * @tparam T typename of the vector\n * @param A 2D vector for which sum is required\n * @return returns sum of all elements of 2D vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n<span class=\"hljs-function\">T <span class=\"hljs-title\">sum</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::vector&lt;std::valarray&lt;T&gt;&gt; &amp;A)</span> </span>{\n    T cur_sum = <span class=\"hljs-number\">0</span>;             <span class=\"hljs-comment\">// Initially sum is zero</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;a : A) {  <span class=\"hljs-comment\">// For every row in A</span>\n        cur_sum += a.<span class=\"hljs-built_in\">sum</span>();    <span class=\"hljs-comment\">// Add sum of that row to current sum</span>\n    }\n    <span class=\"hljs-keyword\">return</span> cur_sum;  <span class=\"hljs-comment\">// Return sum</span>\n}\n\n<span class=\"hljs-comment\">/**\n * Function to get shape of given 2D vector\n * @tparam T typename of the vector\n * @param A 2D vector for which shape is required\n * @return shape as pair\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n<span class=\"hljs-function\">std::pair&lt;<span class=\"hljs-type\">size_t</span>, <span class=\"hljs-type\">size_t</span>&gt; <span class=\"hljs-title\">get_shape</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::vector&lt;std::valarray&lt;T&gt;&gt; &amp;A)</span> </span>{\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">size_t</span> sub_size = (*A.<span class=\"hljs-built_in\">begin</span>()).<span class=\"hljs-built_in\">size</span>();\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;a : A) {\n        <span class=\"hljs-comment\">// If supplied vector don&#x27;t have same shape in all rows</span>\n        <span class=\"hljs-keyword\">if</span> (a.<span class=\"hljs-built_in\">size</span>() != sub_size) {\n            std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;ERROR (&quot;</span> &lt;&lt; __func__ &lt;&lt; <span class=\"hljs-string\">&quot;) : &quot;</span>;\n            std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;Supplied vector is not 2D Matrix&quot;</span> &lt;&lt; std::endl;\n            std::<span class=\"hljs-built_in\">exit</span>(EXIT_FAILURE);\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">make_pair</span>(A.<span class=\"hljs-built_in\">size</span>(), sub_size);  <span class=\"hljs-comment\">// Return shape as pair</span>\n}\n\n<span class=\"hljs-comment\">/**\n * Function to scale given 3D vector using min-max scaler\n * @tparam T typename of the vector\n * @param A 3D vector which will be scaled\n * @param low new minimum value\n * @param high new maximum value\n * @return new scaled 3D vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::vector&lt;std::vector&lt;std::valarray&lt;T&gt;&gt;&gt; <span class=\"hljs-built_in\">minmax_scaler</span>(\n    <span class=\"hljs-keyword\">const</span> std::vector&lt;std::vector&lt;std::valarray&lt;T&gt;&gt;&gt; &amp;A, <span class=\"hljs-keyword\">const</span> T &amp;low,\n    <span class=\"hljs-keyword\">const</span> T &amp;high) {\n    std::vector&lt;std::vector&lt;std::valarray&lt;T&gt;&gt;&gt; B =\n        A;                               <span class=\"hljs-comment\">// Copying into new vector B</span>\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> shape = <span class=\"hljs-built_in\">get_shape</span>(B[<span class=\"hljs-number\">0</span>]);  <span class=\"hljs-comment\">// Storing shape of B&#x27;s every element</span>\n    <span class=\"hljs-comment\">// As this function is used for scaling training data vector should be of</span>\n    <span class=\"hljs-comment\">// shape (1, X)</span>\n    <span class=\"hljs-keyword\">if</span> (shape.first != <span class=\"hljs-number\">1</span>) {\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;ERROR (&quot;</span> &lt;&lt; __func__ &lt;&lt; <span class=\"hljs-string\">&quot;) : &quot;</span>;\n        std::cerr\n            &lt;&lt; <span class=\"hljs-string\">&quot;Supplied vector is not supported for minmax scaling, shape: &quot;</span>;\n        std::cerr &lt;&lt; shape &lt;&lt; std::endl;\n        std::<span class=\"hljs-built_in\">exit</span>(EXIT_FAILURE);\n    }\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; shape.second; i++) {\n        T min = B[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>][i], max = B[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>][i];\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; B.<span class=\"hljs-built_in\">size</span>(); j++) {\n            <span class=\"hljs-comment\">// Updating minimum and maximum values</span>\n            min = std::<span class=\"hljs-built_in\">min</span>(min, B[j][<span class=\"hljs-number\">0</span>][i]);\n            max = std::<span class=\"hljs-built_in\">max</span>(max, B[j][<span class=\"hljs-number\">0</span>][i]);\n        }\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; B.<span class=\"hljs-built_in\">size</span>(); j++) {\n            <span class=\"hljs-comment\">// Applying min-max scaler formula</span>\n            B[j][<span class=\"hljs-number\">0</span>][i] =\n                ((B[j][<span class=\"hljs-number\">0</span>][i] - min) / (max - min)) * (high - low) + low;\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> B;  <span class=\"hljs-comment\">// Return new resultant 3D vector</span>\n}\n\n<span class=\"hljs-comment\">/**\n * Function to get index of maximum element in 2D vector\n * @tparam T typename of the vector\n * @param A 2D vector for which maximum index is required\n * @return index of maximum element\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n<span class=\"hljs-function\"><span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">argmax</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::vector&lt;std::valarray&lt;T&gt;&gt; &amp;A)</span> </span>{\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> shape = <span class=\"hljs-built_in\">get_shape</span>(A);\n    <span class=\"hljs-comment\">// As this function is used on predicted (or target) vector, shape should be</span>\n    <span class=\"hljs-comment\">// (1, X)</span>\n    <span class=\"hljs-keyword\">if</span> (shape.first != <span class=\"hljs-number\">1</span>) {\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;ERROR (&quot;</span> &lt;&lt; __func__ &lt;&lt; <span class=\"hljs-string\">&quot;) : &quot;</span>;\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;Supplied vector is ineligible for argmax&quot;</span> &lt;&lt; std::endl;\n        std::<span class=\"hljs-built_in\">exit</span>(EXIT_FAILURE);\n    }\n    <span class=\"hljs-comment\">// Return distance of max element from first element (i.e. index)</span>\n    <span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">distance</span>(std::<span class=\"hljs-built_in\">begin</span>(A[<span class=\"hljs-number\">0</span>]),\n                         std::<span class=\"hljs-built_in\">max_element</span>(std::<span class=\"hljs-built_in\">begin</span>(A[<span class=\"hljs-number\">0</span>]), std::<span class=\"hljs-built_in\">end</span>(A[<span class=\"hljs-number\">0</span>])));\n}\n\n<span class=\"hljs-comment\">/**\n * Function which applys supplied function to every element of 2D vector\n * @tparam T typename of the vector\n * @param A 2D vector on which function will be applied\n * @param func Function to be applied\n * @return new resultant vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::vector&lt;std::valarray&lt;T&gt;&gt; <span class=\"hljs-built_in\">apply_function</span>(\n    <span class=\"hljs-keyword\">const</span> std::vector&lt;std::valarray&lt;T&gt;&gt; &amp;A, <span class=\"hljs-built_in\">T</span> (*func)(<span class=\"hljs-keyword\">const</span> T &amp;)) {\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; B =\n        A;                  <span class=\"hljs-comment\">// New vector to store resultant vector</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;b : B) {     <span class=\"hljs-comment\">// For every row in vector</span>\n        b = b.<span class=\"hljs-built_in\">apply</span>(func);  <span class=\"hljs-comment\">// Apply function to that row</span>\n    }\n    <span class=\"hljs-keyword\">return</span> B;  <span class=\"hljs-comment\">// Return new resultant 2D vector</span>\n}\n\n<span class=\"hljs-comment\">/**\n * Overloaded operator &quot;*&quot; to multiply given 2D vector with scaler\n * @tparam T typename of both vector and the scaler\n * @param A 2D vector to which scaler will be multiplied\n * @param val Scaler value which will be multiplied\n * @return new resultant vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::vector&lt;std::valarray&lt;T&gt;&gt; <span class=\"hljs-keyword\">operator</span>*(<span class=\"hljs-keyword\">const</span> std::vector&lt;std::valarray&lt;T&gt;&gt; &amp;A,\n                                        <span class=\"hljs-keyword\">const</span> T &amp;val) {\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; B =\n        A;               <span class=\"hljs-comment\">// New vector to store resultant vector</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;b : B) {  <span class=\"hljs-comment\">// For every row in vector</span>\n        b = b * val;     <span class=\"hljs-comment\">// Multiply row with scaler</span>\n    }\n    <span class=\"hljs-keyword\">return</span> B;  <span class=\"hljs-comment\">// Return new resultant 2D vector</span>\n}\n\n<span class=\"hljs-comment\">/**\n * Overloaded operator &quot;/&quot; to divide given 2D vector with scaler\n * @tparam T typename of the vector and the scaler\n * @param A 2D vector to which scaler will be divided\n * @param val Scaler value which will be divided\n * @return new resultant vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::vector&lt;std::valarray&lt;T&gt;&gt; <span class=\"hljs-keyword\">operator</span>/(<span class=\"hljs-keyword\">const</span> std::vector&lt;std::valarray&lt;T&gt;&gt; &amp;A,\n                                        <span class=\"hljs-keyword\">const</span> T &amp;val) {\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; B =\n        A;               <span class=\"hljs-comment\">// New vector to store resultant vector</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;b : B) {  <span class=\"hljs-comment\">// For every row in vector</span>\n        b = b / val;     <span class=\"hljs-comment\">// Divide row with scaler</span>\n    }\n    <span class=\"hljs-keyword\">return</span> B;  <span class=\"hljs-comment\">// Return new resultant 2D vector</span>\n}\n\n<span class=\"hljs-comment\">/**\n * Function to get transpose of 2D vector\n * @tparam T typename of the vector\n * @param A 2D vector which will be transposed\n * @return new resultant vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::vector&lt;std::valarray&lt;T&gt;&gt; <span class=\"hljs-built_in\">transpose</span>(\n    <span class=\"hljs-keyword\">const</span> std::vector&lt;std::valarray&lt;T&gt;&gt; &amp;A) {\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> shape = <span class=\"hljs-built_in\">get_shape</span>(A);  <span class=\"hljs-comment\">// Current shape of vector</span>\n    std::vector&lt;std::valarray&lt;T&gt;&gt; B;  <span class=\"hljs-comment\">// New vector to store result</span>\n    <span class=\"hljs-comment\">// Storing transpose values of A in B</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; shape.second; j++) {\n        std::valarray&lt;T&gt; row;\n        row.<span class=\"hljs-built_in\">resize</span>(shape.first);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; shape.first; i++) {\n            row[i] = A[i][j];\n        }\n        B.<span class=\"hljs-built_in\">push_back</span>(row);\n    }\n    <span class=\"hljs-keyword\">return</span> B;  <span class=\"hljs-comment\">// Return new resultant 2D vector</span>\n}\n\n<span class=\"hljs-comment\">/**\n * Overloaded operator &quot;+&quot; to add two 2D vectors\n * @tparam T typename of the vector\n * @param A First 2D vector\n * @param B Second 2D vector\n * @return new resultant vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::vector&lt;std::valarray&lt;T&gt;&gt; <span class=\"hljs-keyword\">operator</span>+(\n    <span class=\"hljs-keyword\">const</span> std::vector&lt;std::valarray&lt;T&gt;&gt; &amp;A,\n    <span class=\"hljs-keyword\">const</span> std::vector&lt;std::valarray&lt;T&gt;&gt; &amp;B) {\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> shape_a = <span class=\"hljs-built_in\">get_shape</span>(A);\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> shape_b = <span class=\"hljs-built_in\">get_shape</span>(B);\n    <span class=\"hljs-comment\">// If vectors don&#x27;t have equal shape</span>\n    <span class=\"hljs-keyword\">if</span> (shape_a.first != shape_b.first || shape_a.second != shape_b.second) {\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;ERROR (&quot;</span> &lt;&lt; __func__ &lt;&lt; <span class=\"hljs-string\">&quot;) : &quot;</span>;\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;Supplied vectors have different shapes &quot;</span>;\n        std::cerr &lt;&lt; shape_a &lt;&lt; <span class=\"hljs-string\">&quot; and &quot;</span> &lt;&lt; shape_b &lt;&lt; std::endl;\n        std::<span class=\"hljs-built_in\">exit</span>(EXIT_FAILURE);\n    }\n    std::vector&lt;std::valarray&lt;T&gt;&gt; C;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; A.<span class=\"hljs-built_in\">size</span>(); i++) {  <span class=\"hljs-comment\">// For every row</span>\n        C.<span class=\"hljs-built_in\">push_back</span>(A[i] + B[i]);            <span class=\"hljs-comment\">// Elementwise addition</span>\n    }\n    <span class=\"hljs-keyword\">return</span> C;  <span class=\"hljs-comment\">// Return new resultant 2D vector</span>\n}\n\n<span class=\"hljs-comment\">/**\n * Overloaded operator &quot;-&quot; to add subtract 2D vectors\n * @tparam T typename of the vector\n * @param A First 2D vector\n * @param B Second 2D vector\n * @return new resultant vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::vector&lt;std::valarray&lt;T&gt;&gt; <span class=\"hljs-keyword\">operator</span>-(\n    <span class=\"hljs-keyword\">const</span> std::vector&lt;std::valarray&lt;T&gt;&gt; &amp;A,\n    <span class=\"hljs-keyword\">const</span> std::vector&lt;std::valarray&lt;T&gt;&gt; &amp;B) {\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> shape_a = <span class=\"hljs-built_in\">get_shape</span>(A);\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> shape_b = <span class=\"hljs-built_in\">get_shape</span>(B);\n    <span class=\"hljs-comment\">// If vectors don&#x27;t have equal shape</span>\n    <span class=\"hljs-keyword\">if</span> (shape_a.first != shape_b.first || shape_a.second != shape_b.second) {\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;ERROR (&quot;</span> &lt;&lt; __func__ &lt;&lt; <span class=\"hljs-string\">&quot;) : &quot;</span>;\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;Supplied vectors have different shapes &quot;</span>;\n        std::cerr &lt;&lt; shape_a &lt;&lt; <span class=\"hljs-string\">&quot; and &quot;</span> &lt;&lt; shape_b &lt;&lt; std::endl;\n        std::<span class=\"hljs-built_in\">exit</span>(EXIT_FAILURE);\n    }\n    std::vector&lt;std::valarray&lt;T&gt;&gt; C;         <span class=\"hljs-comment\">// Vector to store result</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; A.<span class=\"hljs-built_in\">size</span>(); i++) {  <span class=\"hljs-comment\">// For every row</span>\n        C.<span class=\"hljs-built_in\">push_back</span>(A[i] - B[i]);            <span class=\"hljs-comment\">// Elementwise substraction</span>\n    }\n    <span class=\"hljs-keyword\">return</span> C;  <span class=\"hljs-comment\">// Return new resultant 2D vector</span>\n}\n\n<span class=\"hljs-comment\">/**\n * Function to multiply two 2D vectors\n * @tparam T typename of the vector\n * @param A First 2D vector\n * @param B Second 2D vector\n * @return new resultant vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::vector&lt;std::valarray&lt;T&gt;&gt; <span class=\"hljs-built_in\">multiply</span>(<span class=\"hljs-keyword\">const</span> std::vector&lt;std::valarray&lt;T&gt;&gt; &amp;A,\n                                       <span class=\"hljs-keyword\">const</span> std::vector&lt;std::valarray&lt;T&gt;&gt; &amp;B) {\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> shape_a = <span class=\"hljs-built_in\">get_shape</span>(A);\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> shape_b = <span class=\"hljs-built_in\">get_shape</span>(B);\n    <span class=\"hljs-comment\">// If vectors are not eligible for multiplication</span>\n    <span class=\"hljs-keyword\">if</span> (shape_a.second != shape_b.first) {\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;ERROR (&quot;</span> &lt;&lt; __func__ &lt;&lt; <span class=\"hljs-string\">&quot;) : &quot;</span>;\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;Vectors are not eligible for multiplication &quot;</span>;\n        std::cerr &lt;&lt; shape_a &lt;&lt; <span class=\"hljs-string\">&quot; and &quot;</span> &lt;&lt; shape_b &lt;&lt; std::endl;\n        std::<span class=\"hljs-built_in\">exit</span>(EXIT_FAILURE);\n    }\n    std::vector&lt;std::valarray&lt;T&gt;&gt; C;  <span class=\"hljs-comment\">// Vector to store result</span>\n    <span class=\"hljs-comment\">// Normal matrix multiplication</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; shape_a.first; i++) {\n        std::valarray&lt;T&gt; row;\n        row.<span class=\"hljs-built_in\">resize</span>(shape_b.second);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; shape_b.second; j++) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> k = <span class=\"hljs-number\">0</span>; k &lt; shape_a.second; k++) {\n                row[j] += A[i][k] * B[k][j];\n            }\n        }\n        C.<span class=\"hljs-built_in\">push_back</span>(row);\n    }\n    <span class=\"hljs-keyword\">return</span> C;  <span class=\"hljs-comment\">// Return new resultant 2D vector</span>\n}\n\n<span class=\"hljs-comment\">/**\n * Function to get hadamard product of two 2D vectors\n * @tparam T typename of the vector\n * @param A First 2D vector\n * @param B Second 2D vector\n * @return new resultant vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::vector&lt;std::valarray&lt;T&gt;&gt; <span class=\"hljs-built_in\">hadamard_product</span>(\n    <span class=\"hljs-keyword\">const</span> std::vector&lt;std::valarray&lt;T&gt;&gt; &amp;A,\n    <span class=\"hljs-keyword\">const</span> std::vector&lt;std::valarray&lt;T&gt;&gt; &amp;B) {\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> shape_a = <span class=\"hljs-built_in\">get_shape</span>(A);\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> shape_b = <span class=\"hljs-built_in\">get_shape</span>(B);\n    <span class=\"hljs-comment\">// If vectors are not eligible for hadamard product</span>\n    <span class=\"hljs-keyword\">if</span> (shape_a.first != shape_b.first || shape_a.second != shape_b.second) {\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;ERROR (&quot;</span> &lt;&lt; __func__ &lt;&lt; <span class=\"hljs-string\">&quot;) : &quot;</span>;\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;Vectors have different shapes &quot;</span>;\n        std::cerr &lt;&lt; shape_a &lt;&lt; <span class=\"hljs-string\">&quot; and &quot;</span> &lt;&lt; shape_b &lt;&lt; std::endl;\n        std::<span class=\"hljs-built_in\">exit</span>(EXIT_FAILURE);\n    }\n    std::vector&lt;std::valarray&lt;T&gt;&gt; C;  <span class=\"hljs-comment\">// Vector to store result</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; A.<span class=\"hljs-built_in\">size</span>(); i++) {\n        C.<span class=\"hljs-built_in\">push_back</span>(A[i] * B[i]);  <span class=\"hljs-comment\">// Elementwise multiplication</span>\n    }\n    <span class=\"hljs-keyword\">return</span> C;  <span class=\"hljs-comment\">// Return new resultant 2D vector</span>\n}\n}  <span class=\"hljs-comment\">// namespace machine_learning</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n"
    }
  },
  "contributors": [
    {
      "name": "Deep Raval",
      "email": "deepraval2905@gmail.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}
