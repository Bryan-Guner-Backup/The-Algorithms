{
  "slug": "k-means-clustering",
  "name": "K Means Clustering",
  "categories": ["machinelearning"],
  "body": {},
  "implementations": {
    "c": {
      "dir": "machine_learning/k_means_clustering.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/machine_learning/k_means_clustering.c",
      "code": "<span class=\"hljs-comment\">/**\n * @file k_means_clustering.c\n * @brief K Means Clustering Algorithm implemented\n * @details\n * This file has K Means algorithm implemmented\n * It prints test output in eps format\n *\n * Note:\n * Though the code for clustering works for all the\n * 2D data points and can be extended for any size vector\n * by making the required changes, but note that\n * the output method i.e. printEPS is only good for\n * polar data points i.e. in a circle and both test\n * use the same.\n * @author [Lakhan Nad](https://github.com/Lakhan-Nad)\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> _USE_MATH_DEFINES <span class=\"hljs-comment\">/* required for MS Visual C */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;float.h&gt;</span>        <span class=\"hljs-comment\">/* DBL_MAX, DBL_MIN */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;math.h&gt;</span>         <span class=\"hljs-comment\">/* PI, sin, cos */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span>        <span class=\"hljs-comment\">/* printf */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span>       <span class=\"hljs-comment\">/* rand */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string.h&gt;</span>       <span class=\"hljs-comment\">/* memset */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;time.h&gt;</span>         <span class=\"hljs-comment\">/* time */</span></span>\n\n<span class=\"hljs-comment\">/*!\n * @addtogroup machine_learning Machine Learning Algorithms\n * @{\n * @addtogroup k_means K-Means Clustering Algorithm\n * @{\n */</span>\n\n<span class=\"hljs-comment\">/*! @struct observation\n *  a class to store points in 2d plane\n *  the name observation is used to denote\n *  a random point in plane\n */</span>\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">observation</span>\n{</span>\n    <span class=\"hljs-type\">double</span> x;  <span class=\"hljs-comment\">/**&lt; abscissa of 2D data point */</span>\n    <span class=\"hljs-type\">double</span> y;  <span class=\"hljs-comment\">/**&lt; ordinate of 2D data point */</span>\n    <span class=\"hljs-type\">int</span> group; <span class=\"hljs-comment\">/**&lt; the group no in which this observation would go */</span>\n} observation;\n\n<span class=\"hljs-comment\">/*! @struct cluster\n *  this class stores the coordinates\n *  of centroid of all the points\n *  in that cluster it also\n *  stores the count of observations\n *  belonging to this cluster\n */</span>\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">cluster</span>\n{</span>\n    <span class=\"hljs-type\">double</span> x;     <span class=\"hljs-comment\">/**&lt; abscissa centroid of this cluster */</span>\n    <span class=\"hljs-type\">double</span> y;     <span class=\"hljs-comment\">/**&lt; ordinate of centroid of this cluster */</span>\n    <span class=\"hljs-type\">size_t</span> count; <span class=\"hljs-comment\">/**&lt; count of observations present in this cluster */</span>\n} cluster;\n\n<span class=\"hljs-comment\">/*!\n * Returns the index of centroid nearest to\n * given observation\n *\n * @param o  observation\n * @param clusters  array of cluster having centroids coordinates\n * @param k  size of clusters array\n *\n * @returns the index of nearest centroid for given observation\n */</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">calculateNearst</span><span class=\"hljs-params\">(observation* o, cluster clusters[], <span class=\"hljs-type\">int</span> k)</span>\n{\n    <span class=\"hljs-type\">double</span> minD = DBL_MAX;\n    <span class=\"hljs-type\">double</span> dist = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">int</span> index = <span class=\"hljs-number\">-1</span>;\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">for</span> (; i &lt; k; i++)\n    {\n        <span class=\"hljs-comment\">/* Calculate Squared Distance*/</span>\n        dist = (clusters[i].x - o-&gt;x) * (clusters[i].x - o-&gt;x) +\n               (clusters[i].y - o-&gt;y) * (clusters[i].y - o-&gt;y);\n        <span class=\"hljs-keyword\">if</span> (dist &lt; minD)\n        {\n            minD = dist;\n            index = i;\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> index;\n}\n\n<span class=\"hljs-comment\">/*!\n * Calculate centoid and assign it to the cluster variable\n *\n * @param observations  an array of observations whose centroid is calculated\n * @param size  size of the observations array\n * @param centroid  a reference to cluster object to store information of\n * centroid\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">calculateCentroid</span><span class=\"hljs-params\">(observation observations[], <span class=\"hljs-type\">size_t</span> size,\n                       cluster* centroid)</span>\n{\n    <span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>;\n    centroid-&gt;x = <span class=\"hljs-number\">0</span>;\n    centroid-&gt;y = <span class=\"hljs-number\">0</span>;\n    centroid-&gt;count = size;\n    <span class=\"hljs-keyword\">for</span> (; i &lt; size; i++)\n    {\n        centroid-&gt;x += observations[i].x;\n        centroid-&gt;y += observations[i].y;\n        observations[i].group = <span class=\"hljs-number\">0</span>;\n    }\n    centroid-&gt;x /= centroid-&gt;count;\n    centroid-&gt;y /= centroid-&gt;count;\n}\n\n<span class=\"hljs-comment\">/*!\n *    --K Means Algorithm--\n * 1. Assign each observation to one of k groups\n *    creating a random initial clustering\n * 2. Find the centroid of observations for each\n *    cluster to form new centroids\n * 3. Find the centroid which is nearest for each\n *    observation among the calculated centroids\n * 4. Assign the observation to its nearest centroid\n *    to create a new clustering.\n * 5. Repeat step 2,3,4 until there is no change\n *    the current clustering and is same as last\n *    clustering.\n *\n * @param observations  an array of observations to cluster\n * @param size  size of observations array\n * @param k  no of clusters to be made\n *\n * @returns pointer to cluster object\n */</span>\ncluster* <span class=\"hljs-title function_\">kMeans</span><span class=\"hljs-params\">(observation observations[], <span class=\"hljs-type\">size_t</span> size, <span class=\"hljs-type\">int</span> k)</span>\n{\n    cluster* clusters = <span class=\"hljs-literal\">NULL</span>;\n    <span class=\"hljs-keyword\">if</span> (k &lt;= <span class=\"hljs-number\">1</span>)\n    {\n        <span class=\"hljs-comment\">/*\n        If we have to cluster them only in one group\n        then calculate centroid of observations and\n        that will be a ingle cluster\n        */</span>\n        clusters = (cluster*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(cluster));\n        <span class=\"hljs-built_in\">memset</span>(clusters, <span class=\"hljs-number\">0</span>, <span class=\"hljs-keyword\">sizeof</span>(cluster));\n        calculateCentroid(observations, size, clusters);\n    }\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (k &lt; size)\n    {\n        clusters = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(cluster) * k);\n        <span class=\"hljs-built_in\">memset</span>(clusters, <span class=\"hljs-number\">0</span>, k * <span class=\"hljs-keyword\">sizeof</span>(cluster));\n        <span class=\"hljs-comment\">/* STEP 1 */</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; size; j++)\n        {\n            observations[j].group = rand() % k;\n        }\n        <span class=\"hljs-type\">size_t</span> changed = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-type\">size_t</span> minAcceptedError =\n            size /\n            <span class=\"hljs-number\">10000</span>;  <span class=\"hljs-comment\">// Do until 99.99 percent points are in correct cluster</span>\n        <span class=\"hljs-type\">int</span> t = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-keyword\">do</span>\n        {\n            <span class=\"hljs-comment\">/* Initialize clusters */</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; k; i++)\n            {\n                clusters[i].x = <span class=\"hljs-number\">0</span>;\n                clusters[i].y = <span class=\"hljs-number\">0</span>;\n                clusters[i].count = <span class=\"hljs-number\">0</span>;\n            }\n            <span class=\"hljs-comment\">/* STEP 2*/</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; size; j++)\n            {\n                t = observations[j].group;\n                clusters[t].x += observations[j].x;\n                clusters[t].y += observations[j].y;\n                clusters[t].count++;\n            }\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; k; i++)\n            {\n                clusters[i].x /= clusters[i].count;\n                clusters[i].y /= clusters[i].count;\n            }\n            <span class=\"hljs-comment\">/* STEP 3 and 4 */</span>\n            changed = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// this variable stores change in clustering</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; size; j++)\n            {\n                t = calculateNearst(observations + j, clusters, k);\n                <span class=\"hljs-keyword\">if</span> (t != observations[j].group)\n                {\n                    changed++;\n                    observations[j].group = t;\n                }\n            }\n        } <span class=\"hljs-keyword\">while</span> (changed &gt; minAcceptedError);  <span class=\"hljs-comment\">// Keep on grouping until we have</span>\n                                               <span class=\"hljs-comment\">// got almost best clustering</span>\n    }\n    <span class=\"hljs-keyword\">else</span>\n    {\n        <span class=\"hljs-comment\">/* If no of clusters is more than observations\n           each observation can be its own cluster\n        */</span>\n        clusters = (cluster*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(cluster) * k);\n        <span class=\"hljs-built_in\">memset</span>(clusters, <span class=\"hljs-number\">0</span>, k * <span class=\"hljs-keyword\">sizeof</span>(cluster));\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; size; j++)\n        {\n            clusters[j].x = observations[j].x;\n            clusters[j].y = observations[j].y;\n            clusters[j].count = <span class=\"hljs-number\">1</span>;\n            observations[j].group = j;\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> clusters;\n}\n\n<span class=\"hljs-comment\">/**\n * @}\n * @}\n */</span>\n\n<span class=\"hljs-comment\">/*!\n * A function to print observations and clusters\n * The code is taken from\n * http://rosettacode.org/wiki/K-means%2B%2B_clustering.\n * Even the K Means code is also inspired from it\n *\n * @note To print in a file use pipeline operator\n * ```sh\n * ./k_means_clustering &gt; image.eps\n * ```\n *\n * @param observations  observations array\n * @param len  size of observation array\n * @param cent  clusters centroid&#x27;s array\n * @param k  size of cent array\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">printEPS</span><span class=\"hljs-params\">(observation pts[], <span class=\"hljs-type\">size_t</span> len, cluster cent[], <span class=\"hljs-type\">int</span> k)</span>\n{\n    <span class=\"hljs-type\">int</span> W = <span class=\"hljs-number\">400</span>, H = <span class=\"hljs-number\">400</span>;\n    <span class=\"hljs-type\">double</span> min_x = DBL_MAX, max_x = DBL_MIN, min_y = DBL_MAX, max_y = DBL_MIN;\n    <span class=\"hljs-type\">double</span> scale = <span class=\"hljs-number\">0</span>, cx = <span class=\"hljs-number\">0</span>, cy = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">double</span>* colors = (<span class=\"hljs-type\">double</span>*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>) * (k * <span class=\"hljs-number\">3</span>));\n    <span class=\"hljs-type\">int</span> i;\n    <span class=\"hljs-type\">size_t</span> j;\n    <span class=\"hljs-type\">double</span> kd = k * <span class=\"hljs-number\">1.0</span>;\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; k; i++)\n    {\n        *(colors + <span class=\"hljs-number\">3</span> * i) = (<span class=\"hljs-number\">3</span> * (i + <span class=\"hljs-number\">1</span>) % k) / kd;\n        *(colors + <span class=\"hljs-number\">3</span> * i + <span class=\"hljs-number\">1</span>) = (<span class=\"hljs-number\">7</span> * i % k) / kd;\n        *(colors + <span class=\"hljs-number\">3</span> * i + <span class=\"hljs-number\">2</span>) = (<span class=\"hljs-number\">9</span> * i % k) / kd;\n    }\n\n    <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; len; j++)\n    {\n        <span class=\"hljs-keyword\">if</span> (max_x &lt; pts[j].x)\n        {\n            max_x = pts[j].x;\n        }\n        <span class=\"hljs-keyword\">if</span> (min_x &gt; pts[j].x)\n        {\n            min_x = pts[j].x;\n        }\n        <span class=\"hljs-keyword\">if</span> (max_y &lt; pts[j].y)\n        {\n            max_y = pts[j].y;\n        }\n        <span class=\"hljs-keyword\">if</span> (min_y &gt; pts[j].y)\n        {\n            min_y = pts[j].y;\n        }\n    }\n    scale = W / (max_x - min_x);\n    <span class=\"hljs-keyword\">if</span> (scale &gt; (H / (max_y - min_y)))\n    {\n        scale = H / (max_y - min_y);\n    };\n    cx = (max_x + min_x) / <span class=\"hljs-number\">2</span>;\n    cy = (max_y + min_y) / <span class=\"hljs-number\">2</span>;\n\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n&quot;</span>, W + <span class=\"hljs-number\">10</span>,\n           H + <span class=\"hljs-number\">10</span>);\n    <span class=\"hljs-built_in\">printf</span>(\n        <span class=\"hljs-string\">&quot;/l {rlineto} def /m {rmoveto} def\\n&quot;</span>\n        <span class=\"hljs-string\">&quot;/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n&quot;</span>\n        <span class=\"hljs-string\">&quot;/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath &quot;</span>\n        <span class=\"hljs-string\">&quot;\tgsave 1 setgray fill grestore gsave 3 setlinewidth&quot;</span>\n        <span class=\"hljs-string\">&quot; 1 setgray stroke grestore 0 setgray stroke }def\\n&quot;</span>);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; k; i++)\n    {\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%g %g %g setrgbcolor\\n&quot;</span>, *(colors + <span class=\"hljs-number\">3</span> * i),\n               *(colors + <span class=\"hljs-number\">3</span> * i + <span class=\"hljs-number\">1</span>), *(colors + <span class=\"hljs-number\">3</span> * i + <span class=\"hljs-number\">2</span>));\n        <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; len; j++)\n        {\n            <span class=\"hljs-keyword\">if</span> (pts[j].group != i)\n            {\n                <span class=\"hljs-keyword\">continue</span>;\n            }\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%.3f %.3f c\\n&quot;</span>, (pts[j].x - cx) * scale + W / <span class=\"hljs-number\">2</span>,\n                   (pts[j].y - cy) * scale + H / <span class=\"hljs-number\">2</span>);\n        }\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\n0 setgray %g %g s\\n&quot;</span>, (cent[i].x - cx) * scale + W / <span class=\"hljs-number\">2</span>,\n               (cent[i].y - cy) * scale + H / <span class=\"hljs-number\">2</span>);\n    }\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\n%%%%EOF&quot;</span>);\n\n    <span class=\"hljs-comment\">// free accquired memory</span>\n    <span class=\"hljs-built_in\">free</span>(colors);\n}\n\n<span class=\"hljs-comment\">/*!\n * A function to test the kMeans function\n * Generates 100000 points in a circle of\n * radius 20.0 with center at (0,0)\n * and cluster them into 5 clusters\n *\n * &lt;img alt=&quot;Output for 100000 points divided in 5 clusters&quot; src=\n * &quot;https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/k_means_clustering/kMeansTest1.png&quot;\n * width=&quot;400px&quot; heiggt=&quot;400px&quot;&gt;\n * @returns None\n */</span>\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">()</span>\n{\n    <span class=\"hljs-type\">size_t</span> size = <span class=\"hljs-number\">100000L</span>;\n    observation* observations =\n        (observation*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(observation) * size);\n    <span class=\"hljs-type\">double</span> maxRadius = <span class=\"hljs-number\">20.00</span>;\n    <span class=\"hljs-type\">double</span> radius = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">double</span> ang = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">for</span> (; i &lt; size; i++)\n    {\n        radius = maxRadius * ((<span class=\"hljs-type\">double</span>)rand() / RAND_MAX);\n        ang = <span class=\"hljs-number\">2</span> * M_PI * ((<span class=\"hljs-type\">double</span>)rand() / RAND_MAX);\n        observations[i].x = radius * <span class=\"hljs-built_in\">cos</span>(ang);\n        observations[i].y = radius * <span class=\"hljs-built_in\">sin</span>(ang);\n    }\n    <span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">5</span>;  <span class=\"hljs-comment\">// No of clusters</span>\n    cluster* clusters = kMeans(observations, size, k);\n    printEPS(observations, size, clusters, k);\n    <span class=\"hljs-comment\">// Free the accquired memory</span>\n    <span class=\"hljs-built_in\">free</span>(observations);\n    <span class=\"hljs-built_in\">free</span>(clusters);\n}\n\n<span class=\"hljs-comment\">/*!\n * A function to test the kMeans function\n * Generates 1000000 points in a circle of\n * radius 20.0 with center at (0,0)\n * and cluster them into 11 clusters\n *\n * &lt;img alt=&quot;Output for 1000000 points divided in 11 clusters&quot; src=\n * &quot;https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/k_means_clustering/kMeansTest2.png&quot;\n * width=&quot;400px&quot; heiggt=&quot;400px&quot;&gt;\n * @returns None\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test2</span><span class=\"hljs-params\">()</span>\n{\n    <span class=\"hljs-type\">size_t</span> size = <span class=\"hljs-number\">1000000L</span>;\n    observation* observations =\n        (observation*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(observation) * size);\n    <span class=\"hljs-type\">double</span> maxRadius = <span class=\"hljs-number\">20.00</span>;\n    <span class=\"hljs-type\">double</span> radius = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">double</span> ang = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">for</span> (; i &lt; size; i++)\n    {\n        radius = maxRadius * ((<span class=\"hljs-type\">double</span>)rand() / RAND_MAX);\n        ang = <span class=\"hljs-number\">2</span> * M_PI * ((<span class=\"hljs-type\">double</span>)rand() / RAND_MAX);\n        observations[i].x = radius * <span class=\"hljs-built_in\">cos</span>(ang);\n        observations[i].y = radius * <span class=\"hljs-built_in\">sin</span>(ang);\n    }\n    <span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">11</span>;  <span class=\"hljs-comment\">// No of clusters</span>\n    cluster* clusters = kMeans(observations, size, k);\n    printEPS(observations, size, clusters, k);\n    <span class=\"hljs-comment\">// Free the accquired memory</span>\n    <span class=\"hljs-built_in\">free</span>(observations);\n    <span class=\"hljs-built_in\">free</span>(clusters);\n}\n\n<span class=\"hljs-comment\">/*!\n * This function calls the test\n * function\n */</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span>\n{\n    srand(time(<span class=\"hljs-literal\">NULL</span>));\n    test();\n    <span class=\"hljs-comment\">/* test2(); */</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "r": {
      "dir": "Clustering-Algorithms/kmeans_clustering.R",
      "url": "https://github.com/TheAlgorithms/r/tree/master/Clustering-Algorithms/kmeans_clustering.R",
      "code": "cl <span class=\"hljs-operator\">&lt;-</span> kmeans<span class=\"hljs-punctuation\">(</span>iris<span class=\"hljs-punctuation\">[</span><span class=\"hljs-punctuation\">,</span><span class=\"hljs-operator\">-</span><span class=\"hljs-number\">5</span><span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-number\">3</span><span class=\"hljs-punctuation\">)</span>\nplot<span class=\"hljs-punctuation\">(</span>iris<span class=\"hljs-punctuation\">[</span><span class=\"hljs-punctuation\">,</span><span class=\"hljs-operator\">-</span><span class=\"hljs-number\">5</span><span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span> col <span class=\"hljs-operator\">=</span> cl<span class=\"hljs-operator\">$</span>cluster<span class=\"hljs-punctuation\">)</span>\npoints<span class=\"hljs-punctuation\">(</span>cl<span class=\"hljs-operator\">$</span>centers<span class=\"hljs-punctuation\">,</span> col <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span><span class=\"hljs-operator\">:</span><span class=\"hljs-number\">3</span><span class=\"hljs-punctuation\">,</span> pch <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">8</span><span class=\"hljs-punctuation\">)</span>\n"
    }
  },
  "contributors": [
    {
      "name": "lakhan_nad",
      "email": "lakhannad1999@gmail.com",
      "commits": 1
    },
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}
