{
  "slug": "kohonen-som-trace",
  "name": "Kohonen Som Trace",
  "categories": ["machinelearning"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "machine_learning/kohonen_som_trace.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/machine_learning/kohonen_som_trace.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * \\addtogroup machine_learning Machine Learning Algorithms\n * @{\n * \\file\n * \\brief [Kohonen self organizing\n * map](https://en.wikipedia.org/wiki/Self-organizing_map) (data tracing)\n *\n * This example implements a powerful self organizing map algorithm.\n * The algorithm creates a connected network of weights that closely\n * follows the given data points. This this creates a chain of nodes that\n * resembles the given input shape.\n *\n * \\author [Krishna Vedala](https://github.com/kvedala)\n *\n * \\note This C++ version of the program is considerable slower than its [C\n * counterpart](https://github.com/kvedala/C/blob/master/machine_learning/kohonen_som_trace.c)\n * \\note The compiled code is much slower when compiled with MS Visual C++ 2019\n * than with GCC on windows\n * \\see kohonen_som_topology.cpp\n */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> _USE_MATH_DEFINES  <span class=\"hljs-comment\">// required for MS Visual C++</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;array&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdlib&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ctime&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;fstream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;valarray&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP  <span class=\"hljs-comment\">// check if OpenMP based parallellization is available</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;omp.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n<span class=\"hljs-comment\">/**\n * Helper function to generate a random number in a given interval.\n * \\n Steps:\n * 1. `r1 = rand() % 100` gets a random number between 0 and 99\n * 2. `r2 = r1 / 100` converts random number to be between 0 and 0.99\n * 3. scale and offset the random number to given range of \\f$[a,b]\\f$\n *\n * \\param[in] a lower limit\n * \\param[in] b upper limit\n * \\returns random number in the range \\f$[a,b]\\f$\n */</span>\n<span class=\"hljs-type\">double</span> _random(<span class=\"hljs-type\">double</span> a, <span class=\"hljs-type\">double</span> b) {\n    <span class=\"hljs-keyword\">return</span> ((b - a) * (std::<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span>) / <span class=\"hljs-number\">100.f</span>) + a;\n}\n\n<span class=\"hljs-comment\">/**\n * Save a given n-dimensional data martix to file.\n *\n * \\param[in] fname filename to save in (gets overwriten without confirmation)\n * \\param[in] X matrix to save\n * \\returns 0 if all ok\n * \\returns -1 if file creation failed\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">save_nd_data</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> *fname,\n                 <span class=\"hljs-keyword\">const</span> std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; &amp;X)</span> </span>{\n    <span class=\"hljs-type\">size_t</span> num_points = X.<span class=\"hljs-built_in\">size</span>();       <span class=\"hljs-comment\">// number of rows</span>\n    <span class=\"hljs-type\">size_t</span> num_features = X[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>();  <span class=\"hljs-comment\">// number of columns</span>\n\n    std::ofstream fp;\n    fp.<span class=\"hljs-built_in\">open</span>(fname);\n    <span class=\"hljs-keyword\">if</span> (!fp.<span class=\"hljs-built_in\">is_open</span>()) {\n        <span class=\"hljs-comment\">// error with opening file to write</span>\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;Error opening file &quot;</span> &lt;&lt; fname &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    }\n\n    <span class=\"hljs-comment\">// for each point in the array</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; num_points; i++) {\n        <span class=\"hljs-comment\">// for each feature in the array</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; num_features; j++) {\n            fp &lt;&lt; X[i][j];               <span class=\"hljs-comment\">// print the feature value</span>\n            <span class=\"hljs-keyword\">if</span> (j &lt; num_features - <span class=\"hljs-number\">1</span>) {  <span class=\"hljs-comment\">// if not the last feature</span>\n                fp &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span>;               <span class=\"hljs-comment\">// suffix comma</span>\n            }\n        }\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_points - <span class=\"hljs-number\">1</span>) {  <span class=\"hljs-comment\">// if not the last row</span>\n            fp &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;            <span class=\"hljs-comment\">// start a new line</span>\n        }\n    }\n\n    fp.<span class=\"hljs-built_in\">close</span>();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n\n<span class=\"hljs-comment\">/** \\namespace machine_learning\n * \\brief Machine learning algorithms\n */</span>\n<span class=\"hljs-keyword\">namespace</span> machine_learning {\n\n<span class=\"hljs-comment\">/**\n * Update weights of the SOM using Kohonen algorithm\n *\n * \\param[in] X data point\n * \\param[in,out] W weights matrix\n * \\param[in,out] D temporary vector to store distances\n * \\param[in] alpha learning rate \\f$0&lt;\\alpha\\le1\\f$\n * \\param[in] R neighborhood range\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">update_weights</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::valarray&lt;<span class=\"hljs-type\">double</span>&gt; &amp;x,\n                    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *W,\n                    std::valarray&lt;<span class=\"hljs-type\">double</span>&gt; *D, <span class=\"hljs-type\">double</span> alpha, <span class=\"hljs-type\">int</span> R)</span> </span>{\n    <span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>, k = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">int</span> num_out = W-&gt;<span class=\"hljs-built_in\">size</span>();  <span class=\"hljs-comment\">// number of SOM output nodes</span>\n    <span class=\"hljs-comment\">// int num_features = x.size();  // number of data features</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-comment\">// step 1: for each output point</span>\n    <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; num_out; j++) {\n        <span class=\"hljs-comment\">// compute Euclidian distance of each output</span>\n        <span class=\"hljs-comment\">// point from the current sample</span>\n        (*D)[j] = (((*W)[j] - x) * ((*W)[j] - x)).<span class=\"hljs-built_in\">sum</span>();\n    }\n\n    <span class=\"hljs-comment\">// step 2:  get closest node i.e., node with snallest Euclidian distance to</span>\n    <span class=\"hljs-comment\">// the current pattern</span>\n    <span class=\"hljs-keyword\">auto</span> result = std::<span class=\"hljs-built_in\">min_element</span>(std::<span class=\"hljs-built_in\">begin</span>(*D), std::<span class=\"hljs-built_in\">end</span>(*D));\n    <span class=\"hljs-comment\">// double d_min = *result;</span>\n    <span class=\"hljs-type\">int</span> d_min_idx = std::<span class=\"hljs-built_in\">distance</span>(std::<span class=\"hljs-built_in\">begin</span>(*D), result);\n\n    <span class=\"hljs-comment\">// step 3a: get the neighborhood range</span>\n    <span class=\"hljs-type\">int</span> from_node = std::<span class=\"hljs-built_in\">max</span>(<span class=\"hljs-number\">0</span>, d_min_idx - R);\n    <span class=\"hljs-type\">int</span> to_node = std::<span class=\"hljs-built_in\">min</span>(num_out, d_min_idx + R + <span class=\"hljs-number\">1</span>);\n\n    <span class=\"hljs-comment\">// step 3b: update the weights of nodes in the</span>\n    <span class=\"hljs-comment\">// neighborhood</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-keyword\">for</span> (j = from_node; j &lt; to_node; j++) {\n        <span class=\"hljs-comment\">// update weights of nodes in the neighborhood</span>\n        (*W)[j] += alpha * (x - (*W)[j]);\n    }\n}\n\n<span class=\"hljs-comment\">/**\n * Apply incremental algorithm with updating neighborhood and learning rates\n * on all samples in the given datset.\n *\n * \\param[in] X data set\n * \\param[in,out] W weights matrix\n * \\param[in] alpha_min terminal value of alpha\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">kohonen_som_tracer</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; &amp;X,\n                        std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *W,\n                        <span class=\"hljs-type\">double</span> alpha_min)</span> </span>{\n    <span class=\"hljs-type\">int</span> num_samples = X.<span class=\"hljs-built_in\">size</span>();  <span class=\"hljs-comment\">// number of rows</span>\n    <span class=\"hljs-comment\">// int num_features = X[0].size();  // number of columns</span>\n    <span class=\"hljs-type\">int</span> num_out = W-&gt;<span class=\"hljs-built_in\">size</span>();  <span class=\"hljs-comment\">// number of rows</span>\n    <span class=\"hljs-type\">int</span> R = num_out &gt;&gt; <span class=\"hljs-number\">2</span>, iter = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">double</span> alpha = <span class=\"hljs-number\">1.f</span>;\n\n    <span class=\"hljs-function\">std::valarray&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">D</span><span class=\"hljs-params\">(num_out)</span></span>;\n\n    <span class=\"hljs-comment\">// Loop alpha from 1 to slpha_min</span>\n    <span class=\"hljs-keyword\">do</span> {\n        <span class=\"hljs-comment\">// Loop for each sample pattern in the data set</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> sample = <span class=\"hljs-number\">0</span>; sample &lt; num_samples; sample++) {\n            <span class=\"hljs-comment\">// update weights for the current input pattern sample</span>\n            <span class=\"hljs-built_in\">update_weights</span>(X[sample], W, &amp;D, alpha, R);\n        }\n\n        <span class=\"hljs-comment\">// every 10th iteration, reduce the neighborhood range</span>\n        <span class=\"hljs-keyword\">if</span> (iter % <span class=\"hljs-number\">10</span> == <span class=\"hljs-number\">0</span> &amp;&amp; R &gt; <span class=\"hljs-number\">1</span>) {\n            R--;\n        }\n\n        alpha -= <span class=\"hljs-number\">0.01</span>;\n        iter++;\n    } <span class=\"hljs-keyword\">while</span> (alpha &gt; alpha_min);\n}\n\n}  <span class=\"hljs-comment\">// namespace machine_learning</span>\n\n<span class=\"hljs-comment\">/** @} */</span>\n\n<span class=\"hljs-keyword\">using</span> machine_learning::kohonen_som_tracer;\n\n<span class=\"hljs-comment\">/** Creates a random set of points distributed *near* the circumference\n * of a circle and trains an SOM that finds that circular pattern. The\n * generating function is\n * \\f{eqnarray*}{\n * r &amp;\\in&amp; [1-\\delta r, 1+\\delta r)\\\\\n * \\theta &amp;\\in&amp; [0, 2\\pi)\\\\\n * x &amp;=&amp; r\\cos\\theta\\\\\n * y &amp;=&amp; r\\sin\\theta\n * \\f}\n *\n * \\param[out] data matrix to store data in\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_circle</span><span class=\"hljs-params\">(std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *data)</span> </span>{\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> N = data-&gt;<span class=\"hljs-built_in\">size</span>();\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">double</span> R = <span class=\"hljs-number\">0.75</span>, dr = <span class=\"hljs-number\">0.3</span>;\n    <span class=\"hljs-type\">double</span> <span class=\"hljs-type\">a_t</span> = <span class=\"hljs-number\">0.</span>, <span class=\"hljs-type\">b_t</span> = <span class=\"hljs-number\">2.f</span> * M_PI;  <span class=\"hljs-comment\">// theta random between 0 and 2*pi</span>\n    <span class=\"hljs-type\">double</span> a_r = R - dr, b_r = R + dr;  <span class=\"hljs-comment\">// radius random between R-dr and R+dr</span>\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n        <span class=\"hljs-type\">double</span> r = _random(a_r, b_r);      <span class=\"hljs-comment\">// random radius</span>\n        <span class=\"hljs-type\">double</span> theta = _random(<span class=\"hljs-type\">a_t</span>, <span class=\"hljs-type\">b_t</span>);  <span class=\"hljs-comment\">// random theta</span>\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">0</span>] = r * <span class=\"hljs-built_in\">cos</span>(theta);    <span class=\"hljs-comment\">// convert from polar to cartesian</span>\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">1</span>] = r * <span class=\"hljs-built_in\">sin</span>(theta);\n    }\n}\n\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed *near* the\n * circumference of a circle and trains an SOM that finds that circular pattern.\n * The following [CSV](https://en.wikipedia.org/wiki/Comma-separated_values)\n * files are created to validate the execution:\n * * `test1.csv`: random test samples points with a circular pattern\n * * `w11.csv`: initial random map\n * * `w12.csv`: trained SOM map\n *\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\n * the following snippet\n * ```gnuplot\n * set datafile separator &#x27;,&#x27;\n * plot &quot;test1.csv&quot; title &quot;original&quot;, \\\n *      &quot;w11.csv&quot; title &quot;w1&quot;, \\\n *      &quot;w12.csv&quot; title &quot;w2&quot;\n * ```\n * ![Sample execution\n * output](https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/machine_learning/kohonen/test1.svg)\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test1</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>, N = <span class=\"hljs-number\">500</span>;\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">2</span>;\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">50</span>;\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">X</span>(N);\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">W</span>(num_out);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; std::<span class=\"hljs-built_in\">max</span>(num_out, N); i++) {\n        <span class=\"hljs-comment\">// loop till max(N, num_out)</span>\n        <span class=\"hljs-keyword\">if</span> (i &lt; N) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\n            X[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\n        }\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\n            W[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n            <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++) {\n                <span class=\"hljs-comment\">// preallocate with random initial weights</span>\n                W[i][j] = _random(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>);\n            }\n        }\n    }\n\n    <span class=\"hljs-built_in\">test_circle</span>(&amp;X);  <span class=\"hljs-comment\">// create test data around circumference of a circle</span>\n    <span class=\"hljs-built_in\">save_nd_data</span>(<span class=\"hljs-string\">&quot;test1.csv&quot;</span>, X);    <span class=\"hljs-comment\">// save test data points</span>\n    <span class=\"hljs-built_in\">save_nd_data</span>(<span class=\"hljs-string\">&quot;w11.csv&quot;</span>, W);      <span class=\"hljs-comment\">// save initial random weights</span>\n    <span class=\"hljs-built_in\">kohonen_som_tracer</span>(X, &amp;W, <span class=\"hljs-number\">0.1</span>);  <span class=\"hljs-comment\">// train the SOM</span>\n    <span class=\"hljs-built_in\">save_nd_data</span>(<span class=\"hljs-string\">&quot;w12.csv&quot;</span>, W);      <span class=\"hljs-comment\">// save the resultant weights</span>\n}\n\n<span class=\"hljs-comment\">/** Creates a random set of points distributed *near* the locus\n * of the [Lamniscate of\n * Gerono](https://en.wikipedia.org/wiki/Lemniscate_of_Gerono).\n * \\f{eqnarray*}{\n * \\delta r &amp;=&amp; 0.2\\\\\n * \\delta x &amp;\\in&amp; [-\\delta r, \\delta r)\\\\\n * \\delta y &amp;\\in&amp; [-\\delta r, \\delta r)\\\\\n * \\theta &amp;\\in&amp; [0, \\pi)\\\\\n * x &amp;=&amp; \\delta x + \\cos\\theta\\\\\n * y &amp;=&amp; \\delta y + \\frac{\\sin(2\\theta)}{2}\n * \\f}\n * \\param[out] data matrix to store data in\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_lamniscate</span><span class=\"hljs-params\">(std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *data)</span> </span>{\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> N = data-&gt;<span class=\"hljs-built_in\">size</span>();\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">double</span> dr = <span class=\"hljs-number\">0.2</span>;\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n        <span class=\"hljs-type\">double</span> dx = _random(-dr, dr);     <span class=\"hljs-comment\">// random change in x</span>\n        <span class=\"hljs-type\">double</span> dy = _random(-dr, dr);     <span class=\"hljs-comment\">// random change in y</span>\n        <span class=\"hljs-type\">double</span> theta = _random(<span class=\"hljs-number\">0</span>, M_PI);  <span class=\"hljs-comment\">// random theta</span>\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">0</span>] = dx + <span class=\"hljs-built_in\">cos</span>(theta);  <span class=\"hljs-comment\">// convert from polar to cartesian</span>\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">1</span>] = dy + <span class=\"hljs-built_in\">sin</span>(<span class=\"hljs-number\">2.</span> * theta) / <span class=\"hljs-number\">2.f</span>;\n    }\n}\n\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed *near* the locus\n * of the [Lamniscate of\n * Gerono](https://en.wikipedia.org/wiki/Lemniscate_of_Gerono) and trains an SOM\n * that finds that circular pattern. The following\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\n * to validate the execution:\n * * `test2.csv`: random test samples points with a lamniscate pattern\n * * `w21.csv`: initial random map\n * * `w22.csv`: trained SOM map\n *\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\n * the following snippet\n * ```gnuplot\n * set datafile separator &#x27;,&#x27;\n * plot &quot;test2.csv&quot; title &quot;original&quot;, \\\n *      &quot;w21.csv&quot; title &quot;w1&quot;, \\\n *      &quot;w22.csv&quot; title &quot;w2&quot;\n * ```\n * ![Sample execution\n * output](https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/machine_learning/kohonen/test2.svg)\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test2</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>, N = <span class=\"hljs-number\">500</span>;\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">2</span>;\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">20</span>;\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">X</span>(N);\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">W</span>(num_out);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; std::<span class=\"hljs-built_in\">max</span>(num_out, N); i++) {\n        <span class=\"hljs-comment\">// loop till max(N, num_out)</span>\n        <span class=\"hljs-keyword\">if</span> (i &lt; N) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\n            X[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\n        }\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\n            W[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n            <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++) {\n                <span class=\"hljs-comment\">// preallocate with random initial weights</span>\n                W[i][j] = _random(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>);\n            }\n        }\n    }\n\n    <span class=\"hljs-built_in\">test_lamniscate</span>(&amp;X);              <span class=\"hljs-comment\">// create test data around the lamniscate</span>\n    <span class=\"hljs-built_in\">save_nd_data</span>(<span class=\"hljs-string\">&quot;test2.csv&quot;</span>, X);     <span class=\"hljs-comment\">// save test data points</span>\n    <span class=\"hljs-built_in\">save_nd_data</span>(<span class=\"hljs-string\">&quot;w21.csv&quot;</span>, W);       <span class=\"hljs-comment\">// save initial random weights</span>\n    <span class=\"hljs-built_in\">kohonen_som_tracer</span>(X, &amp;W, <span class=\"hljs-number\">0.01</span>);  <span class=\"hljs-comment\">// train the SOM</span>\n    <span class=\"hljs-built_in\">save_nd_data</span>(<span class=\"hljs-string\">&quot;w22.csv&quot;</span>, W);       <span class=\"hljs-comment\">// save the resultant weights</span>\n}\n\n<span class=\"hljs-comment\">/** Creates a random set of points distributed in six clusters in\n * 3D space with centroids at the points\n * * \\f${0.5, 0.5, 0.5}\\f$\n * * \\f${0.5, 0.5, -0.5}\\f$\n * * \\f${0.5, -0.5, 0.5}\\f$\n * * \\f${0.5, -0.5, -0.5}\\f$\n * * \\f${-0.5, 0.5, 0.5}\\f$\n * * \\f${-0.5, 0.5, -0.5}\\f$\n * * \\f${-0.5, -0.5, 0.5}\\f$\n * * \\f${-0.5, -0.5, -0.5}\\f$\n *\n * \\param[out] data matrix to store data in\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_3d_classes</span><span class=\"hljs-params\">(std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *data)</span> </span>{\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> N = data-&gt;<span class=\"hljs-built_in\">size</span>();\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">double</span> R = <span class=\"hljs-number\">0.1</span>;  <span class=\"hljs-comment\">// radius of cluster</span>\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> num_classes = <span class=\"hljs-number\">8</span>;\n    <span class=\"hljs-keyword\">const</span> std::array&lt;<span class=\"hljs-keyword\">const</span> std::array&lt;<span class=\"hljs-type\">double</span>, 3&gt;, num_classes&gt; centres = {\n        <span class=\"hljs-comment\">// centres of each class cluster</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>}),    <span class=\"hljs-comment\">// centre of class 0</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>}),   <span class=\"hljs-comment\">// centre of class 1</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>}),   <span class=\"hljs-comment\">// centre of class 2</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>}),  <span class=\"hljs-comment\">// centre of class 3</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>}),   <span class=\"hljs-comment\">// centre of class 4</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>}),  <span class=\"hljs-comment\">// centre of class 5</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>}),  <span class=\"hljs-comment\">// centre of class 6</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>})  <span class=\"hljs-comment\">// centre of class 7</span>\n    };\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n        <span class=\"hljs-type\">int</span> cls =\n            std::<span class=\"hljs-built_in\">rand</span>() % num_classes;  <span class=\"hljs-comment\">// select a random class for the point</span>\n\n        <span class=\"hljs-comment\">// create random coordinates (x,y,z) around the centre of the class</span>\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">0</span>] = _random(centres[cls][<span class=\"hljs-number\">0</span>] - R, centres[cls][<span class=\"hljs-number\">0</span>] + R);\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">1</span>] = _random(centres[cls][<span class=\"hljs-number\">1</span>] - R, centres[cls][<span class=\"hljs-number\">1</span>] + R);\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">2</span>] = _random(centres[cls][<span class=\"hljs-number\">2</span>] - R, centres[cls][<span class=\"hljs-number\">2</span>] + R);\n\n        <span class=\"hljs-comment\">/* The follosing can also be used\n        for (int j = 0; j &lt; 3; j++)\n            data[0][i][j] = _random(centres[cls][j] - R, centres[cls][j] + R);\n        */</span>\n    }\n}\n\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed in six clusters in\n * 3D space. The following\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\n * to validate the execution:\n * * `test3.csv`: random test samples points with a circular pattern\n * * `w31.csv`: initial random map\n * * `w32.csv`: trained SOM map\n *\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\n * the following snippet\n * ```gnuplot\n * set datafile separator &#x27;,&#x27;\n * plot &quot;test3.csv&quot; title &quot;original&quot;, \\\n *      &quot;w31.csv&quot; title &quot;w1&quot;, \\\n *      &quot;w32.csv&quot; title &quot;w2&quot;\n * ```\n * ![Sample execution\n * output](https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/machine_learning/kohonen/test3.svg)\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test3</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>, N = <span class=\"hljs-number\">200</span>;\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">3</span>;\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">20</span>;\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">X</span>(N);\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">W</span>(num_out);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; std::<span class=\"hljs-built_in\">max</span>(num_out, N); i++) {\n        <span class=\"hljs-comment\">// loop till max(N, num_out)</span>\n        <span class=\"hljs-keyword\">if</span> (i &lt; N) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\n            X[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\n        }\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\n            W[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n            <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++) {\n                <span class=\"hljs-comment\">// preallocate with random initial weights</span>\n                W[i][j] = _random(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>);\n            }\n        }\n    }\n\n    <span class=\"hljs-built_in\">test_3d_classes</span>(&amp;X);              <span class=\"hljs-comment\">// create test data around the lamniscate</span>\n    <span class=\"hljs-built_in\">save_nd_data</span>(<span class=\"hljs-string\">&quot;test3.csv&quot;</span>, X);     <span class=\"hljs-comment\">// save test data points</span>\n    <span class=\"hljs-built_in\">save_nd_data</span>(<span class=\"hljs-string\">&quot;w31.csv&quot;</span>, W);       <span class=\"hljs-comment\">// save initial random weights</span>\n    <span class=\"hljs-built_in\">kohonen_som_tracer</span>(X, &amp;W, <span class=\"hljs-number\">0.01</span>);  <span class=\"hljs-comment\">// train the SOM</span>\n    <span class=\"hljs-built_in\">save_nd_data</span>(<span class=\"hljs-string\">&quot;w32.csv&quot;</span>, W);       <span class=\"hljs-comment\">// save the resultant weights</span>\n}\n\n<span class=\"hljs-comment\">/**\n * Convert clock cycle difference to time in seconds\n *\n * \\param[in] start_t start clock\n * \\param[in] end_t end clock\n * \\returns time difference in seconds\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">get_clock_diff</span><span class=\"hljs-params\">(<span class=\"hljs-type\">clock_t</span> <span class=\"hljs-type\">start_t</span>, <span class=\"hljs-type\">clock_t</span> <span class=\"hljs-type\">end_t</span>)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(<span class=\"hljs-type\">end_t</span> - <span class=\"hljs-type\">start_t</span>) / CLOCKS_PER_SEC;\n}\n\n<span class=\"hljs-comment\">/** Main function */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span> </span>{\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Using OpenMP based parallelization\\n&quot;</span>;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;NOT using OpenMP based parallelization\\n&quot;</span>;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n    std::<span class=\"hljs-built_in\">srand</span>(std::<span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">nullptr</span>));\n\n    std::<span class=\"hljs-type\">clock_t</span> start_clk = std::<span class=\"hljs-built_in\">clock</span>();\n    <span class=\"hljs-built_in\">test1</span>();\n    <span class=\"hljs-keyword\">auto</span> end_clk = std::<span class=\"hljs-built_in\">clock</span>();\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 1 completed in &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">get_clock_diff</span>(start_clk, end_clk)\n              &lt;&lt; <span class=\"hljs-string\">&quot; sec\\n&quot;</span>;\n\n    start_clk = std::<span class=\"hljs-built_in\">clock</span>();\n    <span class=\"hljs-built_in\">test2</span>();\n    end_clk = std::<span class=\"hljs-built_in\">clock</span>();\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 2 completed in &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">get_clock_diff</span>(start_clk, end_clk)\n              &lt;&lt; <span class=\"hljs-string\">&quot; sec\\n&quot;</span>;\n\n    start_clk = std::<span class=\"hljs-built_in\">clock</span>();\n    <span class=\"hljs-built_in\">test3</span>();\n    end_clk = std::<span class=\"hljs-built_in\">clock</span>();\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 3 completed in &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">get_clock_diff</span>(start_clk, end_clk)\n              &lt;&lt; <span class=\"hljs-string\">&quot; sec\\n&quot;</span>;\n\n    std::cout\n        &lt;&lt; <span class=\"hljs-string\">&quot;(Note: Calculated times include: creating test sets, training &quot;</span>\n           <span class=\"hljs-string\">&quot;model and writing files to disk.)\\n\\n&quot;</span>;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "c": {
      "dir": "machine_learning/kohonen_som_trace.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/machine_learning/kohonen_som_trace.c",
      "code": "<span class=\"hljs-comment\">/**\n * \\file\n * \\brief [Kohonen self organizing\n * map](https://en.wikipedia.org/wiki/Self-organizing_map) (data tracing)\n *\n * \\details\n * This example implements a powerful self organizing map algorithm.\n * The algorithm creates a connected network of weights that closely\n * follows the given data points. This this creates a chain of nodes that\n * resembles the given input shape.\n * \\author [Krishna Vedala](https://github.com/kvedala)\n * \\see kohonen_som_topology.c\n */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> _USE_MATH_DEFINES <span class=\"hljs-comment\">/**&lt; required for MS Visual C */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;math.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;time.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP  <span class=\"hljs-comment\">// check if OpenMP based parallelization is available</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;omp.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n<span class=\"hljs-comment\">/**\n * @addtogroup machine_learning Machine learning algorithms\n * @{\n * @addtogroup kohonen_1d Kohonen SOM trace/chain algorithm\n * @{\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> max</span>\n<span class=\"hljs-comment\">/** shorthand for maximum value */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> max(a, b) (((a) &gt; (b)) ? (a) : (b))</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> min</span>\n<span class=\"hljs-comment\">/** shorthand for minimum value */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> min(a, b) (((a) &lt; (b)) ? (a) : (b))</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n<span class=\"hljs-comment\">/**\n * \\brief Helper function to generate a random number in a given interval.\n * \\details\n * \\n Steps:\n * 1. `r1 = rand() % 100` gets a random number between 0 and 99\n * 2. `r2 = r1 / 100` converts random number to be between 0 and 0.99\n * 3. scale and offset the random number to given range of \\f$[a,b)\\f$\n * \\f[\n * y = (b - a) \\times \\frac{\\text{(random number between 0 and RAND_MAX)} \\;\n * \\text{mod}\\; 100}{100} + a \\f]\n *\n * \\param a lower limit\n * \\param b upper limit\n * \\returns random number in the range \\f$[a,b)\\f$\n */</span>\n<span class=\"hljs-type\">double</span> _random(<span class=\"hljs-type\">double</span> a, <span class=\"hljs-type\">double</span> b)\n{\n    <span class=\"hljs-type\">int</span> r = rand() % <span class=\"hljs-number\">100</span>;\n    <span class=\"hljs-keyword\">return</span> ((b - a) * r / <span class=\"hljs-number\">100.f</span>) + a;\n}\n\n<span class=\"hljs-comment\">/**\n * Save a given n-dimensional data martix to file.\n *\n * \\param [in] fname filename to save in (gets overwriten without confirmation)\n * \\param [in] X matrix to save\n * \\param [in] num_points rows in the matrix = number of points\n * \\param [in] num_features columns in the matrix = dimensions of points\n * \\returns 0 if all ok\n * \\returns -1 if file creation failed\n */</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">save_nd_data</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> *fname, <span class=\"hljs-type\">double</span> **X, <span class=\"hljs-type\">int</span> num_points,\n                 <span class=\"hljs-type\">int</span> num_features)</span>\n{\n    FILE *fp = fopen(fname, <span class=\"hljs-string\">&quot;wt&quot;</span>);\n    <span class=\"hljs-keyword\">if</span> (!fp)  <span class=\"hljs-comment\">// error with fopen</span>\n    {\n        <span class=\"hljs-type\">char</span> msg[<span class=\"hljs-number\">120</span>];\n        <span class=\"hljs-built_in\">sprintf</span>(msg, <span class=\"hljs-string\">&quot;File error (%s): &quot;</span>, fname);\n        perror(msg);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    }\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; num_points; i++)  <span class=\"hljs-comment\">// for each point in the array</span>\n    {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; num_features; j++)  <span class=\"hljs-comment\">// for each feature in the array</span>\n        {\n            <span class=\"hljs-built_in\">fprintf</span>(fp, <span class=\"hljs-string\">&quot;%.4g&quot;</span>, X[i][j]);  <span class=\"hljs-comment\">// print the feature value</span>\n            <span class=\"hljs-keyword\">if</span> (j &lt; num_features - <span class=\"hljs-number\">1</span>)      <span class=\"hljs-comment\">// if not the last feature</span>\n                <span class=\"hljs-built_in\">fprintf</span>(fp, <span class=\"hljs-string\">&quot;,&quot;</span>);          <span class=\"hljs-comment\">// suffix comma</span>\n        }\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_points - <span class=\"hljs-number\">1</span>)  <span class=\"hljs-comment\">// if not the last row</span>\n            <span class=\"hljs-built_in\">fprintf</span>(fp, <span class=\"hljs-string\">&quot;\\n&quot;</span>);   <span class=\"hljs-comment\">// start a new line</span>\n    }\n    fclose(fp);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * Get minimum value and index of the value in a vector\n * \\param[in] X vector to search\n * \\param[in] N number of points in the vector\n * \\param[out] val minimum value found\n * \\param[out] idx index where minimum value was found\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">kohonen_get_min_1d</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> <span class=\"hljs-keyword\">const</span> *X, <span class=\"hljs-type\">int</span> N, <span class=\"hljs-type\">double</span> *val, <span class=\"hljs-type\">int</span> *idx)</span>\n{\n    val[<span class=\"hljs-number\">0</span>] = INFINITY;  <span class=\"hljs-comment\">// initial min value</span>\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)  <span class=\"hljs-comment\">// check each value</span>\n    {\n        <span class=\"hljs-keyword\">if</span> (X[i] &lt; val[<span class=\"hljs-number\">0</span>])  <span class=\"hljs-comment\">// if a lower value is found</span>\n        {                   <span class=\"hljs-comment\">// save the value and its index</span>\n            idx[<span class=\"hljs-number\">0</span>] = i;\n            val[<span class=\"hljs-number\">0</span>] = X[i];\n        }\n    }\n}\n\n<span class=\"hljs-comment\">/**\n * Update weights of the SOM using Kohonen algorithm\n *\n * \\param[in] x data point\n * \\param[in,out] W weights matrix\n * \\param[in,out] D temporary vector to store distances\n * \\param[in] num_out number of output points\n * \\param[in] num_features number of features per input sample\n * \\param[in] alpha learning rate \\f$0&lt;\\alpha\\le1\\f$\n * \\param[in] R neighborhood range\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">kohonen_update_weights</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> <span class=\"hljs-keyword\">const</span> *x, <span class=\"hljs-type\">double</span> *<span class=\"hljs-keyword\">const</span> *W, <span class=\"hljs-type\">double</span> *D,\n                            <span class=\"hljs-type\">int</span> num_out, <span class=\"hljs-type\">int</span> num_features, <span class=\"hljs-type\">double</span> alpha, <span class=\"hljs-type\">int</span> R)</span>\n{\n    <span class=\"hljs-type\">int</span> j, k;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-comment\">// step 1: for each output point</span>\n    <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; num_out; j++)\n    {\n        D[j] = <span class=\"hljs-number\">0.f</span>;\n        <span class=\"hljs-comment\">// compute Euclidian distance of each output</span>\n        <span class=\"hljs-comment\">// point from the current sample</span>\n        <span class=\"hljs-keyword\">for</span> (k = <span class=\"hljs-number\">0</span>; k &lt; num_features; k++)\n            D[j] += (W[j][k] - x[k]) * (W[j][k] - x[k]);\n    }\n\n    <span class=\"hljs-comment\">// step 2:  get closest node i.e., node with smallest Euclidian distance to</span>\n    <span class=\"hljs-comment\">// the current pattern</span>\n    <span class=\"hljs-type\">int</span> d_min_idx;\n    <span class=\"hljs-type\">double</span> d_min;\n    kohonen_get_min_1d(D, num_out, &amp;d_min, &amp;d_min_idx);\n\n    <span class=\"hljs-comment\">// step 3a: get the neighborhood range</span>\n    <span class=\"hljs-type\">int</span> from_node = max(<span class=\"hljs-number\">0</span>, d_min_idx - R);\n    <span class=\"hljs-type\">int</span> to_node = min(num_out, d_min_idx + R + <span class=\"hljs-number\">1</span>);\n\n    <span class=\"hljs-comment\">// step 3b: update the weights of nodes in the</span>\n    <span class=\"hljs-comment\">// neighborhood</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-keyword\">for</span> (j = from_node; j &lt; to_node; j++)\n        <span class=\"hljs-keyword\">for</span> (k = <span class=\"hljs-number\">0</span>; k &lt; num_features; k++)\n            <span class=\"hljs-comment\">// update weights of nodes in the neighborhood</span>\n            W[j][k] += alpha * (x[k] - W[j][k]);\n}\n\n<span class=\"hljs-comment\">/**\n * Apply incremental algorithm with updating neighborhood and learning rates\n * on all samples in the given datset.\n *\n * \\param[in] X data set\n * \\param[in,out] W weights matrix\n * \\param[in] num_samples number of output points\n * \\param[in] num_features number of features per input sample\n * \\param[in] num_out number of output points\n * \\param[in] alpha_min terminal value of alpha\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">kohonen_som_tracer</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> **X, <span class=\"hljs-type\">double</span> *<span class=\"hljs-keyword\">const</span> *W, <span class=\"hljs-type\">int</span> num_samples,\n                        <span class=\"hljs-type\">int</span> num_features, <span class=\"hljs-type\">int</span> num_out, <span class=\"hljs-type\">double</span> alpha_min)</span>\n{\n    <span class=\"hljs-type\">int</span> R = num_out &gt;&gt; <span class=\"hljs-number\">2</span>, iter = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">double</span> alpha = <span class=\"hljs-number\">1.f</span>;\n    <span class=\"hljs-type\">double</span> *D = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(num_out * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\n\n    <span class=\"hljs-comment\">// Loop alpha from 1 to alpha_min</span>\n    <span class=\"hljs-keyword\">for</span> (; alpha &gt; alpha_min; alpha -= <span class=\"hljs-number\">0.01</span>, iter++)\n    {\n        <span class=\"hljs-comment\">// Loop for each sample pattern in the data set</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> sample = <span class=\"hljs-number\">0</span>; sample &lt; num_samples; sample++)\n        {\n            <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">double</span> *x = X[sample];\n            <span class=\"hljs-comment\">// update weights for the current input pattern sample</span>\n            kohonen_update_weights(x, W, D, num_out, num_features, alpha, R);\n        }\n\n        <span class=\"hljs-comment\">// every 10th iteration, reduce the neighborhood range</span>\n        <span class=\"hljs-keyword\">if</span> (iter % <span class=\"hljs-number\">10</span> == <span class=\"hljs-number\">0</span> &amp;&amp; R &gt; <span class=\"hljs-number\">1</span>)\n            R--;\n    }\n\n    <span class=\"hljs-built_in\">free</span>(D);\n}\n\n<span class=\"hljs-comment\">/**\n * @}\n * @}\n */</span>\n\n<span class=\"hljs-comment\">/** Creates a random set of points distributed *near* the circumference\n * of a circle and trains an SOM that finds that circular pattern. The\n * generating function is\n * \\f{eqnarray*}{\n * r &amp;\\in&amp; [1-\\delta r, 1+\\delta r)\\\\\n * \\theta &amp;\\in&amp; [0, 2\\pi)\\\\\n * x &amp;=&amp; r\\cos\\theta\\\\\n * y &amp;=&amp; r\\sin\\theta\n * \\f}\n *\n * \\param[out] data matrix to store data in\n * \\param[in] N number of points required\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test_circle</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> *<span class=\"hljs-keyword\">const</span> *data, <span class=\"hljs-type\">int</span> N)</span>\n{\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">double</span> R = <span class=\"hljs-number\">0.75</span>, dr = <span class=\"hljs-number\">0.3</span>;\n    <span class=\"hljs-type\">double</span> <span class=\"hljs-type\">a_t</span> = <span class=\"hljs-number\">0.</span>, <span class=\"hljs-type\">b_t</span> = <span class=\"hljs-number\">2.f</span> * M_PI;  <span class=\"hljs-comment\">// theta random between 0 and 2*pi</span>\n    <span class=\"hljs-type\">double</span> a_r = R - dr, b_r = R + dr;  <span class=\"hljs-comment\">// radius random between R-dr and R+dr</span>\n    <span class=\"hljs-type\">int</span> i;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\n    {\n        <span class=\"hljs-type\">double</span> r = _random(a_r, b_r);      <span class=\"hljs-comment\">// random radius</span>\n        <span class=\"hljs-type\">double</span> theta = _random(<span class=\"hljs-type\">a_t</span>, <span class=\"hljs-type\">b_t</span>);  <span class=\"hljs-comment\">// random theta</span>\n        data[i][<span class=\"hljs-number\">0</span>] = r * <span class=\"hljs-built_in\">cos</span>(theta);       <span class=\"hljs-comment\">// convert from polar to cartesian</span>\n        data[i][<span class=\"hljs-number\">1</span>] = r * <span class=\"hljs-built_in\">sin</span>(theta);\n    }\n}\n\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed *near* the\n * circumference of a circle and trains an SOM that finds that circular pattern.\n * The following [CSV](https://en.wikipedia.org/wiki/Comma-separated_values)\n * files are created to validate the execution:\n * * `test1.csv`: random test samples points with a circular pattern\n * * `w11.csv`: initial random map\n * * `w12.csv`: trained SOM map\n *\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\n * the following snippet\n * ```gnuplot\n * set datafile separator &#x27;,&#x27;\n * plot &quot;test1.csv&quot; title &quot;original&quot;, \\\n *      &quot;w11.csv&quot; title &quot;w1&quot;, \\\n *      &quot;w12.csv&quot; title &quot;w2&quot;\n * ```\n * ![Sample execution\n * output](https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/test1.svg)\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test1</span><span class=\"hljs-params\">()</span>\n{\n    <span class=\"hljs-type\">int</span> j, N = <span class=\"hljs-number\">500</span>;\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">2</span>;\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">50</span>;\n\n    <span class=\"hljs-comment\">// 2D space, hence size = number of rows * 2</span>\n    <span class=\"hljs-type\">double</span> **X = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\n\n    <span class=\"hljs-comment\">// number of clusters nodes * 2</span>\n    <span class=\"hljs-type\">double</span> **W = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(num_out * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max(num_out, N); i++)  <span class=\"hljs-comment\">// loop till max(N, num_out)</span>\n    {\n        <span class=\"hljs-keyword\">if</span> (i &lt; N)  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\n            X[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(features * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out)  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\n        {\n            W[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(features * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n            <span class=\"hljs-comment\">// preallocate with random initial weights</span>\n            <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++) W[i][j] = _random(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>);\n        }\n    }\n\n    test_circle(X, N);  <span class=\"hljs-comment\">// create test data around circumference of a circle</span>\n    save_nd_data(<span class=\"hljs-string\">&quot;test1.csv&quot;</span>, X, N, features);  <span class=\"hljs-comment\">// save test data points</span>\n    save_nd_data(<span class=\"hljs-string\">&quot;w11.csv&quot;</span>, W, num_out,\n                 features);  <span class=\"hljs-comment\">// save initial random weights</span>\n    kohonen_som_tracer(X, W, N, features, num_out, <span class=\"hljs-number\">0.1</span>);  <span class=\"hljs-comment\">// train the SOM</span>\n    save_nd_data(<span class=\"hljs-string\">&quot;w12.csv&quot;</span>, W, num_out,\n                 features);  <span class=\"hljs-comment\">// save the resultant weights</span>\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max(num_out, N); i++)\n    {\n        <span class=\"hljs-keyword\">if</span> (i &lt; N)\n            <span class=\"hljs-built_in\">free</span>(X[i]);\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out)\n            <span class=\"hljs-built_in\">free</span>(W[i]);\n    }\n}\n\n<span class=\"hljs-comment\">/** Creates a random set of points distributed *near* the locus\n * of the [Lamniscate of\n * Gerono](https://en.wikipedia.org/wiki/Lemniscate_of_Gerono).\n * \\f{eqnarray*}{\n * \\delta r &amp;=&amp; 0.2\\\\\n * \\delta x &amp;\\in&amp; [-\\delta r, \\delta r)\\\\\n * \\delta y &amp;\\in&amp; [-\\delta r, \\delta r)\\\\\n * \\theta &amp;\\in&amp; [0, \\pi)\\\\\n * x &amp;=&amp; \\delta x + \\cos\\theta\\\\\n * y &amp;=&amp; \\delta y + \\frac{\\sin(2\\theta)}{2}\n * \\f}\n * \\param[out] data matrix to store data in\n * \\param[in] N number of points required\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test_lamniscate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> *<span class=\"hljs-keyword\">const</span> *data, <span class=\"hljs-type\">int</span> N)</span>\n{\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">double</span> dr = <span class=\"hljs-number\">0.2</span>;\n    <span class=\"hljs-type\">int</span> i;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\n    {\n        <span class=\"hljs-type\">double</span> dx = _random(-dr, dr);     <span class=\"hljs-comment\">// random change in x</span>\n        <span class=\"hljs-type\">double</span> dy = _random(-dr, dr);     <span class=\"hljs-comment\">// random change in y</span>\n        <span class=\"hljs-type\">double</span> theta = _random(<span class=\"hljs-number\">0</span>, M_PI);  <span class=\"hljs-comment\">// random theta</span>\n        data[i][<span class=\"hljs-number\">0</span>] = dx + <span class=\"hljs-built_in\">cos</span>(theta);     <span class=\"hljs-comment\">// convert from polar to cartesian</span>\n        data[i][<span class=\"hljs-number\">1</span>] = dy + <span class=\"hljs-built_in\">sin</span>(<span class=\"hljs-number\">2.</span> * theta) / <span class=\"hljs-number\">2.f</span>;\n    }\n}\n\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed *near* the locus\n * of the [Lamniscate of\n * Gerono](https://en.wikipedia.org/wiki/Lemniscate_of_Gerono) and trains an SOM\n * that finds that circular pattern. The following\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\n * to validate the execution:\n * * `test2.csv`: random test samples points with a lamniscate pattern\n * * `w21.csv`: initial random map\n * * `w22.csv`: trained SOM map\n *\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\n * the following snippet\n * ```gnuplot\n * set datafile separator &#x27;,&#x27;\n * plot &quot;test2.csv&quot; title &quot;original&quot;, \\\n *      &quot;w21.csv&quot; title &quot;w1&quot;, \\\n *      &quot;w22.csv&quot; title &quot;w2&quot;\n * ```\n * ![Sample execution\n * output](https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/test2.svg)\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test2</span><span class=\"hljs-params\">()</span>\n{\n    <span class=\"hljs-type\">int</span> j, N = <span class=\"hljs-number\">500</span>;\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">2</span>;\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">20</span>;\n    <span class=\"hljs-type\">double</span> **X = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\n    <span class=\"hljs-type\">double</span> **W = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(num_out * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max(num_out, N); i++)\n    {\n        <span class=\"hljs-keyword\">if</span> (i &lt; N)  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\n            X[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(features * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out)  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\n        {\n            W[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(features * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n            <span class=\"hljs-comment\">// preallocate with random initial weights</span>\n            <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++) W[i][j] = _random(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>);\n        }\n    }\n\n    test_lamniscate(X, N);  <span class=\"hljs-comment\">// create test data around the lamniscate</span>\n    save_nd_data(<span class=\"hljs-string\">&quot;test2.csv&quot;</span>, X, N, features);  <span class=\"hljs-comment\">// save test data points</span>\n    save_nd_data(<span class=\"hljs-string\">&quot;w21.csv&quot;</span>, W, num_out,\n                 features);  <span class=\"hljs-comment\">// save initial random weights</span>\n    kohonen_som_tracer(X, W, N, features, num_out, <span class=\"hljs-number\">0.01</span>);  <span class=\"hljs-comment\">// train the SOM</span>\n    save_nd_data(<span class=\"hljs-string\">&quot;w22.csv&quot;</span>, W, num_out,\n                 features);  <span class=\"hljs-comment\">// save the resultant weights</span>\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max(num_out, N); i++)\n    {\n        <span class=\"hljs-keyword\">if</span> (i &lt; N)\n            <span class=\"hljs-built_in\">free</span>(X[i]);\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out)\n            <span class=\"hljs-built_in\">free</span>(W[i]);\n    }\n    <span class=\"hljs-built_in\">free</span>(X);\n    <span class=\"hljs-built_in\">free</span>(W);\n}\n\n<span class=\"hljs-comment\">/** Creates a random set of points distributed in four clusters in\n * 3D space with centroids at the points\n * * \\f$(0,5, 0.5, 0.5)\\f$\n * * \\f$(0,5,-0.5, -0.5)\\f$\n * * \\f$(-0,5, 0.5, 0.5)\\f$\n * * \\f$(-0,5,-0.5, -0.5)\\f$\n *\n * \\param[out] data matrix to store data in\n * \\param[in] N number of points required\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test_3d_classes</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> *<span class=\"hljs-keyword\">const</span> *data, <span class=\"hljs-type\">int</span> N)</span>\n{\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">double</span> R = <span class=\"hljs-number\">0.1</span>;  <span class=\"hljs-comment\">// radius of cluster</span>\n    <span class=\"hljs-type\">int</span> i;\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> num_classes = <span class=\"hljs-number\">4</span>;\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">double</span> centres[][<span class=\"hljs-number\">3</span>] = {\n        <span class=\"hljs-comment\">// centres of each class cluster</span>\n        {<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>},    <span class=\"hljs-comment\">// centre of class 1</span>\n        {<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>},  <span class=\"hljs-comment\">// centre of class 2</span>\n        {<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>},   <span class=\"hljs-comment\">// centre of class 3</span>\n        {<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span> - <span class=\"hljs-number\">.5</span>}  <span class=\"hljs-comment\">// centre of class 4</span>\n    };\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\n    {\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> =</span>\n            rand() % num_classes;  <span class=\"hljs-comment\">// select a random class for the point</span>\n\n        <span class=\"hljs-comment\">// create random coordinates (x,y,z) around the centre of the class</span>\n        data[i][<span class=\"hljs-number\">0</span>] = _random(centres[class][<span class=\"hljs-number\">0</span>] - R, centres[class][<span class=\"hljs-number\">0</span>] + R);\n        data[i][<span class=\"hljs-number\">1</span>] = _random(centres[class][<span class=\"hljs-number\">1</span>] - R, centres[class][<span class=\"hljs-number\">1</span>] + R);\n        data[i][<span class=\"hljs-number\">2</span>] = _random(centres[class][<span class=\"hljs-number\">2</span>] - R, centres[class][<span class=\"hljs-number\">2</span>] + R);\n\n        <span class=\"hljs-comment\">/* The follosing can also be used\n        for (int j = 0; j &lt; 3; j++)\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\n        */</span>\n    }\n}\n\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed in six clusters in\n * 3D space. The following\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\n * to validate the execution:\n * * `test3.csv`: random test samples points with a circular pattern\n * * `w31.csv`: initial random map\n * * `w32.csv`: trained SOM map\n *\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\n * the following snippet\n * ```gnuplot\n * set datafile separator &#x27;,&#x27;\n * plot &quot;test3.csv&quot; title &quot;original&quot;, \\\n *      &quot;w31.csv&quot; title &quot;w1&quot;, \\\n *      &quot;w32.csv&quot; title &quot;w2&quot;\n * ```\n * ![Sample execution\n * output](https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/test3.svg)\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test3</span><span class=\"hljs-params\">()</span>\n{\n    <span class=\"hljs-type\">int</span> j, N = <span class=\"hljs-number\">200</span>;\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">3</span>;\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">20</span>;\n    <span class=\"hljs-type\">double</span> **X = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\n    <span class=\"hljs-type\">double</span> **W = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(num_out * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max(num_out, N); i++)\n    {\n        <span class=\"hljs-keyword\">if</span> (i &lt; N)  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\n            X[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(features * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out)  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\n        {\n            W[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(features * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n            <span class=\"hljs-comment\">// preallocate with random initial weights</span>\n            <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++) W[i][j] = _random(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>);\n        }\n    }\n\n    test_3d_classes(X, N);  <span class=\"hljs-comment\">// create test data around the lamniscate</span>\n    save_nd_data(<span class=\"hljs-string\">&quot;test3.csv&quot;</span>, X, N, features);  <span class=\"hljs-comment\">// save test data points</span>\n    save_nd_data(<span class=\"hljs-string\">&quot;w31.csv&quot;</span>, W, num_out,\n                 features);  <span class=\"hljs-comment\">// save initial random weights</span>\n    kohonen_som_tracer(X, W, N, features, num_out, <span class=\"hljs-number\">0.01</span>);  <span class=\"hljs-comment\">// train the SOM</span>\n    save_nd_data(<span class=\"hljs-string\">&quot;w32.csv&quot;</span>, W, num_out,\n                 features);  <span class=\"hljs-comment\">// save the resultant weights</span>\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max(num_out, N); i++)\n    {\n        <span class=\"hljs-keyword\">if</span> (i &lt; N)\n            <span class=\"hljs-built_in\">free</span>(X[i]);\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out)\n            <span class=\"hljs-built_in\">free</span>(W[i]);\n    }\n    <span class=\"hljs-built_in\">free</span>(X);\n    <span class=\"hljs-built_in\">free</span>(W);\n}\n\n<span class=\"hljs-comment\">/**\n * Convert clock cycle difference to time in seconds\n *\n * \\param[in] start_t start clock\n * \\param[in] end_t end clock\n * \\returns time difference in seconds\n */</span>\n<span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">get_clock_diff</span><span class=\"hljs-params\">(<span class=\"hljs-type\">clock_t</span> <span class=\"hljs-type\">start_t</span>, <span class=\"hljs-type\">clock_t</span> <span class=\"hljs-type\">end_t</span>)</span>\n{\n    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-type\">double</span>)(<span class=\"hljs-type\">end_t</span> - <span class=\"hljs-type\">start_t</span>) / (<span class=\"hljs-type\">double</span>)CLOCKS_PER_SEC;\n}\n\n<span class=\"hljs-comment\">/** Main function */</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span>\n{\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Using OpenMP based parallelization\\n&quot;</span>);\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span>\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;NOT using OpenMP based parallelization\\n&quot;</span>);\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-type\">clock_t</span> start_clk = clock();\n    test1();\n    <span class=\"hljs-type\">clock_t</span> end_clk = clock();\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Test 1 completed in %.4g sec\\n&quot;</span>,\n           get_clock_diff(start_clk, end_clk));\n    start_clk = clock();\n    test2();\n    end_clk = clock();\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Test 2 completed in %.4g sec\\n&quot;</span>,\n           get_clock_diff(start_clk, end_clk));\n    start_clk = clock();\n    test3();\n    end_clk = clock();\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Test 3 completed in %.4g sec\\n&quot;</span>,\n           get_clock_diff(start_clk, end_clk));\n    <span class=\"hljs-built_in\">printf</span>(\n        <span class=\"hljs-string\">&quot;(Note: Calculated times include: creating test sets, training &quot;</span>\n        <span class=\"hljs-string\">&quot;model and writing files to disk.)\\n\\n&quot;</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 12
    }
  ],
  "explanationUrl": {}
}
