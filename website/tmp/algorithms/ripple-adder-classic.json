{
  "slug": "ripple-adder-classic",
  "name": "Ripple Adder Classic",
  "categories": ["quantum"],
  "body": {},
  "implementations": {
    "python": {
      "dir": "quantum/ripple_adder_classic.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/quantum/ripple_adder_classic.py",
      "code": "<span class=\"hljs-comment\"># https://github.com/rupansh/QuantumComputing/blob/master/rippleadd.py</span>\n<span class=\"hljs-comment\"># https://en.wikipedia.org/wiki/Adder_(electronics)#Full_adder</span>\n<span class=\"hljs-comment\"># https://en.wikipedia.org/wiki/Controlled_NOT_gate</span>\n\n<span class=\"hljs-keyword\">from</span> qiskit <span class=\"hljs-keyword\">import</span> Aer, QuantumCircuit, execute\n<span class=\"hljs-keyword\">from</span> qiskit.providers <span class=\"hljs-keyword\">import</span> BaseBackend\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">store_two_classics</span>(<span class=\"hljs-params\">val1: <span class=\"hljs-built_in\">int</span>, val2: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">tuple</span>[QuantumCircuit, <span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">str</span>]:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Generates a Quantum Circuit which stores two classical integers\n    Returns the circuit and binary representation of the integers\n    &quot;&quot;&quot;</span>\n    x, y = <span class=\"hljs-built_in\">bin</span>(val1)[<span class=\"hljs-number\">2</span>:], <span class=\"hljs-built_in\">bin</span>(val2)[<span class=\"hljs-number\">2</span>:]  <span class=\"hljs-comment\"># Remove leading &#x27;0b&#x27;</span>\n\n    <span class=\"hljs-comment\"># Ensure that both strings are of the same length</span>\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(x) &gt; <span class=\"hljs-built_in\">len</span>(y):\n        y = y.zfill(<span class=\"hljs-built_in\">len</span>(x))\n    <span class=\"hljs-keyword\">else</span>:\n        x = x.zfill(<span class=\"hljs-built_in\">len</span>(y))\n\n    <span class=\"hljs-comment\"># We need (3 * number of bits in the larger number)+1 qBits</span>\n    <span class=\"hljs-comment\"># The second parameter is the number of classical registers, to measure the result</span>\n    circuit = QuantumCircuit((<span class=\"hljs-built_in\">len</span>(x) * <span class=\"hljs-number\">3</span>) + <span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">len</span>(x) + <span class=\"hljs-number\">1</span>)\n\n    <span class=\"hljs-comment\"># We are essentially &quot;not-ing&quot; the bits that are 1</span>\n    <span class=\"hljs-comment\"># Reversed because its easier to perform ops on more significant bits</span>\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(x)):\n        <span class=\"hljs-keyword\">if</span> x[::-<span class=\"hljs-number\">1</span>][i] == <span class=\"hljs-string\">&quot;1&quot;</span>:\n            circuit.x(i)\n    <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(y)):\n        <span class=\"hljs-keyword\">if</span> y[::-<span class=\"hljs-number\">1</span>][j] == <span class=\"hljs-string\">&quot;1&quot;</span>:\n            circuit.x(<span class=\"hljs-built_in\">len</span>(x) + j)\n\n    <span class=\"hljs-keyword\">return</span> circuit, x, y\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">full_adder</span>(<span class=\"hljs-params\">\n    circuit: QuantumCircuit,\n    input1_loc: <span class=\"hljs-built_in\">int</span>,\n    input2_loc: <span class=\"hljs-built_in\">int</span>,\n    carry_in: <span class=\"hljs-built_in\">int</span>,\n    carry_out: <span class=\"hljs-built_in\">int</span>,\n</span>):\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Quantum Equivalent of a Full Adder Circuit\n    CX/CCX is like 2-way/3-way XOR\n    &quot;&quot;&quot;</span>\n    circuit.ccx(input1_loc, input2_loc, carry_out)\n    circuit.cx(input1_loc, input2_loc)\n    circuit.ccx(input2_loc, carry_in, carry_out)\n    circuit.cx(input2_loc, carry_in)\n    circuit.cx(input1_loc, input2_loc)\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">ripple_adder</span>(<span class=\"hljs-params\">\n    val1: <span class=\"hljs-built_in\">int</span>, val2: <span class=\"hljs-built_in\">int</span>, backend: BaseBackend = Aer.get_backend(<span class=\"hljs-params\"><span class=\"hljs-string\">&quot;qasm_simulator&quot;</span></span>)\n</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Quantum Equivalent of a Ripple Adder Circuit\n    Uses qasm_simulator backend by default\n\n    Currently only adds &#x27;emulated&#x27; Classical Bits\n    but nothing prevents us from doing this with hadamard&#x27;d bits :)\n\n    Only supports adding +ve Integers\n\n    &gt;&gt;&gt; ripple_adder(3, 4)\n    7\n    &gt;&gt;&gt; ripple_adder(10, 4)\n    14\n    &gt;&gt;&gt; ripple_adder(-1, 10)\n    Traceback (most recent call last):\n        ...\n    ValueError: Both Integers must be positive!\n    &quot;&quot;&quot;</span>\n\n    <span class=\"hljs-keyword\">if</span> val1 &lt; <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">or</span> val2 &lt; <span class=\"hljs-number\">0</span>:\n        <span class=\"hljs-keyword\">raise</span> ValueError(<span class=\"hljs-string\">&quot;Both Integers must be positive!&quot;</span>)\n\n    <span class=\"hljs-comment\"># Store the Integers</span>\n    circuit, x, y = store_two_classics(val1, val2)\n\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    We are essentially using each bit of x &amp; y respectively as full_adder&#x27;s input\n    the carry_input is used from the previous circuit (for circuit num &gt; 1)\n\n    the carry_out is just below carry_input because\n    it will be essentially the carry_input for the next full_adder\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(x)):\n        full_adder(circuit, i, <span class=\"hljs-built_in\">len</span>(x) + i, <span class=\"hljs-built_in\">len</span>(x) + <span class=\"hljs-built_in\">len</span>(y) + i, <span class=\"hljs-built_in\">len</span>(x) + <span class=\"hljs-built_in\">len</span>(y) + i + <span class=\"hljs-number\">1</span>)\n        circuit.barrier()  <span class=\"hljs-comment\"># Optional, just for aesthetics</span>\n\n    <span class=\"hljs-comment\"># Measure the resultant qBits</span>\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(x) + <span class=\"hljs-number\">1</span>):\n        circuit.measure([(<span class=\"hljs-built_in\">len</span>(x) * <span class=\"hljs-number\">2</span>) + i], [i])\n\n    res = execute(circuit, backend, shots=<span class=\"hljs-number\">1</span>).result()\n\n    <span class=\"hljs-comment\"># The result is in binary. Convert it back to int</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">list</span>(res.get_counts().keys())[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">2</span>)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    <span class=\"hljs-keyword\">import</span> doctest\n\n    doctest.testmod()\n"
    }
  },
  "contributors": [
    {
      "name": "algobytewise",
      "email": "algobytewise@gmail.com",
      "commits": 1
    },
    {
      "name": "Rupansh",
      "email": "rupanshsekar@hotmail.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}
