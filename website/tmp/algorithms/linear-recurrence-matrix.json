{
  "slug": "linear-recurrence-matrix",
  "name": "Linear Recurrence Matrix",
  "categories": ["math"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "math/linear_recurrence_matrix.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/math/linear_recurrence_matrix.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @brief Evaluate recurrence relation using [matrix\n * exponentiation](https://www.hackerearth.com/practice/notes/matrix-exponentiation-1/).\n * @details\n * Given a recurrence relation; evaluate the value of nth term.\n * For e.g., For fibonacci series, recurrence series is `f(n) = f(n-1) + f(n-2)`\n * where `f(0) = 0` and `f(1) = 1`.\n * Note that the method used only demonstrates\n * recurrence relation with one variable (n), unlike `nCr` problem, since it has\n * two (n, r)\n *\n * ### Algorithm\n * This problem can be solved using matrix exponentiation method.\n * @see here for simple [number exponentiation\n * algorithm](https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/modular_exponentiation.cpp)\n * or [explaination\n * here](https://en.wikipedia.org/wiki/Exponentiation_by_squaring).\n * @author [Ashish Daulatabad](https://github.com/AshishYUO)\n */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>   <span class=\"hljs-comment\">/// for assert</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>  <span class=\"hljs-comment\">/// for IO operations</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>    <span class=\"hljs-comment\">/// for std::vector STL</span></span>\n\n<span class=\"hljs-comment\">/**\n * @namespace math\n * @brief Mathematical algorithms\n */</span>\n<span class=\"hljs-keyword\">namespace</span> math {\n<span class=\"hljs-comment\">/**\n * @namespace linear_recurrence_matrix\n * @brief Functions for [Linear Recurrence\n * Matrix](https://www.hackerearth.com/practice/notes/matrix-exponentiation-1/)\n * implementation.\n */</span>\n<span class=\"hljs-keyword\">namespace</span> linear_recurrence_matrix {\n<span class=\"hljs-comment\">/**\n * @brief Implementation of matrix multiplication\n * @details Multiplies matrix A and B, given total columns in A are equal to\n * total given rows in column B\n * @tparam T template type for integer as well as floating values, default is\n * long long int\n * @param _mat_a first matrix of size n * m\n * @param _mat_b second matrix of size m * k\n * @returns `_mat_c` resultant matrix of size n * k\n * Complexity: `O(n*m*k)`\n * @note The complexity in this case will be O(n^3) due to the nature of the\n * problem. We&#x27;ll be multiplying the matrix with itself most of the time.\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T = <span class=\"hljs-type\">int64_t</span>&gt;\nstd::vector&lt;std::vector&lt;T&gt;&gt; <span class=\"hljs-built_in\">matrix_multiplication</span>(\n    <span class=\"hljs-keyword\">const</span> std::vector&lt;std::vector&lt;T&gt;&gt;&amp; _mat_a,\n    <span class=\"hljs-keyword\">const</span> std::vector&lt;std::vector&lt;T&gt;&gt;&amp; _mat_b, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int64_t</span> mod = <span class=\"hljs-number\">1000000007</span>) {\n    <span class=\"hljs-comment\">// assert that columns in `_mat_a` and rows in `_mat_b` are equal</span>\n    <span class=\"hljs-built_in\">assert</span>(_mat_a[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>() == _mat_b.<span class=\"hljs-built_in\">size</span>());\n    std::vector&lt;std::vector&lt;T&gt;&gt; _mat_c(_mat_a.<span class=\"hljs-built_in\">size</span>(),\n                                       std::<span class=\"hljs-built_in\">vector</span>&lt;T&gt;(_mat_b[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>(), <span class=\"hljs-number\">0</span>));\n    <span class=\"hljs-comment\">/**\n     * Actual matrix multiplication.\n     */</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; _mat_a.<span class=\"hljs-built_in\">size</span>(); ++i) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; _mat_b[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>(); ++j) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> k = <span class=\"hljs-number\">0</span>; k &lt; _mat_b.<span class=\"hljs-built_in\">size</span>(); ++k) {\n                _mat_c[i][j] =\n                    (_mat_c[i][j] % mod +\n                     (_mat_a[i][k] % mod * _mat_b[k][j] % mod) % mod) %\n                    mod;\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> _mat_c;\n}\n<span class=\"hljs-comment\">/**\n * @brief Returns whether matrix `mat` is a [zero\n * matrix.](https://en.wikipedia.org/wiki/Zero_matrix)\n * @tparam T template type for integer as well as floating values, default is\n * long long int\n * @param _mat A matrix\n * @returns true if it is a zero matrix else false\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T = <span class=\"hljs-type\">int64_t</span>&gt;\n<span class=\"hljs-type\">bool</span> <span class=\"hljs-built_in\">is_zero_matrix</span>(<span class=\"hljs-keyword\">const</span> std::vector&lt;std::vector&lt;T&gt;&gt;&amp; _mat) {\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; _mat.<span class=\"hljs-built_in\">size</span>(); ++i) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; _mat[i].<span class=\"hljs-built_in\">size</span>(); ++j) {\n            <span class=\"hljs-keyword\">if</span> (_mat[i][j] != <span class=\"hljs-number\">0</span>) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Implementation of Matrix exponentiation\n * @details returns the matrix exponentiation `(B^n)` in `k^3 * O(log2(power))`\n * time, where `k` is the size of matrix (k by k).\n * @tparam T template type for integer as well as floating values, default is\n * long long int\n * @param _mat matrix for exponentiation\n * @param power the exponent value\n * @returns the matrix _mat to the power `power (_mat^power)`\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T = <span class=\"hljs-type\">int64_t</span>&gt;\nstd::vector&lt;std::vector&lt;T&gt;&gt; <span class=\"hljs-built_in\">matrix_exponentiation</span>(\n    std::vector&lt;std::vector&lt;T&gt;&gt; _mat, <span class=\"hljs-type\">uint64_t</span> power,\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int64_t</span> mod = <span class=\"hljs-number\">1000000007</span>) {\n    <span class=\"hljs-comment\">/**\n     * Initializing answer as identity matrix. For simple binary\n     * exponentiation reference, [see\n     * here](https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/modular_exponentiation.cpp)\n     */</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">is_zero_matrix</span>(_mat)) {\n        <span class=\"hljs-keyword\">return</span> _mat;\n    }\n\n    std::vector&lt;std::vector&lt;T&gt;&gt; _mat_answer(_mat.<span class=\"hljs-built_in\">size</span>(),\n                                            std::<span class=\"hljs-built_in\">vector</span>&lt;T&gt;(_mat.<span class=\"hljs-built_in\">size</span>(), <span class=\"hljs-number\">0</span>));\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; _mat.<span class=\"hljs-built_in\">size</span>(); ++i) {\n        _mat_answer[i][i] = <span class=\"hljs-number\">1</span>;\n    }\n    <span class=\"hljs-comment\">// exponentiation algorithm here.</span>\n    <span class=\"hljs-keyword\">while</span> (power &gt; <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-keyword\">if</span> (power &amp; <span class=\"hljs-number\">1</span>) {\n            _mat_answer = <span class=\"hljs-built_in\">matrix_multiplication</span>(_mat_answer, _mat, mod);\n        }\n        power &gt;&gt;= <span class=\"hljs-number\">1</span>;\n        _mat = <span class=\"hljs-built_in\">matrix_multiplication</span>(_mat, _mat, mod);\n    }\n\n    <span class=\"hljs-keyword\">return</span> _mat_answer;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Implementation of nth recurrence series.\n * @details Returns the nth term in the recurrence series.\n * Note that the function assumes definition of base cases from `n = 0`\n * (e.g., for fibonacci, `f(0)` has a defined value `0`)\n * @tparam T template type for integer as well as floating values, default is\n * long long int\n * @param _mat [square matrix](https://en.m.wikipedia.org/wiki/Square_matrix)\n * that evaluates the nth term using exponentiation\n * @param _base_cases 2D array of dimension `1*n` containing values which are\n * defined for some n (e.g., for fibonacci, `f(0)` and `f(1)` are defined, and\n * `f(n)` where `n &gt; 1` is evaluated on previous two values)\n * @param nth_term the nth term of recurrence relation\n * @param constant_or_sum_included whether the recurrence relation has a\n * constant value or is evaluating sum of first n terms of the recurrence.\n * @returns the nth term of the recurrence relation in `O(k^3. log(n))`, where k\n * is number of rows and columns in `_mat` and `n` is the value of `nth_term`\n * If constant_or_sum_included is true, returns the sum of first n terms in\n * recurrence series\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T = <span class=\"hljs-type\">int64_t</span>&gt;\nT <span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\n    <span class=\"hljs-keyword\">const</span> std::vector&lt;std::vector&lt;T&gt;&gt;&amp; _mat,\n    <span class=\"hljs-keyword\">const</span> std::vector&lt;std::vector&lt;T&gt;&gt;&amp; _base_cases, <span class=\"hljs-type\">uint64_t</span> nth_term,\n    <span class=\"hljs-type\">bool</span> constant_or_sum_included = <span class=\"hljs-literal\">false</span>) {\n    <span class=\"hljs-built_in\">assert</span>(_mat.<span class=\"hljs-built_in\">size</span>() == _base_cases.<span class=\"hljs-built_in\">back</span>().<span class=\"hljs-built_in\">size</span>());\n\n    <span class=\"hljs-comment\">/**\n     * If nth term is a base case, then return base case directly.\n     */</span>\n\n    <span class=\"hljs-keyword\">if</span> (nth_term &lt; _base_cases.<span class=\"hljs-built_in\">back</span>().<span class=\"hljs-built_in\">size</span>() - constant_or_sum_included) {\n        <span class=\"hljs-keyword\">return</span> _base_cases.<span class=\"hljs-built_in\">back</span>()[nth_term - constant_or_sum_included];\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">/**\n         * Else evaluate the expression, so multiplying _mat to itself (n -\n         * base_cases.length + 1 + constant_or_sum_included) times.\n         */</span>\n        std::vector&lt;std::vector&lt;T&gt;&gt; _res_matrix =\n            <span class=\"hljs-built_in\">matrix_exponentiation</span>(_mat, nth_term - _base_cases.<span class=\"hljs-built_in\">back</span>().<span class=\"hljs-built_in\">size</span>() +\n                                            <span class=\"hljs-number\">1</span> + constant_or_sum_included);\n\n        <span class=\"hljs-comment\">/**\n         * After matrix exponentiation, multiply with the base case to evaluate\n         * the answer. The answer is always at the end of the array.\n         */</span>\n        std::vector&lt;std::vector&lt;T&gt;&gt; _res =\n            <span class=\"hljs-built_in\">matrix_multiplication</span>(_base_cases, _res_matrix);\n\n        <span class=\"hljs-keyword\">return</span> _res.<span class=\"hljs-built_in\">back</span>().<span class=\"hljs-built_in\">back</span>();\n    }\n}\n}  <span class=\"hljs-comment\">// namespace linear_recurrence_matrix</span>\n}  <span class=\"hljs-comment\">// namespace math</span>\n\n<span class=\"hljs-comment\">/**\n * @brief Self test-implementations\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">/*\n     * Example 1: [Fibonacci\n     * series](https://en.wikipedia.org/wiki/Fibonacci_number);\n     *\n     * [fn-2    fn-1]  [0      1]  ==   [fn-1   (fn-2 + fn-1)] =&gt; [fn-1   fn]\n     *                 [1      1]\n     *\n     * Let A = [fn-2   fn-1], and B = [0   1]\n     *                                [1   1],\n     *\n     * Since, A.B....(n-1 times) = [fn-1   fn]\n     * we can multiply B with itself n-1 times to obtain the required value\n     */</span>\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt;&gt; fibonacci_matrix = {{<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>}},\n                                      fib_base_case = {{<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}};\n\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\n               fibonacci_matrix, fib_base_case, <span class=\"hljs-number\">11</span>) == <span class=\"hljs-number\">89LL</span>);\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\n               fibonacci_matrix, fib_base_case, <span class=\"hljs-number\">39</span>) == <span class=\"hljs-number\">63245986LL</span>);\n    <span class=\"hljs-comment\">/*\n     * Example 2: [Tribonacci series](https://oeis.org/A000073)\n     *                    [0   0   1]\n     * [fn-3  fn-2  fn-1] [1   0   1]  =  [(fn-2)  (fn-1)  (fn-3 + fn-2 + fn-1)]\n     *                    [0   1   1]\n     *                                 =&gt; [fn-2     fn-1    fn]\n     *\n     *                                       [0   0   1]\n     * Let A = [fn-3   fn-2   fn-1], and B = [1   0   1]\n     *                                       [0   1   1]\n     *\n     * Since, A.B....(n-2 times) = [fn-2  fn-1   fn]\n     * we will have multiply B with itself n-2 times to obtain the required\n     * value ()\n     */</span>\n\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt;&gt; tribonacci = {{<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>},\n                                                    {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>},\n                                                    {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>}},\n                                      trib_base_case = {\n                                          {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}};  <span class=\"hljs-comment\">// f0 = 0, f1 = 0, f2 = 1</span>\n\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\n               tribonacci, trib_base_case, <span class=\"hljs-number\">11</span>) == <span class=\"hljs-number\">149LL</span>);\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\n               tribonacci, trib_base_case, <span class=\"hljs-number\">36</span>) == <span class=\"hljs-number\">615693474LL</span>);\n\n    <span class=\"hljs-comment\">/*\n     * Example 3: [Pell numbers](https://oeis.org/A000129)\n     * `f(n)  = 2* f(n-1) + f(n-2); f(0) = f(1) = 2`\n     *\n     * [fn-2  fn-1] [0   1]  =  [(fn-1)  fn-2 + 2*fn-1)]\n     *              [1   2]\n     *                       =&gt; [fn-1     fn]\n     *\n     * Let A = [fn-2  fn-1], and B = [0   1]\n     *                               [1   2]\n     */</span>\n\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt;&gt; pell_recurrence = {{<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>}},\n                                      pell_base_case = {\n                                          {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>}};  <span class=\"hljs-comment\">// `f0 = 2, f1 = 2`</span>\n\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\n               pell_recurrence, pell_base_case, <span class=\"hljs-number\">15</span>) == <span class=\"hljs-number\">551614LL</span>);\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\n               pell_recurrence, pell_base_case, <span class=\"hljs-number\">23</span>) == <span class=\"hljs-number\">636562078LL</span>);\n\n    <span class=\"hljs-comment\">/*\n     * Example 4: Custom recurrence relation:\n     * Now the recurrence is of the form `a*f(n-1) + b*(fn-2) + ... + c`\n     * where `c` is the constant\n     * `f(n)  = 2* f(n-1) + f(n-2) + 7; f(0) = f(1) = 2, c = 7`\n     *\n     *                   [1   0   1]\n     * [7,  fn-2,  fn-1] [0   0   1]\n     *                   [0   1   2]\n     * =  [7,  (fn-1),  fn-2 + 2*fn-1) + 7]\n     *\n     * =&gt; [7,    fn-1,     fn]\n     * :: Series will be 2, 2, 13, 35, 90, 222, 541, 1311, 3170, 7658, 18493,\n     * 44651, 107802, 260262, 628333, 1516935, 362210, 8841362, 21344941,\n     * 51531251\n     *\n     * Let A = [7,  fn-2,  fn-1], and B = [1   0   1]\n     *                                    [0   0   1]\n     *                                    [0   1   2]\n     */</span>\n\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt;&gt;\n        custom_recurrence = {{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}, {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}, {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>}},\n        custom_base_case = {{<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>}};  <span class=\"hljs-comment\">// `c = 7, f0 = 2, f1 = 2`</span>\n\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\n               custom_recurrence, custom_base_case, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">18493LL</span>);\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\n               custom_recurrence, custom_base_case, <span class=\"hljs-number\">19</span>, <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">51531251LL</span>);\n\n    <span class=\"hljs-comment\">/*\n     * Example 5: Sum fibonacci sequence\n     * The following matrix evaluates the sum of first n fibonacci terms in\n     * O(27. log2(n)) time.\n     * `f(n) = f(n-1) + f(n-2); f(0) = 0, f(1) = 1`\n     *\n     *                           [1   0   0]\n     * [s(f, n-1),  fn-2,  fn-1] [1   0   1]\n     *                           [1   1   1]\n     *   =&gt; [(s(f, n-1)+f(n-2)+f(n-1)), (fn-1),  f(n-2)+f(n-1)]\n     *\n     *   =&gt; [s(f, n-1)+f(n),    fn-1,     fn]\n     *\n     *   =&gt; [s(f, n),    fn-1,     fn]\n     *\n     * Sum of first 20 fibonacci series:\n     * 0, 1, 2, 4, 7, 12, 20, 33, 54, 88, 143, 232, 376, 609, 986, 1596, 2583,\n     * 4180, 6764\n     *          f0  f1  s(f,1)\n     * Let A = [0    1    1], and B = [0   1   1]\n     *                                [1   1   1]\n     *                                [0   0   1]\n     */</span>\n\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt;&gt; sum_fibo_recurrence = {{<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>},\n                                                             {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>},\n                                                             {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}},\n                                      sum_fibo_base_case = {\n                                          {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>}};  <span class=\"hljs-comment\">// `f0 = 0, f1 = 1`</span>\n\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\n               sum_fibo_recurrence, sum_fibo_base_case, <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">609LL</span>);\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\n               sum_fibo_recurrence, sum_fibo_base_case, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">2583LL</span>);\n    <span class=\"hljs-comment\">/*\n     * Example 6: [Tribonacci sum series](https://oeis.org/A000073)\n     *                               [0   0   1   1]\n     * [fn-3  fn-2  fn-1  s(f, n-1)] [1   0   1   1]\n     *                               [0   1   1   1]\n     *                               [0   0   0   1]\n     *\n     * = [fn-2, fn-1, fn-3 + fn-2 + fn-1, (fn-3 + fn-2 + fn-1 + s(f, n-1))]\n     *\n     * =&gt; [fn-2, fn-1, fn,  fn + s(f, n-1)]\n     *\n     * =&gt; [fn-2, fn-1, fn, s(f, n)]\n     *\n     * Sum of the series is: 0, 0, 1, 2, 4, 8, 15, 28, 52, 96, 177, 326, 600,\n     * 1104, 2031, 3736, 6872, 12640, 23249, 42762\n     *\n     * Let A = [fn-3   fn-2   fn-1   s(f, n-1)], and\n     *     [0   0   1   1]\n     * B = [1   0   1   1]\n     *     [0   1   1   1]\n     *     [0   0   0   1]\n     *\n     * Since, A.B....(n-2 times) = [fn-2  fn-1   fn]\n     * we will have multiply B with itself n-2 times to obtain the required\n     * value\n     */</span>\n\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt;&gt; tribonacci_sum = {{<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>},\n                                                        {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>},\n                                                        {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>},\n                                                        {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}},\n                                      trib_sum_base_case = {{<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>}};\n    <span class=\"hljs-comment\">// `f0 = 0, f1 = 0, f2 = 1, s = 1`</span>\n\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\n               tribonacci_sum, trib_sum_base_case, <span class=\"hljs-number\">18</span>, <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">23249LL</span>);\n    <span class=\"hljs-built_in\">assert</span>(math::linear_recurrence_matrix::<span class=\"hljs-built_in\">get_nth_term_of_recurrence_series</span>(\n               tribonacci_sum, trib_sum_base_case, <span class=\"hljs-number\">19</span>, <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">42762LL</span>);\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Main function\n * @returns 0 on exit\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">// run self-test implementations</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [],
  "explanationUrl": {}
}
