{
  "slug": "minimum-spanning-tree-boruvka",
  "name": "Minimum Spanning Tree Boruvka",
  "categories": ["graphs"],
  "body": {},
  "implementations": {
    "python": {
      "dir": "graphs/minimum_spanning_tree_boruvka.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/graphs/minimum_spanning_tree_boruvka.py",
      "code": "<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Graph</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Data structure to store graphs (based on adjacency lists)\r\n    &quot;&quot;&quot;</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self</span>):\r\n\r\n        self.num_vertices = <span class=\"hljs-number\">0</span>\r\n        self.num_edges = <span class=\"hljs-number\">0</span>\r\n        self.adjacency = {}\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add_vertex</span>(<span class=\"hljs-params\">self, vertex</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        Adds a vertex to the graph\r\n\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-keyword\">if</span> vertex <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> self.adjacency:\r\n            self.adjacency[vertex] = {}\r\n            self.num_vertices += <span class=\"hljs-number\">1</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add_edge</span>(<span class=\"hljs-params\">self, head, tail, weight</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        Adds an edge to the graph\r\n\r\n        &quot;&quot;&quot;</span>\r\n\r\n        self.add_vertex(head)\r\n        self.add_vertex(tail)\r\n\r\n        <span class=\"hljs-keyword\">if</span> head == tail:\r\n            <span class=\"hljs-keyword\">return</span>\r\n\r\n        self.adjacency[head][tail] = weight\r\n        self.adjacency[tail][head] = weight\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">distinct_weight</span>(<span class=\"hljs-params\">self</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        For Boruvks&#x27;s algorithm the weights should be distinct\r\n        Converts the weights to be distinct\r\n\r\n        &quot;&quot;&quot;</span>\r\n        edges = self.get_edges()\r\n        <span class=\"hljs-keyword\">for</span> edge <span class=\"hljs-keyword\">in</span> edges:\r\n            head, tail, weight = edge\r\n            edges.remove((tail, head, weight))\r\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(edges)):\r\n            edges[i] = <span class=\"hljs-built_in\">list</span>(edges[i])\r\n\r\n        edges.sort(key=<span class=\"hljs-keyword\">lambda</span> e: e[<span class=\"hljs-number\">2</span>])\r\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(edges) - <span class=\"hljs-number\">1</span>):\r\n            <span class=\"hljs-keyword\">if</span> edges[i][<span class=\"hljs-number\">2</span>] &gt;= edges[i + <span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">2</span>]:\r\n                edges[i + <span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">2</span>] = edges[i][<span class=\"hljs-number\">2</span>] + <span class=\"hljs-number\">1</span>\r\n        <span class=\"hljs-keyword\">for</span> edge <span class=\"hljs-keyword\">in</span> edges:\r\n            head, tail, weight = edge\r\n            self.adjacency[head][tail] = weight\r\n            self.adjacency[tail][head] = weight\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__str__</span>(<span class=\"hljs-params\">self</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        Returns string representation of the graph\r\n        &quot;&quot;&quot;</span>\r\n        string = <span class=\"hljs-string\">&quot;&quot;</span>\r\n        <span class=\"hljs-keyword\">for</span> tail <span class=\"hljs-keyword\">in</span> self.adjacency:\r\n            <span class=\"hljs-keyword\">for</span> head <span class=\"hljs-keyword\">in</span> self.adjacency[tail]:\r\n                weight = self.adjacency[head][tail]\r\n                string += <span class=\"hljs-string\">&quot;%d -&gt; %d == %d\\n&quot;</span> % (head, tail, weight)\r\n        <span class=\"hljs-keyword\">return</span> string.rstrip(<span class=\"hljs-string\">&quot;\\n&quot;</span>)\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_edges</span>(<span class=\"hljs-params\">self</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        Returna all edges in the graph\r\n        &quot;&quot;&quot;</span>\r\n        output = []\r\n        <span class=\"hljs-keyword\">for</span> tail <span class=\"hljs-keyword\">in</span> self.adjacency:\r\n            <span class=\"hljs-keyword\">for</span> head <span class=\"hljs-keyword\">in</span> self.adjacency[tail]:\r\n                output.append((tail, head, self.adjacency[head][tail]))\r\n        <span class=\"hljs-keyword\">return</span> output\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_vertices</span>(<span class=\"hljs-params\">self</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        Returns all vertices in the graph\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-keyword\">return</span> self.adjacency.keys()\r\n\r\n<span class=\"hljs-meta\">    @staticmethod</span>\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">vertices=<span class=\"hljs-literal\">None</span>, edges=<span class=\"hljs-literal\">None</span></span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        Builds a graph from the given set of vertices and edges\r\n\r\n        &quot;&quot;&quot;</span>\r\n        g = Graph()\r\n        <span class=\"hljs-keyword\">if</span> vertices <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:\r\n            vertices = []\r\n        <span class=\"hljs-keyword\">if</span> edges <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:\r\n            edge = []\r\n        <span class=\"hljs-keyword\">for</span> vertex <span class=\"hljs-keyword\">in</span> vertices:\r\n            g.add_vertex(vertex)\r\n        <span class=\"hljs-keyword\">for</span> edge <span class=\"hljs-keyword\">in</span> edges:\r\n            g.add_edge(*edge)\r\n        <span class=\"hljs-keyword\">return</span> g\r\n\r\n    <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UnionFind</span>:\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        Disjoint set Union and Find for Boruvka&#x27;s algorithm\r\n        &quot;&quot;&quot;</span>\r\n\r\n        <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self</span>):\r\n            self.parent = {}\r\n            self.rank = {}\r\n\r\n        <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__len__</span>(<span class=\"hljs-params\">self</span>):\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(self.parent)\r\n\r\n        <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">make_set</span>(<span class=\"hljs-params\">self, item</span>):\r\n            <span class=\"hljs-keyword\">if</span> item <span class=\"hljs-keyword\">in</span> self.parent:\r\n                <span class=\"hljs-keyword\">return</span> self.find(item)\r\n\r\n            self.parent[item] = item\r\n            self.rank[item] = <span class=\"hljs-number\">0</span>\r\n            <span class=\"hljs-keyword\">return</span> item\r\n\r\n        <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">find</span>(<span class=\"hljs-params\">self, item</span>):\r\n            <span class=\"hljs-keyword\">if</span> item <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> self.parent:\r\n                <span class=\"hljs-keyword\">return</span> self.make_set(item)\r\n            <span class=\"hljs-keyword\">if</span> item != self.parent[item]:\r\n                self.parent[item] = self.find(self.parent[item])\r\n            <span class=\"hljs-keyword\">return</span> self.parent[item]\r\n\r\n        <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">union</span>(<span class=\"hljs-params\">self, item1, item2</span>):\r\n            root1 = self.find(item1)\r\n            root2 = self.find(item2)\r\n\r\n            <span class=\"hljs-keyword\">if</span> root1 == root2:\r\n                <span class=\"hljs-keyword\">return</span> root1\r\n\r\n            <span class=\"hljs-keyword\">if</span> self.rank[root1] &gt; self.rank[root2]:\r\n                self.parent[root2] = root1\r\n                <span class=\"hljs-keyword\">return</span> root1\r\n\r\n            <span class=\"hljs-keyword\">if</span> self.rank[root1] &lt; self.rank[root2]:\r\n                self.parent[root1] = root2\r\n                <span class=\"hljs-keyword\">return</span> root2\r\n\r\n            <span class=\"hljs-keyword\">if</span> self.rank[root1] == self.rank[root2]:\r\n                self.rank[root1] += <span class=\"hljs-number\">1</span>\r\n                self.parent[root2] = root1\r\n                <span class=\"hljs-keyword\">return</span> root1\r\n\r\n<span class=\"hljs-meta\">    @staticmethod</span>\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">boruvka_mst</span>(<span class=\"hljs-params\">graph</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        Implementation of Boruvka&#x27;s algorithm\r\n        &gt;&gt;&gt; g = Graph()\r\n        &gt;&gt;&gt; g = Graph.build([0, 1, 2, 3], [[0, 1, 1], [0, 2, 1],[2, 3, 1]])\r\n        &gt;&gt;&gt; g.distinct_weight()\r\n        &gt;&gt;&gt; bg = Graph.boruvka_mst(g)\r\n        &gt;&gt;&gt; print(bg)\r\n        1 -&gt; 0 == 1\r\n        2 -&gt; 0 == 2\r\n        0 -&gt; 1 == 1\r\n        0 -&gt; 2 == 2\r\n        3 -&gt; 2 == 3\r\n        2 -&gt; 3 == 3\r\n        &quot;&quot;&quot;</span>\r\n        num_components = graph.num_vertices\r\n\r\n        union_find = Graph.UnionFind()\r\n        mst_edges = []\r\n        <span class=\"hljs-keyword\">while</span> num_components &gt; <span class=\"hljs-number\">1</span>:\r\n            cheap_edge = {}\r\n            <span class=\"hljs-keyword\">for</span> vertex <span class=\"hljs-keyword\">in</span> graph.get_vertices():\r\n                cheap_edge[vertex] = -<span class=\"hljs-number\">1</span>\r\n\r\n            edges = graph.get_edges()\r\n            <span class=\"hljs-keyword\">for</span> edge <span class=\"hljs-keyword\">in</span> edges:\r\n                head, tail, weight = edge\r\n                edges.remove((tail, head, weight))\r\n            <span class=\"hljs-keyword\">for</span> edge <span class=\"hljs-keyword\">in</span> edges:\r\n                head, tail, weight = edge\r\n                set1 = union_find.find(head)\r\n                set2 = union_find.find(tail)\r\n                <span class=\"hljs-keyword\">if</span> set1 != set2:\r\n                    <span class=\"hljs-keyword\">if</span> cheap_edge[set1] == -<span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">or</span> cheap_edge[set1][<span class=\"hljs-number\">2</span>] &gt; weight:\r\n                        cheap_edge[set1] = [head, tail, weight]\r\n\r\n                    <span class=\"hljs-keyword\">if</span> cheap_edge[set2] == -<span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">or</span> cheap_edge[set2][<span class=\"hljs-number\">2</span>] &gt; weight:\r\n                        cheap_edge[set2] = [head, tail, weight]\r\n            <span class=\"hljs-keyword\">for</span> vertex <span class=\"hljs-keyword\">in</span> cheap_edge:\r\n                <span class=\"hljs-keyword\">if</span> cheap_edge[vertex] != -<span class=\"hljs-number\">1</span>:\r\n                    head, tail, weight = cheap_edge[vertex]\r\n                    <span class=\"hljs-keyword\">if</span> union_find.find(head) != union_find.find(tail):\r\n                        union_find.union(head, tail)\r\n                        mst_edges.append(cheap_edge[vertex])\r\n                        num_components = num_components - <span class=\"hljs-number\">1</span>\r\n        mst = Graph.build(edges=mst_edges)\r\n        <span class=\"hljs-keyword\">return</span> mst\r\n"
    }
  },
  "contributors": [
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 1
    },
    {
      "name": "Hasenn",
      "email": "eliottarloveyrier@live.fr",
      "commits": 1
    },
    {
      "name": "Nitisha Bharathi",
      "email": "30657775+nitishabharathi@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}
