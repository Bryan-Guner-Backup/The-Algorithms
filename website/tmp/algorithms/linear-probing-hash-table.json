{
  "slug": "linear-probing-hash-table",
  "name": "Linear Probing Hash Table",
  "categories": ["hashing"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "hashing/linear_probing_hash_table.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/hashing/linear_probing_hash_table.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * @author [achance6](https://github.com/achance6)\n * @author [Krishna Vedala](https://github.com/kvedala)\n * @brief Storage mechanism using [linear probing\n * hash](https://en.wikipedia.org/wiki/Linear_probing) keys.\n * @note The implementation can be optimized by using OOP style.\n */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\n\n<span class=\"hljs-comment\">/**\n * @addtogroup open_addressing Open Addressing\n * @{\n * @namespace linear_probing\n * @brief An implementation of hash table using [linear\n * probing](https://en.wikipedia.org/wiki/Linear_probing) algorithm.\n */</span>\n<span class=\"hljs-keyword\">namespace</span> linear_probing {\n<span class=\"hljs-comment\">// fwd declarations</span>\n<span class=\"hljs-keyword\">using</span> Entry = <span class=\"hljs-keyword\">struct</span> Entry;\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">putProber</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> Entry&amp; entry, <span class=\"hljs-type\">int</span> key)</span></span>;\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">searchingProber</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> Entry&amp; entry, <span class=\"hljs-type\">int</span> key)</span></span>;\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span></span>;\n\n<span class=\"hljs-comment\">// Undocumented globals</span>\n<span class=\"hljs-type\">int</span> notPresent;\nstd::vector&lt;Entry&gt; table;\n<span class=\"hljs-type\">int</span> totalSize;\n<span class=\"hljs-type\">int</span> tomb = <span class=\"hljs-number\">-1</span>;\n<span class=\"hljs-type\">int</span> size;\n<span class=\"hljs-type\">bool</span> rehashing;\n\n<span class=\"hljs-comment\">/** Node object that holds key */</span>\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Entry</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">Entry</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key = notPresent)</span> : key(key) {</span>}  <span class=\"hljs-comment\">///&lt; constructor</span>\n    <span class=\"hljs-type\">int</span> key;                                            <span class=\"hljs-comment\">///&lt; key value</span>\n};\n\n<span class=\"hljs-comment\">/**\n * @brief Hash a key. Uses the STL library&#x27;s `std::hash()` function.\n *\n * @param key value to hash\n * @return hash value of the key\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">hashFxn</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>{\n    std::hash&lt;<span class=\"hljs-type\">int</span>&gt; hash;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">hash</span>(key);\n}\n\n<span class=\"hljs-comment\">/** Performs linear probing to resolve collisions\n * @param key key value to hash\n * @return hash value of the key\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">linearProbe</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key, <span class=\"hljs-type\">bool</span> searching)</span> </span>{\n    <span class=\"hljs-type\">int</span> hash = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(<span class=\"hljs-built_in\">hashFxn</span>(key));\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;\n    Entry entry;\n    <span class=\"hljs-keyword\">do</span> {\n        <span class=\"hljs-type\">int</span> index = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;((hash + i) % totalSize);\n        entry = table[index];\n        <span class=\"hljs-keyword\">if</span> (searching) {\n            <span class=\"hljs-keyword\">if</span> (entry.key == notPresent) {\n                <span class=\"hljs-keyword\">return</span> notPresent;\n            }\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">searchingProber</span>(entry, key)) {\n                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Found key!&quot;</span> &lt;&lt; std::endl;\n                <span class=\"hljs-keyword\">return</span> index;\n            }\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Found tombstone or equal hash, checking next&quot;</span>\n                      &lt;&lt; std::endl;\n            i++;\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">putProber</span>(entry, key)) {\n                <span class=\"hljs-keyword\">if</span> (!rehashing) {\n                    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Spot found!&quot;</span> &lt;&lt; std::endl;\n                }\n                <span class=\"hljs-keyword\">return</span> index;\n            }\n            <span class=\"hljs-keyword\">if</span> (!rehashing) {\n                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Spot taken, looking at next&quot;</span> &lt;&lt; std::endl;\n            }\n            i++;\n        }\n        <span class=\"hljs-keyword\">if</span> (i == totalSize) {\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Linear probe failed&quot;</span> &lt;&lt; std::endl;\n            <span class=\"hljs-keyword\">return</span> notPresent;\n        }\n    } <span class=\"hljs-keyword\">while</span> (entry.key != notPresent);\n    <span class=\"hljs-keyword\">return</span> notPresent;\n}\n\n<span class=\"hljs-comment\">/** Finds empty spot\n * @param entry instance to check in\n * @param key key value to hash\n * @return hash value of the key\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">putProber</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> Entry&amp; entry, <span class=\"hljs-type\">int</span> key)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (entry.key == notPresent || entry.key == tomb) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n}\n\n<span class=\"hljs-comment\">/** Looks for a matching key\n * @param entry instance to check in\n * @param key key value to hash\n * @return hash value of the key\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">searchingProber</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> Entry&amp; entry, <span class=\"hljs-type\">int</span> key)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (entry.key == key) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n}\n\n<span class=\"hljs-comment\">/** Function to displays the table\n * @returns none\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">display</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; totalSize; i++) {\n        <span class=\"hljs-keyword\">if</span> (table[i].key == notPresent) {\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot; Empty &quot;</span>;\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (table[i].key == tomb) {\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot; Tomb &quot;</span>;\n        } <span class=\"hljs-keyword\">else</span> {\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;\n            std::cout &lt;&lt; table[i].key;\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;\n        }\n    }\n    std::cout &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-comment\">/** Rehashes the table into a bigger table\n * @returns None\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rehash</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// Necessary so wall of add info isn&#x27;t printed all at once</span>\n    rehashing = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-type\">int</span> oldSize = totalSize;\n    <span class=\"hljs-function\">std::vector&lt;Entry&gt; <span class=\"hljs-title\">oldTable</span><span class=\"hljs-params\">(table)</span></span>;\n    <span class=\"hljs-comment\">// Really this should use the next prime number greater than totalSize *</span>\n    <span class=\"hljs-comment\">// 2</span>\n    totalSize *= <span class=\"hljs-number\">2</span>;\n    table = std::<span class=\"hljs-built_in\">vector</span>&lt;Entry&gt;(totalSize);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; oldSize; i++) {\n        <span class=\"hljs-keyword\">if</span> (oldTable[i].key != <span class=\"hljs-number\">-1</span> &amp;&amp; oldTable[i].key != notPresent) {\n            size--;  <span class=\"hljs-comment\">// Size stays the same (add increments size)</span>\n            <span class=\"hljs-built_in\">add</span>(oldTable[i].key);\n        }\n    }\n    <span class=\"hljs-comment\">// delete[] oldTable;</span>\n    rehashing = <span class=\"hljs-literal\">false</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Table was rehashed, new size is: &quot;</span> &lt;&lt; totalSize &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-comment\">/** Adds entry using linear probing. Checks for load factor here\n * @param key key value to hash and add\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>{\n    <span class=\"hljs-type\">int</span> index = <span class=\"hljs-built_in\">linearProbe</span>(key, <span class=\"hljs-literal\">false</span>);\n    table[index].key = key;\n    <span class=\"hljs-comment\">// Load factor greater than 0.5 causes resizing</span>\n    <span class=\"hljs-keyword\">if</span> (++size / <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(totalSize) &gt;= <span class=\"hljs-number\">0.5</span>) {\n        <span class=\"hljs-built_in\">rehash</span>();\n    }\n}\n\n<span class=\"hljs-comment\">/** Removes key. Leaves tombstone upon removal.\n * @param key key value to hash and remove\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>{\n    <span class=\"hljs-type\">int</span> index = <span class=\"hljs-built_in\">linearProbe</span>(key, <span class=\"hljs-literal\">true</span>);\n    <span class=\"hljs-keyword\">if</span> (index == notPresent) {\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;key not found&quot;</span> &lt;&lt; std::endl;\n    }\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Removal Successful, leaving tomb&quot;</span> &lt;&lt; std::endl;\n    table[index].key = tomb;\n    size--;\n}\n\n<span class=\"hljs-comment\">/** Information about the adding process\n * @param key key value to hash and add\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addInfo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>{\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Initial table: &quot;</span>;\n    <span class=\"hljs-built_in\">display</span>();\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;hash of &quot;</span> &lt;&lt; key &lt;&lt; <span class=\"hljs-string\">&quot; is &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">hashFxn</span>(key) &lt;&lt; <span class=\"hljs-string\">&quot; % &quot;</span>\n              &lt;&lt; totalSize &lt;&lt; <span class=\"hljs-string\">&quot; == &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">hashFxn</span>(key) % totalSize;\n    std::cout &lt;&lt; std::endl;\n    <span class=\"hljs-built_in\">add</span>(key);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;New table: &quot;</span>;\n    <span class=\"hljs-built_in\">display</span>();\n}\n\n<span class=\"hljs-comment\">/** Information about removal process\n * @param key key value to hash and remove\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">removalInfo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>{\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Initial table: &quot;</span>;\n    <span class=\"hljs-built_in\">display</span>();\n    std::cout &lt;&lt; std::endl;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;hash of &quot;</span> &lt;&lt; key &lt;&lt; <span class=\"hljs-string\">&quot; is &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">hashFxn</span>(key) &lt;&lt; <span class=\"hljs-string\">&quot; % &quot;</span>\n              &lt;&lt; totalSize &lt;&lt; <span class=\"hljs-string\">&quot; == &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">hashFxn</span>(key) % totalSize;\n    std::cout &lt;&lt; std::endl;\n    <span class=\"hljs-built_in\">remove</span>(key);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;New table: &quot;</span>;\n    <span class=\"hljs-built_in\">display</span>();\n}\n}  <span class=\"hljs-comment\">// namespace linear_probing</span>\n<span class=\"hljs-comment\">/**\n * @}\n */</span>\n\n<span class=\"hljs-keyword\">using</span> linear_probing::Entry;\n<span class=\"hljs-keyword\">using</span> linear_probing::table;\n<span class=\"hljs-keyword\">using</span> linear_probing::totalSize;\n\n<span class=\"hljs-comment\">/** Main function\n * @returns 0 on success\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-type\">int</span> cmd = <span class=\"hljs-number\">0</span>, hash = <span class=\"hljs-number\">0</span>, key = <span class=\"hljs-number\">0</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the initial size of Hash Table. = &quot;</span>;\n    std::cin &gt;&gt; totalSize;\n    table = std::<span class=\"hljs-built_in\">vector</span>&lt;Entry&gt;(totalSize);\n    <span class=\"hljs-type\">bool</span> loop = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-keyword\">while</span> (loop) {\n        std::cout &lt;&lt; std::endl;\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;PLEASE CHOOSE -&quot;</span> &lt;&lt; std::endl;\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;1. Add key. (Numeric only)&quot;</span> &lt;&lt; std::endl;\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;2. Remove key.&quot;</span> &lt;&lt; std::endl;\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;3. Find key.&quot;</span> &lt;&lt; std::endl;\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;4. Generate Hash. (Numeric only)&quot;</span> &lt;&lt; std::endl;\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;5. Display Hash table.&quot;</span> &lt;&lt; std::endl;\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;6. Exit.&quot;</span> &lt;&lt; std::endl;\n        std::cin &gt;&gt; cmd;\n        <span class=\"hljs-built_in\">switch</span> (cmd) {\n            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>:\n                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter key to add = &quot;</span>;\n                std::cin &gt;&gt; key;\n                linear_probing::<span class=\"hljs-built_in\">addInfo</span>(key);\n                <span class=\"hljs-keyword\">break</span>;\n            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">2</span>:\n                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter key to remove = &quot;</span>;\n                std::cin &gt;&gt; key;\n                linear_probing::<span class=\"hljs-built_in\">removalInfo</span>(key);\n                <span class=\"hljs-keyword\">break</span>;\n            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">3</span>: {\n                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter key to search = &quot;</span>;\n                std::cin &gt;&gt; key;\n                Entry entry = table[linear_probing::<span class=\"hljs-built_in\">linearProbe</span>(key, <span class=\"hljs-literal\">true</span>)];\n                <span class=\"hljs-keyword\">if</span> (entry.key == linear_probing::notPresent) {\n                    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Key not present&quot;</span>;\n                }\n                <span class=\"hljs-keyword\">break</span>;\n            }\n            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">4</span>:\n                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter element to generate hash = &quot;</span>;\n                std::cin &gt;&gt; key;\n                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Hash of &quot;</span> &lt;&lt; key\n                          &lt;&lt; <span class=\"hljs-string\">&quot; is = &quot;</span> &lt;&lt; linear_probing::<span class=\"hljs-built_in\">hashFxn</span>(key);\n                <span class=\"hljs-keyword\">break</span>;\n            <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">5</span>:\n                linear_probing::<span class=\"hljs-built_in\">display</span>();\n                <span class=\"hljs-keyword\">break</span>;\n            <span class=\"hljs-keyword\">default</span>:\n                loop = <span class=\"hljs-literal\">false</span>;\n                <span class=\"hljs-keyword\">break</span>;\n                <span class=\"hljs-comment\">// delete[] table;</span>\n        }\n        std::cout &lt;&lt; std::endl;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "achance6",
      "email": "45263295+achance6@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 8
    }
  ],
  "explanationUrl": {}
}
