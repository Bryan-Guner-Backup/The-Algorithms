{
  "slug": "modular-inverse-fermat-little-theorem",
  "name": "Modular Inverse Fermat Little Theorem",
  "categories": ["math"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "math/modular_inverse_fermat_little_theorem.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/math/modular_inverse_fermat_little_theorem.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * @brief C++ Program to find the modular inverse using [Fermat&#x27;s Little\n * Theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem)\n *\n * Fermat&#x27;s Little Theorem state that \\f[ϕ(m) = m-1\\f]\n * where \\f$m\\f$ is a prime number.\n * \\f{eqnarray*}{\n *  a \\cdot x &amp;≡&amp; 1 \\;\\text{mod}\\; m\\\\\n *  x &amp;≡&amp; a^{-1} \\;\\text{mod}\\; m\n * \\f}\n * Using Euler&#x27;s theorem we can modify the equation.\n *\\f[\n * a^{ϕ(m)} ≡ 1 \\;\\text{mod}\\; m\n * \\f]\n * (Where &#x27;^&#x27; denotes the exponent operator)\n *\n * Here &#x27;ϕ&#x27; is Euler&#x27;s Totient Function. For modular inverse existence &#x27;a&#x27; and\n * &#x27;m&#x27; must be relatively primes numbers. To apply Fermat&#x27;s Little Theorem is\n * necessary that &#x27;m&#x27; must be a prime number. Generally in many competitive\n * programming competitions &#x27;m&#x27; is either 1000000007 (1e9+7) or 998244353.\n *\n * We considered m as large prime (1e9+7).\n * \\f$a^{ϕ(m)} ≡ 1 \\;\\text{mod}\\; m\\f$ (Using Euler&#x27;s Theorem)\n * \\f$ϕ(m) = m-1\\f$ using Fermat&#x27;s Little Theorem.\n * \\f$a^{m-1} ≡ 1 \\;\\text{mod}\\; m\\f$\n * Now multiplying both side by \\f$a^{-1}\\f$.\n * \\f{eqnarray*}{\n * a^{m-1} \\cdot a^{-1} &amp;≡&amp; a^{-1} \\;\\text{mod}\\; m\\\\\n * a^{m-2} &amp;≡&amp;  a^{-1} \\;\\text{mod}\\; m\n * \\f}\n *\n * We will find the exponent using binary exponentiation. Such that the\n * algorithm works in \\f$O(\\log m)\\f$ time.\n *\n * Examples: -\n * * a = 3 and m = 7\n * * \\f$a^{-1} \\;\\text{mod}\\; m\\f$ is equivalent to\n * \\f$a^{m-2} \\;\\text{mod}\\; m\\f$\n * * \\f$3^5 \\;\\text{mod}\\; 7 = 243 \\;\\text{mod}\\; 7 = 5\\f$\n * &lt;br/&gt;Hence, \\f$3^{-1} \\;\\text{mod}\\; 7 = 5\\f$\n * or \\f$3 \\times 5  \\;\\text{mod}\\; 7 = 1 \\;\\text{mod}\\; 7\\f$\n * (as \\f$a\\times a^{-1} = 1\\f$)\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\n\n<span class=\"hljs-comment\">/** Recursive function to calculate exponent in \\f$O(\\log n)\\f$ using binary\n * exponent.\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title\">binExpo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> a, <span class=\"hljs-type\">int64_t</span> b, <span class=\"hljs-type\">int64_t</span> m)</span> </span>{\n    a %= m;\n    <span class=\"hljs-type\">int64_t</span> res = <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">while</span> (b &gt; <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-keyword\">if</span> (b % <span class=\"hljs-number\">2</span>) {\n            res = res * a % m;\n        }\n        a = a * a % m;\n        <span class=\"hljs-comment\">// Dividing b by 2 is similar to right shift.</span>\n        b &gt;&gt;= <span class=\"hljs-number\">1</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> res;\n}\n\n<span class=\"hljs-comment\">/** Prime check in \\f$O(\\sqrt{m})\\f$ time.\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isPrime</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> m)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (m &lt;= <span class=\"hljs-number\">1</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int64_t</span> i = <span class=\"hljs-number\">2</span>; i * i &lt;= m; i++) {\n            <span class=\"hljs-keyword\">if</span> (m % i == <span class=\"hljs-number\">0</span>) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * Main function\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-type\">int64_t</span> a, m;\n    <span class=\"hljs-comment\">// Take input of  a and m.</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Computing ((a^(-1))%(m)) using Fermat&#x27;s Little Theorem&quot;</span>;\n    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Give input &#x27;a&#x27; and &#x27;m&#x27; space separated : &quot;</span>;\n    std::cin &gt;&gt; a &gt;&gt; m;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isPrime</span>(m)) {\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;The modular inverse of a with mod m is (a^(m-2)) : &quot;</span>;\n        std::cout &lt;&lt; <span class=\"hljs-built_in\">binExpo</span>(a, m - <span class=\"hljs-number\">2</span>, m) &lt;&lt; std::endl;\n    } <span class=\"hljs-keyword\">else</span> {\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;m must be a prime number.&quot;</span>;\n        std::cout &lt;&lt; std::endl;\n    }\n}\n"
    }
  },
  "contributors": [],
  "explanationUrl": {}
}
