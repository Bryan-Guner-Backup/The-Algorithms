{
  "slug": "2-hidden-layers-neural-network",
  "name": "2 Hidden Layers Neural Network",
  "categories": ["neuralnetwork"],
  "body": {},
  "implementations": {
    "python": {
      "dir": "neural_network/2_hidden_layers_neural_network.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/neural_network/2_hidden_layers_neural_network.py",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;\nReferences:\n    - http://neuralnetworksanddeeplearning.com/chap2.html (Backpropagation)\n    - https://en.wikipedia.org/wiki/Sigmoid_function (Sigmoid activation function)\n    - https://en.wikipedia.org/wiki/Feedforward_neural_network (Feedforward)\n&quot;&quot;&quot;</span>\n\n<span class=\"hljs-keyword\">import</span> numpy\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TwoHiddenLayerNeuralNetwork</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, input_array: numpy.ndarray, output_array: numpy.ndarray</span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        This function initializes the TwoHiddenLayerNeuralNetwork class with random\n        weights for every layer and initializes predicted output with zeroes.\n\n        input_array : input values for training the neural network (i.e training data) .\n        output_array : expected output values of the given inputs.\n        &quot;&quot;&quot;</span>\n\n        <span class=\"hljs-comment\"># Input values provided for training the model.</span>\n        self.input_array = input_array\n\n        <span class=\"hljs-comment\"># Random initial weights are assigned where first argument is the</span>\n        <span class=\"hljs-comment\"># number of nodes in previous layer and second argument is the</span>\n        <span class=\"hljs-comment\"># number of nodes in the next layer.</span>\n\n        <span class=\"hljs-comment\"># Random initial weights are assigned.</span>\n        <span class=\"hljs-comment\"># self.input_array.shape[1] is used to represent number of nodes in input layer.</span>\n        <span class=\"hljs-comment\"># First hidden layer consists of 4 nodes.</span>\n        self.input_layer_and_first_hidden_layer_weights = numpy.random.rand(\n            self.input_array.shape[<span class=\"hljs-number\">1</span>], <span class=\"hljs-number\">4</span>\n        )\n\n        <span class=\"hljs-comment\"># Random initial values for the first hidden layer.</span>\n        <span class=\"hljs-comment\"># First hidden layer has 4 nodes.</span>\n        <span class=\"hljs-comment\"># Second hidden layer has 3 nodes.</span>\n        self.first_hidden_layer_and_second_hidden_layer_weights = numpy.random.rand(\n            <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>\n        )\n\n        <span class=\"hljs-comment\"># Random initial values for the second hidden layer.</span>\n        <span class=\"hljs-comment\"># Second hidden layer has 3 nodes.</span>\n        <span class=\"hljs-comment\"># Output layer has 1 node.</span>\n        self.second_hidden_layer_and_output_layer_weights = numpy.random.rand(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span>)\n\n        <span class=\"hljs-comment\"># Real output values provided.</span>\n        self.output_array = output_array\n\n        <span class=\"hljs-comment\"># Predicted output values by the neural network.</span>\n        <span class=\"hljs-comment\"># Predicted_output array initially consists of zeroes.</span>\n        self.predicted_output = numpy.zeros(output_array.shape)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">feedforward</span>(<span class=\"hljs-params\">self</span>) -&gt; numpy.ndarray:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        The information moves in only one direction i.e. forward from the input nodes,\n        through the two hidden nodes and to the output nodes.\n        There are no cycles or loops in the network.\n\n        Return layer_between_second_hidden_layer_and_output\n            (i.e the last layer of the neural network).\n\n        &gt;&gt;&gt; input_val = numpy.array(([0, 0, 0], [0, 0, 0], [0, 0, 0]), dtype=float)\n        &gt;&gt;&gt; output_val = numpy.array(([0], [0], [0]), dtype=float)\n        &gt;&gt;&gt; nn = TwoHiddenLayerNeuralNetwork(input_val, output_val)\n        &gt;&gt;&gt; res = nn.feedforward()\n        &gt;&gt;&gt; array_sum = numpy.sum(res)\n        &gt;&gt;&gt; numpy.isnan(array_sum)\n        False\n        &quot;&quot;&quot;</span>\n        <span class=\"hljs-comment\"># Layer_between_input_and_first_hidden_layer is the layer connecting the</span>\n        <span class=\"hljs-comment\"># input nodes with the first hidden layer nodes.</span>\n        self.layer_between_input_and_first_hidden_layer = sigmoid(\n            numpy.dot(self.input_array, self.input_layer_and_first_hidden_layer_weights)\n        )\n\n        <span class=\"hljs-comment\"># layer_between_first_hidden_layer_and_second_hidden_layer is the layer</span>\n        <span class=\"hljs-comment\"># connecting the first hidden set of nodes with the second hidden set of nodes.</span>\n        self.layer_between_first_hidden_layer_and_second_hidden_layer = sigmoid(\n            numpy.dot(\n                self.layer_between_input_and_first_hidden_layer,\n                self.first_hidden_layer_and_second_hidden_layer_weights,\n            )\n        )\n\n        <span class=\"hljs-comment\"># layer_between_second_hidden_layer_and_output is the layer connecting</span>\n        <span class=\"hljs-comment\"># second hidden layer with the output node.</span>\n        self.layer_between_second_hidden_layer_and_output = sigmoid(\n            numpy.dot(\n                self.layer_between_first_hidden_layer_and_second_hidden_layer,\n                self.second_hidden_layer_and_output_layer_weights,\n            )\n        )\n\n        <span class=\"hljs-keyword\">return</span> self.layer_between_second_hidden_layer_and_output\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">back_propagation</span>(<span class=\"hljs-params\">self</span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        Function for fine-tuning the weights of the neural net based on the\n        error rate obtained in the previous epoch (i.e., iteration).\n        Updation is done using derivative of sogmoid activation function.\n\n        &gt;&gt;&gt; input_val = numpy.array(([0, 0, 0], [0, 0, 0], [0, 0, 0]), dtype=float)\n        &gt;&gt;&gt; output_val = numpy.array(([0], [0], [0]), dtype=float)\n        &gt;&gt;&gt; nn = TwoHiddenLayerNeuralNetwork(input_val, output_val)\n        &gt;&gt;&gt; res = nn.feedforward()\n        &gt;&gt;&gt; nn.back_propagation()\n        &gt;&gt;&gt; updated_weights = nn.second_hidden_layer_and_output_layer_weights\n        &gt;&gt;&gt; (res == updated_weights).all()\n        False\n        &quot;&quot;&quot;</span>\n\n        updated_second_hidden_layer_and_output_layer_weights = numpy.dot(\n            self.layer_between_first_hidden_layer_and_second_hidden_layer.T,\n            <span class=\"hljs-number\">2</span>\n            * (self.output_array - self.predicted_output)\n            * sigmoid_derivative(self.predicted_output),\n        )\n        updated_first_hidden_layer_and_second_hidden_layer_weights = numpy.dot(\n            self.layer_between_input_and_first_hidden_layer.T,\n            numpy.dot(\n                <span class=\"hljs-number\">2</span>\n                * (self.output_array - self.predicted_output)\n                * sigmoid_derivative(self.predicted_output),\n                self.second_hidden_layer_and_output_layer_weights.T,\n            )\n            * sigmoid_derivative(\n                self.layer_between_first_hidden_layer_and_second_hidden_layer\n            ),\n        )\n        updated_input_layer_and_first_hidden_layer_weights = numpy.dot(\n            self.input_array.T,\n            numpy.dot(\n                numpy.dot(\n                    <span class=\"hljs-number\">2</span>\n                    * (self.output_array - self.predicted_output)\n                    * sigmoid_derivative(self.predicted_output),\n                    self.second_hidden_layer_and_output_layer_weights.T,\n                )\n                * sigmoid_derivative(\n                    self.layer_between_first_hidden_layer_and_second_hidden_layer\n                ),\n                self.first_hidden_layer_and_second_hidden_layer_weights.T,\n            )\n            * sigmoid_derivative(self.layer_between_input_and_first_hidden_layer),\n        )\n\n        self.input_layer_and_first_hidden_layer_weights += (\n            updated_input_layer_and_first_hidden_layer_weights\n        )\n        self.first_hidden_layer_and_second_hidden_layer_weights += (\n            updated_first_hidden_layer_and_second_hidden_layer_weights\n        )\n        self.second_hidden_layer_and_output_layer_weights += (\n            updated_second_hidden_layer_and_output_layer_weights\n        )\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">train</span>(<span class=\"hljs-params\">self, output: numpy.ndarray, iterations: <span class=\"hljs-built_in\">int</span>, give_loss: <span class=\"hljs-built_in\">bool</span></span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        Performs the feedforwarding and back propagation process for the\n        given number of iterations.\n        Every iteration will update the weights of neural network.\n\n        output : real output values,required for calculating loss.\n        iterations : number of times the weights are to be updated.\n        give_loss : boolean value, If True then prints loss for each iteration,\n                    If False then nothing is printed\n\n        &gt;&gt;&gt; input_val = numpy.array(([0, 0, 0], [0, 1, 0], [0, 0, 1]), dtype=float)\n        &gt;&gt;&gt; output_val = numpy.array(([0], [1], [1]), dtype=float)\n        &gt;&gt;&gt; nn = TwoHiddenLayerNeuralNetwork(input_val, output_val)\n        &gt;&gt;&gt; first_iteration_weights = nn.feedforward()\n        &gt;&gt;&gt; nn.back_propagation()\n        &gt;&gt;&gt; updated_weights = nn.second_hidden_layer_and_output_layer_weights\n        &gt;&gt;&gt; (first_iteration_weights == updated_weights).all()\n        False\n        &quot;&quot;&quot;</span>\n        <span class=\"hljs-keyword\">for</span> iteration <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, iterations + <span class=\"hljs-number\">1</span>):\n            self.output = self.feedforward()\n            self.back_propagation()\n            <span class=\"hljs-keyword\">if</span> give_loss:\n                loss = numpy.mean(numpy.square(output - self.feedforward()))\n                <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;Iteration <span class=\"hljs-subst\">{iteration}</span> Loss: <span class=\"hljs-subst\">{loss}</span>&quot;</span>)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">predict</span>(<span class=\"hljs-params\">self, <span class=\"hljs-built_in\">input</span>: numpy.ndarray</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        Predict&#x27;s the output for the given input values using\n        the trained neural network.\n\n        The output value given by the model ranges in-between 0 and 1.\n        The predict function returns 1 if the model value is greater\n        than the threshold value else returns 0,\n        as the real output values are in binary.\n\n        &gt;&gt;&gt; input_val = numpy.array(([0, 0, 0], [0, 1, 0], [0, 0, 1]), dtype=float)\n        &gt;&gt;&gt; output_val = numpy.array(([0], [1], [1]), dtype=float)\n        &gt;&gt;&gt; nn = TwoHiddenLayerNeuralNetwork(input_val, output_val)\n        &gt;&gt;&gt; nn.train(output_val, 1000, False)\n        &gt;&gt;&gt; nn.predict([0,1,0]) in (0, 1)\n        True\n        &quot;&quot;&quot;</span>\n\n        <span class=\"hljs-comment\"># Input values for which the predictions are to be made.</span>\n        self.array = <span class=\"hljs-built_in\">input</span>\n\n        self.layer_between_input_and_first_hidden_layer = sigmoid(\n            numpy.dot(self.array, self.input_layer_and_first_hidden_layer_weights)\n        )\n\n        self.layer_between_first_hidden_layer_and_second_hidden_layer = sigmoid(\n            numpy.dot(\n                self.layer_between_input_and_first_hidden_layer,\n                self.first_hidden_layer_and_second_hidden_layer_weights,\n            )\n        )\n\n        self.layer_between_second_hidden_layer_and_output = sigmoid(\n            numpy.dot(\n                self.layer_between_first_hidden_layer_and_second_hidden_layer,\n                self.second_hidden_layer_and_output_layer_weights,\n            )\n        )\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">int</span>(self.layer_between_second_hidden_layer_and_output &gt; <span class=\"hljs-number\">0.6</span>)\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">sigmoid</span>(<span class=\"hljs-params\">value: numpy.ndarray</span>) -&gt; numpy.ndarray:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Applies sigmoid activation function.\n\n    return normalized values\n\n    &gt;&gt;&gt; sigmoid(numpy.array(([1, 0, 2], [1, 0, 0]), dtype=numpy.float64))\n    array([[0.73105858, 0.5       , 0.88079708],\n           [0.73105858, 0.5       , 0.5       ]])\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span> / (<span class=\"hljs-number\">1</span> + numpy.exp(-value))\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">sigmoid_derivative</span>(<span class=\"hljs-params\">value: numpy.ndarray</span>) -&gt; numpy.ndarray:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Provides the derivative value of the sigmoid function.\n\n    returns derivative of the sigmoid value\n\n    &gt;&gt;&gt; sigmoid_derivative(numpy.array(([1, 0, 2], [1, 0, 0]), dtype=numpy.float64))\n    array([[ 0.,  0., -2.],\n           [ 0.,  0.,  0.]])\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-keyword\">return</span> (value) * (<span class=\"hljs-number\">1</span> - (value))\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">example</span>() -&gt; <span class=\"hljs-built_in\">int</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Example for &quot;how to use the neural network class and use the\n    respected methods for the desired output&quot;.\n    Calls the TwoHiddenLayerNeuralNetwork class and\n    provides the fixed input output values to the model.\n    Model is trained for a fixed amount of iterations then the predict method is called.\n    In this example the output is divided into 2 classes i.e. binary classification,\n    the two classes are represented by &#x27;0&#x27; and &#x27;1&#x27;.\n\n    &gt;&gt;&gt; example() in (0, 1)\n    True\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-comment\"># Input values.</span>\n    <span class=\"hljs-built_in\">input</span> = numpy.array(\n        (\n            [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>],\n            [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>],\n            [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>],\n            [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>],\n            [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>],\n            [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>],\n            [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>],\n            [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>],\n        ),\n        dtype=numpy.float64,\n    )\n\n    <span class=\"hljs-comment\"># True output values for the given input values.</span>\n    output = numpy.array(([<span class=\"hljs-number\">0</span>], [<span class=\"hljs-number\">1</span>], [<span class=\"hljs-number\">1</span>], [<span class=\"hljs-number\">0</span>], [<span class=\"hljs-number\">1</span>], [<span class=\"hljs-number\">0</span>], [<span class=\"hljs-number\">0</span>], [<span class=\"hljs-number\">1</span>]), dtype=numpy.float64)\n\n    <span class=\"hljs-comment\"># Calling neural network class.</span>\n    neural_network = TwoHiddenLayerNeuralNetwork(input_array=<span class=\"hljs-built_in\">input</span>, output_array=output)\n\n    <span class=\"hljs-comment\"># Calling training function.</span>\n    <span class=\"hljs-comment\"># Set give_loss to True if you want to see loss in every iteration.</span>\n    neural_network.train(output=output, iterations=<span class=\"hljs-number\">10</span>, give_loss=<span class=\"hljs-literal\">False</span>)\n\n    <span class=\"hljs-keyword\">return</span> neural_network.predict(numpy.array(([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>]), dtype=numpy.float64))\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    example()\n"
    }
  },
  "contributors": [
    {
      "name": "algobytewise",
      "email": "algobytewise@gmail.com",
      "commits": 1
    },
    {
      "name": "Ramandeep Singh",
      "email": "raman77768@gmail.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}
