{
  "slug": "sequential-minimum-optimization",
  "name": "Sequential Minimum Optimization",
  "categories": ["machinelearning"],
  "body": {},
  "implementations": {
    "python": {
      "dir": "machine_learning/sequential_minimum_optimization.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/machine_learning/sequential_minimum_optimization.py",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Implementation of sequential minimal optimization (SMO) for support vector machines\r\n    (SVM).\r\n\r\n    Sequential minimal optimization (SMO) is an algorithm for solving the quadratic\r\n    programming (QP) problem that arises during the training of support vector\r\n    machines.\r\n    It was invented by John Platt in 1998.\r\n\r\nInput:\r\n    0: type: numpy.ndarray.\r\n    1: first column of ndarray must be tags of samples, must be 1 or -1.\r\n    2: rows of ndarray represent samples.\r\n\r\nUsage:\r\n    Command:\r\n        python3 sequential_minimum_optimization.py\r\n    Code:\r\n        from sequential_minimum_optimization import SmoSVM, Kernel\r\n\r\n        kernel = Kernel(kernel=&#x27;poly&#x27;, degree=3., coef0=1., gamma=0.5)\r\n        init_alphas = np.zeros(train.shape[0])\r\n        SVM = SmoSVM(train=train, alpha_list=init_alphas, kernel_func=kernel, cost=0.4,\r\n                     b=0.0, tolerance=0.001)\r\n        SVM.fit()\r\n        predict = SVM.predict(test_samples)\r\n\r\nReference:\r\n    https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/smo-book.pdf\r\n    https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-98-14.pdf\r\n    http://web.cs.iastate.edu/~honavar/smo-svm.pdf\r\n&quot;&quot;&quot;</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">import</span> os\r\n<span class=\"hljs-keyword\">import</span> sys\r\n<span class=\"hljs-keyword\">import</span> urllib.request\r\n\r\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\r\n<span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd\r\n<span class=\"hljs-keyword\">from</span> matplotlib <span class=\"hljs-keyword\">import</span> pyplot <span class=\"hljs-keyword\">as</span> plt\r\n<span class=\"hljs-keyword\">from</span> sklearn.datasets <span class=\"hljs-keyword\">import</span> make_blobs, make_circles\r\n<span class=\"hljs-keyword\">from</span> sklearn.preprocessing <span class=\"hljs-keyword\">import</span> StandardScaler\r\n\r\nCANCER_DATASET_URL = (\r\n    <span class=\"hljs-string\">&quot;http://archive.ics.uci.edu/ml/machine-learning-databases/&quot;</span>\r\n    <span class=\"hljs-string\">&quot;breast-cancer-wisconsin/wdbc.data&quot;</span>\r\n)\r\n\r\n\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SmoSVM</span>:\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">\r\n        self,\r\n        train,\r\n        kernel_func,\r\n        alpha_list=<span class=\"hljs-literal\">None</span>,\r\n        cost=<span class=\"hljs-number\">0.4</span>,\r\n        b=<span class=\"hljs-number\">0.0</span>,\r\n        tolerance=<span class=\"hljs-number\">0.001</span>,\r\n        auto_norm=<span class=\"hljs-literal\">True</span>,\r\n    </span>):\r\n        self._init = <span class=\"hljs-literal\">True</span>\r\n        self._auto_norm = auto_norm\r\n        self._c = np.float64(cost)\r\n        self._b = np.float64(b)\r\n        self._tol = np.float64(tolerance) <span class=\"hljs-keyword\">if</span> tolerance &gt; <span class=\"hljs-number\">0.0001</span> <span class=\"hljs-keyword\">else</span> np.float64(<span class=\"hljs-number\">0.001</span>)\r\n\r\n        self.tags = train[:, <span class=\"hljs-number\">0</span>]\r\n        self.samples = self._norm(train[:, <span class=\"hljs-number\">1</span>:]) <span class=\"hljs-keyword\">if</span> self._auto_norm <span class=\"hljs-keyword\">else</span> train[:, <span class=\"hljs-number\">1</span>:]\r\n        self.alphas = alpha_list <span class=\"hljs-keyword\">if</span> alpha_list <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">else</span> np.zeros(train.shape[<span class=\"hljs-number\">0</span>])\r\n        self.Kernel = kernel_func\r\n\r\n        self._eps = <span class=\"hljs-number\">0.001</span>\r\n        self._all_samples = <span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">range</span>(self.length))\r\n        self._K_matrix = self._calculate_k_matrix()\r\n        self._error = np.zeros(self.length)\r\n        self._unbound = []\r\n\r\n        self.choose_alpha = self._choose_alphas()\r\n\r\n    <span class=\"hljs-comment\"># Calculate alphas using SMO algorithm</span>\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">fit</span>(<span class=\"hljs-params\">self</span>):\r\n        K = self._k\r\n        state = <span class=\"hljs-literal\">None</span>\r\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\r\n\r\n            <span class=\"hljs-comment\"># 1: Find alpha1, alpha2</span>\r\n            <span class=\"hljs-keyword\">try</span>:\r\n                i1, i2 = self.choose_alpha.send(state)\r\n                state = <span class=\"hljs-literal\">None</span>\r\n            <span class=\"hljs-keyword\">except</span> StopIteration:\r\n                <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Optimization done!\\nEvery sample satisfy the KKT condition!&quot;</span>)\r\n                <span class=\"hljs-keyword\">break</span>\r\n\r\n            <span class=\"hljs-comment\"># 2: calculate new alpha2 and new alpha1</span>\r\n            y1, y2 = self.tags[i1], self.tags[i2]\r\n            a1, a2 = self.alphas[i1].copy(), self.alphas[i2].copy()\r\n            e1, e2 = self._e(i1), self._e(i2)\r\n            args = (i1, i2, a1, a2, e1, e2, y1, y2)\r\n            a1_new, a2_new = self._get_new_alpha(*args)\r\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> a1_new <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">not</span> a2_new:\r\n                state = <span class=\"hljs-literal\">False</span>\r\n                <span class=\"hljs-keyword\">continue</span>\r\n            self.alphas[i1], self.alphas[i2] = a1_new, a2_new\r\n\r\n            <span class=\"hljs-comment\"># 3: update threshold(b)</span>\r\n            b1_new = np.float64(\r\n                -e1\r\n                - y1 * K(i1, i1) * (a1_new - a1)\r\n                - y2 * K(i2, i1) * (a2_new - a2)\r\n                + self._b\r\n            )\r\n            b2_new = np.float64(\r\n                -e2\r\n                - y2 * K(i2, i2) * (a2_new - a2)\r\n                - y1 * K(i1, i2) * (a1_new - a1)\r\n                + self._b\r\n            )\r\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-number\">0.0</span> &lt; a1_new &lt; self._c:\r\n                b = b1_new\r\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-number\">0.0</span> &lt; a2_new &lt; self._c:\r\n                b = b2_new\r\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> (np.float64(<span class=\"hljs-number\">0</span>) &lt; a2_new &lt; self._c) <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">not</span> (\r\n                np.float64(<span class=\"hljs-number\">0</span>) &lt; a1_new &lt; self._c\r\n            ):\r\n                b = (b1_new + b2_new) / <span class=\"hljs-number\">2.0</span>\r\n            b_old = self._b\r\n            self._b = b\r\n\r\n            <span class=\"hljs-comment\"># 4:  update error value,here we only calculate those non-bound samples&#x27;</span>\r\n            <span class=\"hljs-comment\">#     error</span>\r\n            self._unbound = [i <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> self._all_samples <span class=\"hljs-keyword\">if</span> self._is_unbound(i)]\r\n            <span class=\"hljs-keyword\">for</span> s <span class=\"hljs-keyword\">in</span> self.unbound:\r\n                <span class=\"hljs-keyword\">if</span> s == i1 <span class=\"hljs-keyword\">or</span> s == i2:\r\n                    <span class=\"hljs-keyword\">continue</span>\r\n                self._error[s] += (\r\n                    y1 * (a1_new - a1) * K(i1, s)\r\n                    + y2 * (a2_new - a2) * K(i2, s)\r\n                    + (self._b - b_old)\r\n                )\r\n\r\n            <span class=\"hljs-comment\"># if i1 or i2 is non-bound,update there error value to zero</span>\r\n            <span class=\"hljs-keyword\">if</span> self._is_unbound(i1):\r\n                self._error[i1] = <span class=\"hljs-number\">0</span>\r\n            <span class=\"hljs-keyword\">if</span> self._is_unbound(i2):\r\n                self._error[i2] = <span class=\"hljs-number\">0</span>\r\n\r\n    <span class=\"hljs-comment\"># Predict test samles</span>\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">predict</span>(<span class=\"hljs-params\">self, test_samples, classify=<span class=\"hljs-literal\">True</span></span>):\r\n\r\n        <span class=\"hljs-keyword\">if</span> test_samples.shape[<span class=\"hljs-number\">1</span>] &gt; self.samples.shape[<span class=\"hljs-number\">1</span>]:\r\n            <span class=\"hljs-keyword\">raise</span> ValueError(\r\n                <span class=\"hljs-string\">&quot;Test samples&#x27; feature length does not equal to that of train samples&quot;</span>\r\n            )\r\n\r\n        <span class=\"hljs-keyword\">if</span> self._auto_norm:\r\n            test_samples = self._norm(test_samples)\r\n\r\n        results = []\r\n        <span class=\"hljs-keyword\">for</span> test_sample <span class=\"hljs-keyword\">in</span> test_samples:\r\n            result = self._predict(test_sample)\r\n            <span class=\"hljs-keyword\">if</span> classify:\r\n                results.append(<span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">if</span> result &gt; <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">else</span> -<span class=\"hljs-number\">1</span>)\r\n            <span class=\"hljs-keyword\">else</span>:\r\n                results.append(result)\r\n        <span class=\"hljs-keyword\">return</span> np.array(results)\r\n\r\n    <span class=\"hljs-comment\"># Check if alpha violate KKT condition</span>\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_check_obey_kkt</span>(<span class=\"hljs-params\">self, index</span>):\r\n        alphas = self.alphas\r\n        tol = self._tol\r\n        r = self._e(index) * self.tags[index]\r\n        c = self._c\r\n\r\n        <span class=\"hljs-keyword\">return</span> (r &lt; -tol <span class=\"hljs-keyword\">and</span> alphas[index] &lt; c) <span class=\"hljs-keyword\">or</span> (r &gt; tol <span class=\"hljs-keyword\">and</span> alphas[index] &gt; <span class=\"hljs-number\">0.0</span>)\r\n\r\n    <span class=\"hljs-comment\"># Get value calculated from kernel function</span>\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_k</span>(<span class=\"hljs-params\">self, i1, i2</span>):\r\n        <span class=\"hljs-comment\"># for test samples,use Kernel function</span>\r\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">isinstance</span>(i2, np.ndarray):\r\n            <span class=\"hljs-keyword\">return</span> self.Kernel(self.samples[i1], i2)\r\n        <span class=\"hljs-comment\"># for train samples,Kernel values have been saved in matrix</span>\r\n        <span class=\"hljs-keyword\">else</span>:\r\n            <span class=\"hljs-keyword\">return</span> self._K_matrix[i1, i2]\r\n\r\n    <span class=\"hljs-comment\"># Get sample&#x27;s error</span>\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_e</span>(<span class=\"hljs-params\">self, index</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        Two cases:\r\n            1:Sample[index] is non-bound,Fetch error from list: _error\r\n            2:sample[index] is bound,Use predicted value deduct true value: g(xi) - yi\r\n\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-comment\"># get from error data</span>\r\n        <span class=\"hljs-keyword\">if</span> self._is_unbound(index):\r\n            <span class=\"hljs-keyword\">return</span> self._error[index]\r\n        <span class=\"hljs-comment\"># get by g(xi) - yi</span>\r\n        <span class=\"hljs-keyword\">else</span>:\r\n            gx = np.dot(self.alphas * self.tags, self._K_matrix[:, index]) + self._b\r\n            yi = self.tags[index]\r\n            <span class=\"hljs-keyword\">return</span> gx - yi\r\n\r\n    <span class=\"hljs-comment\"># Calculate Kernel matrix of all possible i1,i2 ,saving time</span>\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_calculate_k_matrix</span>(<span class=\"hljs-params\">self</span>):\r\n        k_matrix = np.zeros([self.length, self.length])\r\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> self._all_samples:\r\n            <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> self._all_samples:\r\n                k_matrix[i, j] = np.float64(\r\n                    self.Kernel(self.samples[i, :], self.samples[j, :])\r\n                )\r\n        <span class=\"hljs-keyword\">return</span> k_matrix\r\n\r\n    <span class=\"hljs-comment\"># Predict test sample&#x27;s tag</span>\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_predict</span>(<span class=\"hljs-params\">self, sample</span>):\r\n        k = self._k\r\n        predicted_value = (\r\n            np.<span class=\"hljs-built_in\">sum</span>(\r\n                [\r\n                    self.alphas[i1] * self.tags[i1] * k(i1, sample)\r\n                    <span class=\"hljs-keyword\">for</span> i1 <span class=\"hljs-keyword\">in</span> self._all_samples\r\n                ]\r\n            )\r\n            + self._b\r\n        )\r\n        <span class=\"hljs-keyword\">return</span> predicted_value\r\n\r\n    <span class=\"hljs-comment\"># Choose alpha1 and alpha2</span>\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_choose_alphas</span>(<span class=\"hljs-params\">self</span>):\r\n        locis = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-keyword\">from</span> self._choose_a1()\r\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> locis:\r\n            <span class=\"hljs-keyword\">return</span>\r\n        <span class=\"hljs-keyword\">return</span> locis\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_choose_a1</span>(<span class=\"hljs-params\">self</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        Choose first alpha ;steps:\r\n           1:First loop over all sample\r\n           2:Second loop over all non-bound samples till all non-bound samples does not\r\n               voilate kkt condition.\r\n           3:Repeat this two process endlessly,till all samples does not voilate kkt\r\n               condition samples after first loop.\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\r\n            all_not_obey = <span class=\"hljs-literal\">True</span>\r\n            <span class=\"hljs-comment\"># all sample</span>\r\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;scanning all sample!&quot;</span>)\r\n            <span class=\"hljs-keyword\">for</span> i1 <span class=\"hljs-keyword\">in</span> [i <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> self._all_samples <span class=\"hljs-keyword\">if</span> self._check_obey_kkt(i)]:\r\n                all_not_obey = <span class=\"hljs-literal\">False</span>\r\n                <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-keyword\">from</span> self._choose_a2(i1)\r\n\r\n            <span class=\"hljs-comment\"># non-bound sample</span>\r\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;scanning non-bound sample!&quot;</span>)\r\n            <span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\r\n                not_obey = <span class=\"hljs-literal\">True</span>\r\n                <span class=\"hljs-keyword\">for</span> i1 <span class=\"hljs-keyword\">in</span> [\r\n                    i\r\n                    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> self._all_samples\r\n                    <span class=\"hljs-keyword\">if</span> self._check_obey_kkt(i) <span class=\"hljs-keyword\">and</span> self._is_unbound(i)\r\n                ]:\r\n                    not_obey = <span class=\"hljs-literal\">False</span>\r\n                    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-keyword\">from</span> self._choose_a2(i1)\r\n                <span class=\"hljs-keyword\">if</span> not_obey:\r\n                    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;all non-bound samples fit the KKT condition!&quot;</span>)\r\n                    <span class=\"hljs-keyword\">break</span>\r\n            <span class=\"hljs-keyword\">if</span> all_not_obey:\r\n                <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;all samples fit the KKT condition! Optimization done!&quot;</span>)\r\n                <span class=\"hljs-keyword\">break</span>\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_choose_a2</span>(<span class=\"hljs-params\">self, i1</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        Choose the second alpha by using heuristic algorithm ;steps:\r\n           1: Choose alpha2 which gets the maximum step size (|E1 - E2|).\r\n           2: Start in a random point,loop over all non-bound samples till alpha1 and\r\n               alpha2 are optimized.\r\n           3: Start in a random point,loop over all samples till alpha1 and alpha2 are\r\n               optimized.\r\n        &quot;&quot;&quot;</span>\r\n        self._unbound = [i <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> self._all_samples <span class=\"hljs-keyword\">if</span> self._is_unbound(i)]\r\n\r\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(self.unbound) &gt; <span class=\"hljs-number\">0</span>:\r\n            tmp_error = self._error.copy().tolist()\r\n            tmp_error_dict = {\r\n                index: value\r\n                <span class=\"hljs-keyword\">for</span> index, value <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(tmp_error)\r\n                <span class=\"hljs-keyword\">if</span> self._is_unbound(index)\r\n            }\r\n            <span class=\"hljs-keyword\">if</span> self._e(i1) &gt;= <span class=\"hljs-number\">0</span>:\r\n                i2 = <span class=\"hljs-built_in\">min</span>(tmp_error_dict, key=<span class=\"hljs-keyword\">lambda</span> index: tmp_error_dict[index])\r\n            <span class=\"hljs-keyword\">else</span>:\r\n                i2 = <span class=\"hljs-built_in\">max</span>(tmp_error_dict, key=<span class=\"hljs-keyword\">lambda</span> index: tmp_error_dict[index])\r\n            cmd = <span class=\"hljs-keyword\">yield</span> i1, i2\r\n            <span class=\"hljs-keyword\">if</span> cmd <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:\r\n                <span class=\"hljs-keyword\">return</span>\r\n\r\n        <span class=\"hljs-keyword\">for</span> i2 <span class=\"hljs-keyword\">in</span> np.roll(self.unbound, np.random.choice(self.length)):\r\n            cmd = <span class=\"hljs-keyword\">yield</span> i1, i2\r\n            <span class=\"hljs-keyword\">if</span> cmd <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:\r\n                <span class=\"hljs-keyword\">return</span>\r\n\r\n        <span class=\"hljs-keyword\">for</span> i2 <span class=\"hljs-keyword\">in</span> np.roll(self._all_samples, np.random.choice(self.length)):\r\n            cmd = <span class=\"hljs-keyword\">yield</span> i1, i2\r\n            <span class=\"hljs-keyword\">if</span> cmd <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:\r\n                <span class=\"hljs-keyword\">return</span>\r\n\r\n    <span class=\"hljs-comment\"># Get the new alpha2 and new alpha1</span>\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_get_new_alpha</span>(<span class=\"hljs-params\">self, i1, i2, a1, a2, e1, e2, y1, y2</span>):\r\n        K = self._k\r\n        <span class=\"hljs-keyword\">if</span> i1 == i2:\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span>, <span class=\"hljs-literal\">None</span>\r\n\r\n        <span class=\"hljs-comment\"># calculate L and H  which bound the new alpha2</span>\r\n        s = y1 * y2\r\n        <span class=\"hljs-keyword\">if</span> s == -<span class=\"hljs-number\">1</span>:\r\n            L, H = <span class=\"hljs-built_in\">max</span>(<span class=\"hljs-number\">0.0</span>, a2 - a1), <span class=\"hljs-built_in\">min</span>(self._c, self._c + a2 - a1)\r\n        <span class=\"hljs-keyword\">else</span>:\r\n            L, H = <span class=\"hljs-built_in\">max</span>(<span class=\"hljs-number\">0.0</span>, a2 + a1 - self._c), <span class=\"hljs-built_in\">min</span>(self._c, a2 + a1)\r\n        <span class=\"hljs-keyword\">if</span> L == H:\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span>, <span class=\"hljs-literal\">None</span>\r\n\r\n        <span class=\"hljs-comment\"># calculate eta</span>\r\n        k11 = K(i1, i1)\r\n        k22 = K(i2, i2)\r\n        k12 = K(i1, i2)\r\n        eta = k11 + k22 - <span class=\"hljs-number\">2.0</span> * k12\r\n\r\n        <span class=\"hljs-comment\"># select the new alpha2 which could get the minimal objectives</span>\r\n        <span class=\"hljs-keyword\">if</span> eta &gt; <span class=\"hljs-number\">0.0</span>:\r\n            a2_new_unc = a2 + (y2 * (e1 - e2)) / eta\r\n            <span class=\"hljs-comment\"># a2_new has a boundary</span>\r\n            <span class=\"hljs-keyword\">if</span> a2_new_unc &gt;= H:\r\n                a2_new = H\r\n            <span class=\"hljs-keyword\">elif</span> a2_new_unc &lt;= L:\r\n                a2_new = L\r\n            <span class=\"hljs-keyword\">else</span>:\r\n                a2_new = a2_new_unc\r\n        <span class=\"hljs-keyword\">else</span>:\r\n            b = self._b\r\n            l1 = a1 + s * (a2 - L)\r\n            h1 = a1 + s * (a2 - H)\r\n\r\n            <span class=\"hljs-comment\"># way 1</span>\r\n            f1 = y1 * (e1 + b) - a1 * K(i1, i1) - s * a2 * K(i1, i2)\r\n            f2 = y2 * (e2 + b) - a2 * K(i2, i2) - s * a1 * K(i1, i2)\r\n            ol = (\r\n                l1 * f1\r\n                + L * f2\r\n                + <span class=\"hljs-number\">1</span> / <span class=\"hljs-number\">2</span> * l1 ** <span class=\"hljs-number\">2</span> * K(i1, i1)\r\n                + <span class=\"hljs-number\">1</span> / <span class=\"hljs-number\">2</span> * L ** <span class=\"hljs-number\">2</span> * K(i2, i2)\r\n                + s * L * l1 * K(i1, i2)\r\n            )\r\n            oh = (\r\n                h1 * f1\r\n                + H * f2\r\n                + <span class=\"hljs-number\">1</span> / <span class=\"hljs-number\">2</span> * h1 ** <span class=\"hljs-number\">2</span> * K(i1, i1)\r\n                + <span class=\"hljs-number\">1</span> / <span class=\"hljs-number\">2</span> * H ** <span class=\"hljs-number\">2</span> * K(i2, i2)\r\n                + s * H * h1 * K(i1, i2)\r\n            )\r\n            <span class=\"hljs-string\">&quot;&quot;&quot;\r\n            # way 2\r\n            Use objective function check which alpha2 new could get the minimal\r\n            objectives\r\n            &quot;&quot;&quot;</span>\r\n            <span class=\"hljs-keyword\">if</span> ol &lt; (oh - self._eps):\r\n                a2_new = L\r\n            <span class=\"hljs-keyword\">elif</span> ol &gt; oh + self._eps:\r\n                a2_new = H\r\n            <span class=\"hljs-keyword\">else</span>:\r\n                a2_new = a2\r\n\r\n        <span class=\"hljs-comment\"># a1_new has a boundary too</span>\r\n        a1_new = a1 + s * (a2 - a2_new)\r\n        <span class=\"hljs-keyword\">if</span> a1_new &lt; <span class=\"hljs-number\">0</span>:\r\n            a2_new += s * a1_new\r\n            a1_new = <span class=\"hljs-number\">0</span>\r\n        <span class=\"hljs-keyword\">if</span> a1_new &gt; self._c:\r\n            a2_new += s * (a1_new - self._c)\r\n            a1_new = self._c\r\n\r\n        <span class=\"hljs-keyword\">return</span> a1_new, a2_new\r\n\r\n    <span class=\"hljs-comment\"># Normalise data using min_max way</span>\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_norm</span>(<span class=\"hljs-params\">self, data</span>):\r\n        <span class=\"hljs-keyword\">if</span> self._init:\r\n            self._<span class=\"hljs-built_in\">min</span> = np.<span class=\"hljs-built_in\">min</span>(data, axis=<span class=\"hljs-number\">0</span>)\r\n            self._<span class=\"hljs-built_in\">max</span> = np.<span class=\"hljs-built_in\">max</span>(data, axis=<span class=\"hljs-number\">0</span>)\r\n            self._init = <span class=\"hljs-literal\">False</span>\r\n            <span class=\"hljs-keyword\">return</span> (data - self._<span class=\"hljs-built_in\">min</span>) / (self._<span class=\"hljs-built_in\">max</span> - self._<span class=\"hljs-built_in\">min</span>)\r\n        <span class=\"hljs-keyword\">else</span>:\r\n            <span class=\"hljs-keyword\">return</span> (data - self._<span class=\"hljs-built_in\">min</span>) / (self._<span class=\"hljs-built_in\">max</span> - self._<span class=\"hljs-built_in\">min</span>)\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_is_unbound</span>(<span class=\"hljs-params\">self, index</span>):\r\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-number\">0.0</span> &lt; self.alphas[index] &lt; self._c:\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\r\n        <span class=\"hljs-keyword\">else</span>:\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_is_support</span>(<span class=\"hljs-params\">self, index</span>):\r\n        <span class=\"hljs-keyword\">if</span> self.alphas[index] &gt; <span class=\"hljs-number\">0</span>:\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\r\n        <span class=\"hljs-keyword\">else</span>:\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\r\n\r\n<span class=\"hljs-meta\">    @property</span>\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">unbound</span>(<span class=\"hljs-params\">self</span>):\r\n        <span class=\"hljs-keyword\">return</span> self._unbound\r\n\r\n<span class=\"hljs-meta\">    @property</span>\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">support</span>(<span class=\"hljs-params\">self</span>):\r\n        <span class=\"hljs-keyword\">return</span> [i <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(self.length) <span class=\"hljs-keyword\">if</span> self._is_support(i)]\r\n\r\n<span class=\"hljs-meta\">    @property</span>\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">length</span>(<span class=\"hljs-params\">self</span>):\r\n        <span class=\"hljs-keyword\">return</span> self.samples.shape[<span class=\"hljs-number\">0</span>]\r\n\r\n\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Kernel</span>:\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, kernel, degree=<span class=\"hljs-number\">1.0</span>, coef0=<span class=\"hljs-number\">0.0</span>, gamma=<span class=\"hljs-number\">1.0</span></span>):\r\n        self.degree = np.float64(degree)\r\n        self.coef0 = np.float64(coef0)\r\n        self.gamma = np.float64(gamma)\r\n        self._kernel_name = kernel\r\n        self._kernel = self._get_kernel(kernel_name=kernel)\r\n        self._check()\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_polynomial</span>(<span class=\"hljs-params\">self, v1, v2</span>):\r\n        <span class=\"hljs-keyword\">return</span> (self.gamma * np.inner(v1, v2) + self.coef0) ** self.degree\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_linear</span>(<span class=\"hljs-params\">self, v1, v2</span>):\r\n        <span class=\"hljs-keyword\">return</span> np.inner(v1, v2) + self.coef0\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_rbf</span>(<span class=\"hljs-params\">self, v1, v2</span>):\r\n        <span class=\"hljs-keyword\">return</span> np.exp(-<span class=\"hljs-number\">1</span> * (self.gamma * np.linalg.norm(v1 - v2) ** <span class=\"hljs-number\">2</span>))\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_check</span>(<span class=\"hljs-params\">self</span>):\r\n        <span class=\"hljs-keyword\">if</span> self._kernel == self._rbf:\r\n            <span class=\"hljs-keyword\">if</span> self.gamma &lt; <span class=\"hljs-number\">0</span>:\r\n                <span class=\"hljs-keyword\">raise</span> ValueError(<span class=\"hljs-string\">&quot;gamma value must greater than 0&quot;</span>)\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_get_kernel</span>(<span class=\"hljs-params\">self, kernel_name</span>):\r\n        maps = {<span class=\"hljs-string\">&quot;linear&quot;</span>: self._linear, <span class=\"hljs-string\">&quot;poly&quot;</span>: self._polynomial, <span class=\"hljs-string\">&quot;rbf&quot;</span>: self._rbf}\r\n        <span class=\"hljs-keyword\">return</span> maps[kernel_name]\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__call__</span>(<span class=\"hljs-params\">self, v1, v2</span>):\r\n        <span class=\"hljs-keyword\">return</span> self._kernel(v1, v2)\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__repr__</span>(<span class=\"hljs-params\">self</span>):\r\n        <span class=\"hljs-keyword\">return</span> self._kernel_name\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">count_time</span>(<span class=\"hljs-params\">func</span>):\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">call_func</span>(<span class=\"hljs-params\">*args, **kwargs</span>):\r\n        <span class=\"hljs-keyword\">import</span> time\r\n\r\n        start_time = time.time()\r\n        func(*args, **kwargs)\r\n        end_time = time.time()\r\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;smo algorithm cost <span class=\"hljs-subst\">{end_time - start_time}</span> seconds&quot;</span>)\r\n\r\n    <span class=\"hljs-keyword\">return</span> call_func\r\n\r\n\r\n<span class=\"hljs-meta\">@count_time</span>\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">test_cancel_data</span>():\r\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Hello!\\nStart test svm by smo algorithm!&quot;</span>)\r\n    <span class=\"hljs-comment\"># 0: download dataset and load into pandas&#x27; dataframe</span>\r\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> os.path.exists(<span class=\"hljs-string\">r&quot;cancel_data.csv&quot;</span>):\r\n        request = urllib.request.Request(\r\n            CANCER_DATASET_URL,\r\n            headers={<span class=\"hljs-string\">&quot;User-Agent&quot;</span>: <span class=\"hljs-string\">&quot;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&quot;</span>},\r\n        )\r\n        response = urllib.request.urlopen(request)\r\n        content = response.read().decode(<span class=\"hljs-string\">&quot;utf-8&quot;</span>)\r\n        <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(<span class=\"hljs-string\">r&quot;cancel_data.csv&quot;</span>, <span class=\"hljs-string\">&quot;w&quot;</span>) <span class=\"hljs-keyword\">as</span> f:\r\n            f.write(content)\r\n\r\n    data = pd.read_csv(<span class=\"hljs-string\">r&quot;cancel_data.csv&quot;</span>, header=<span class=\"hljs-literal\">None</span>)\r\n\r\n    <span class=\"hljs-comment\"># 1: pre-processing data</span>\r\n    <span class=\"hljs-keyword\">del</span> data[data.columns.tolist()[<span class=\"hljs-number\">0</span>]]\r\n    data = data.dropna(axis=<span class=\"hljs-number\">0</span>)\r\n    data = data.replace({<span class=\"hljs-string\">&quot;M&quot;</span>: np.float64(<span class=\"hljs-number\">1</span>), <span class=\"hljs-string\">&quot;B&quot;</span>: np.float64(-<span class=\"hljs-number\">1</span>)})\r\n    samples = np.array(data)[:, :]\r\n\r\n    <span class=\"hljs-comment\"># 2: dividing data into train_data data and test_data data</span>\r\n    train_data, test_data = samples[:<span class=\"hljs-number\">328</span>, :], samples[<span class=\"hljs-number\">328</span>:, :]\r\n    test_tags, test_samples = test_data[:, <span class=\"hljs-number\">0</span>], test_data[:, <span class=\"hljs-number\">1</span>:]\r\n\r\n    <span class=\"hljs-comment\"># 3: choose kernel function,and set initial alphas to zero(optional)</span>\r\n    mykernel = Kernel(kernel=<span class=\"hljs-string\">&quot;rbf&quot;</span>, degree=<span class=\"hljs-number\">5</span>, coef0=<span class=\"hljs-number\">1</span>, gamma=<span class=\"hljs-number\">0.5</span>)\r\n    al = np.zeros(train_data.shape[<span class=\"hljs-number\">0</span>])\r\n\r\n    <span class=\"hljs-comment\"># 4: calculating best alphas using SMO algorithm and predict test_data samples</span>\r\n    mysvm = SmoSVM(\r\n        train=train_data,\r\n        kernel_func=mykernel,\r\n        alpha_list=al,\r\n        cost=<span class=\"hljs-number\">0.4</span>,\r\n        b=<span class=\"hljs-number\">0.0</span>,\r\n        tolerance=<span class=\"hljs-number\">0.001</span>,\r\n    )\r\n    mysvm.fit()\r\n    predict = mysvm.predict(test_samples)\r\n\r\n    <span class=\"hljs-comment\"># 5: check accuracy</span>\r\n    score = <span class=\"hljs-number\">0</span>\r\n    test_num = test_tags.shape[<span class=\"hljs-number\">0</span>]\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(test_tags.shape[<span class=\"hljs-number\">0</span>]):\r\n        <span class=\"hljs-keyword\">if</span> test_tags[i] == predict[i]:\r\n            score += <span class=\"hljs-number\">1</span>\r\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;\\nall: <span class=\"hljs-subst\">{test_num}</span>\\nright: <span class=\"hljs-subst\">{score}</span>\\nfalse: <span class=\"hljs-subst\">{test_num - score}</span>&quot;</span>)\r\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;Rough Accuracy: <span class=\"hljs-subst\">{score / test_tags.shape[<span class=\"hljs-number\">0</span>]}</span>&quot;</span>)\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">test_demonstration</span>():\r\n    <span class=\"hljs-comment\"># change stdout</span>\r\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;\\nStart plot,please wait!!!&quot;</span>)\r\n    sys.stdout = <span class=\"hljs-built_in\">open</span>(os.devnull, <span class=\"hljs-string\">&quot;w&quot;</span>)\r\n\r\n    ax1 = plt.subplot2grid((<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>), (<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>))\r\n    ax2 = plt.subplot2grid((<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>), (<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>))\r\n    ax3 = plt.subplot2grid((<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>), (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>))\r\n    ax4 = plt.subplot2grid((<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>), (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>))\r\n    ax1.set_title(<span class=\"hljs-string\">&quot;linear svm,cost:0.1&quot;</span>)\r\n    test_linear_kernel(ax1, cost=<span class=\"hljs-number\">0.1</span>)\r\n    ax2.set_title(<span class=\"hljs-string\">&quot;linear svm,cost:500&quot;</span>)\r\n    test_linear_kernel(ax2, cost=<span class=\"hljs-number\">500</span>)\r\n    ax3.set_title(<span class=\"hljs-string\">&quot;rbf kernel svm,cost:0.1&quot;</span>)\r\n    test_rbf_kernel(ax3, cost=<span class=\"hljs-number\">0.1</span>)\r\n    ax4.set_title(<span class=\"hljs-string\">&quot;rbf kernel svm,cost:500&quot;</span>)\r\n    test_rbf_kernel(ax4, cost=<span class=\"hljs-number\">500</span>)\r\n\r\n    sys.stdout = sys.__stdout__\r\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Plot done!!!&quot;</span>)\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">test_linear_kernel</span>(<span class=\"hljs-params\">ax, cost</span>):\r\n    train_x, train_y = make_blobs(\r\n        n_samples=<span class=\"hljs-number\">500</span>, centers=<span class=\"hljs-number\">2</span>, n_features=<span class=\"hljs-number\">2</span>, random_state=<span class=\"hljs-number\">1</span>\r\n    )\r\n    train_y[train_y == <span class=\"hljs-number\">0</span>] = -<span class=\"hljs-number\">1</span>\r\n    scaler = StandardScaler()\r\n    train_x_scaled = scaler.fit_transform(train_x, train_y)\r\n    train_data = np.hstack((train_y.reshape(<span class=\"hljs-number\">500</span>, <span class=\"hljs-number\">1</span>), train_x_scaled))\r\n    mykernel = Kernel(kernel=<span class=\"hljs-string\">&quot;linear&quot;</span>, degree=<span class=\"hljs-number\">5</span>, coef0=<span class=\"hljs-number\">1</span>, gamma=<span class=\"hljs-number\">0.5</span>)\r\n    mysvm = SmoSVM(\r\n        train=train_data,\r\n        kernel_func=mykernel,\r\n        cost=cost,\r\n        tolerance=<span class=\"hljs-number\">0.001</span>,\r\n        auto_norm=<span class=\"hljs-literal\">False</span>,\r\n    )\r\n    mysvm.fit()\r\n    plot_partition_boundary(mysvm, train_data, ax=ax)\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">test_rbf_kernel</span>(<span class=\"hljs-params\">ax, cost</span>):\r\n    train_x, train_y = make_circles(\r\n        n_samples=<span class=\"hljs-number\">500</span>, noise=<span class=\"hljs-number\">0.1</span>, factor=<span class=\"hljs-number\">0.1</span>, random_state=<span class=\"hljs-number\">1</span>\r\n    )\r\n    train_y[train_y == <span class=\"hljs-number\">0</span>] = -<span class=\"hljs-number\">1</span>\r\n    scaler = StandardScaler()\r\n    train_x_scaled = scaler.fit_transform(train_x, train_y)\r\n    train_data = np.hstack((train_y.reshape(<span class=\"hljs-number\">500</span>, <span class=\"hljs-number\">1</span>), train_x_scaled))\r\n    mykernel = Kernel(kernel=<span class=\"hljs-string\">&quot;rbf&quot;</span>, degree=<span class=\"hljs-number\">5</span>, coef0=<span class=\"hljs-number\">1</span>, gamma=<span class=\"hljs-number\">0.5</span>)\r\n    mysvm = SmoSVM(\r\n        train=train_data,\r\n        kernel_func=mykernel,\r\n        cost=cost,\r\n        tolerance=<span class=\"hljs-number\">0.001</span>,\r\n        auto_norm=<span class=\"hljs-literal\">False</span>,\r\n    )\r\n    mysvm.fit()\r\n    plot_partition_boundary(mysvm, train_data, ax=ax)\r\n\r\n\r\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">plot_partition_boundary</span>(<span class=\"hljs-params\">\r\n    model, train_data, ax, resolution=<span class=\"hljs-number\">100</span>, colors=(<span class=\"hljs-params\"><span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-string\">&quot;k&quot;</span>, <span class=\"hljs-string\">&quot;r&quot;</span></span>)\r\n</span>):\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    We can not get the optimum w of our kernel svm model which is different from linear\r\n    svm.  For this reason, we generate randomly distributed points with high desity and\r\n    prediced values of these points are calculated by using our tained model. Then we\r\n    could use this prediced values to draw contour map.\r\n    And this contour map can represent svm&#x27;s partition boundary.\r\n    &quot;&quot;&quot;</span>\r\n    train_data_x = train_data[:, <span class=\"hljs-number\">1</span>]\r\n    train_data_y = train_data[:, <span class=\"hljs-number\">2</span>]\r\n    train_data_tags = train_data[:, <span class=\"hljs-number\">0</span>]\r\n    xrange = np.linspace(train_data_x.<span class=\"hljs-built_in\">min</span>(), train_data_x.<span class=\"hljs-built_in\">max</span>(), resolution)\r\n    yrange = np.linspace(train_data_y.<span class=\"hljs-built_in\">min</span>(), train_data_y.<span class=\"hljs-built_in\">max</span>(), resolution)\r\n    test_samples = np.array([(x, y) <span class=\"hljs-keyword\">for</span> x <span class=\"hljs-keyword\">in</span> xrange <span class=\"hljs-keyword\">for</span> y <span class=\"hljs-keyword\">in</span> yrange]).reshape(\r\n        resolution * resolution, <span class=\"hljs-number\">2</span>\r\n    )\r\n\r\n    test_tags = model.predict(test_samples, classify=<span class=\"hljs-literal\">False</span>)\r\n    grid = test_tags.reshape((<span class=\"hljs-built_in\">len</span>(xrange), <span class=\"hljs-built_in\">len</span>(yrange)))\r\n\r\n    <span class=\"hljs-comment\"># Plot contour map which represents the partition boundary</span>\r\n    ax.contour(\r\n        xrange,\r\n        yrange,\r\n        np.mat(grid).T,\r\n        levels=(-<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>),\r\n        linestyles=(<span class=\"hljs-string\">&quot;--&quot;</span>, <span class=\"hljs-string\">&quot;-&quot;</span>, <span class=\"hljs-string\">&quot;--&quot;</span>),\r\n        linewidths=(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>),\r\n        colors=colors,\r\n    )\r\n    <span class=\"hljs-comment\"># Plot all train samples</span>\r\n    ax.scatter(\r\n        train_data_x,\r\n        train_data_y,\r\n        c=train_data_tags,\r\n        cmap=plt.cm.Dark2,\r\n        lw=<span class=\"hljs-number\">0</span>,\r\n        alpha=<span class=\"hljs-number\">0.5</span>,\r\n    )\r\n\r\n    <span class=\"hljs-comment\"># Plot support vectors</span>\r\n    support = model.support\r\n    ax.scatter(\r\n        train_data_x[support],\r\n        train_data_y[support],\r\n        c=train_data_tags[support],\r\n        cmap=plt.cm.Dark2,\r\n    )\r\n\r\n\r\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\r\n    test_cancel_data()\r\n    test_demonstration()\r\n    plt.show()\r\n"
    }
  },
  "contributors": [
    {
      "name": "BAKEZQ",
      "email": "zhongquan789@gmail.com",
      "commits": 1
    },
    {
      "name": "GeorgeChambi",
      "email": "charalambous99@gmail.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 6
    }
  ],
  "explanationUrl": {}
}
