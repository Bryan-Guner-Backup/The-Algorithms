{
  "slug": "prim",
  "name": "Prim",
  "categories": ["graphs"],
  "body": {},
  "implementations": {
    "python": {
      "dir": "graphs/prim.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/graphs/prim.py",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;Prim&#x27;s Algorithm.\n\n    Determines the minimum spanning tree(MST) of a graph using the Prim&#x27;s Algorithm.\n\n    Details: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n&quot;&quot;&quot;</span>\n\n<span class=\"hljs-keyword\">import</span> heapq <span class=\"hljs-keyword\">as</span> hq\n<span class=\"hljs-keyword\">import</span> math\n<span class=\"hljs-keyword\">from</span> typing <span class=\"hljs-keyword\">import</span> Iterator\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Vertex</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;Class Vertex.&quot;&quot;&quot;</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, <span class=\"hljs-built_in\">id</span></span>):\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        Arguments:\n            id - input an id to identify the vertex\n        Attributes:\n            neighbors - a list of the vertices it is linked to\n            edges     - a dict to store the edges&#x27;s weight\n        &quot;&quot;&quot;</span>\n        self.<span class=\"hljs-built_in\">id</span> = <span class=\"hljs-built_in\">str</span>(<span class=\"hljs-built_in\">id</span>)\n        self.key = <span class=\"hljs-literal\">None</span>\n        self.pi = <span class=\"hljs-literal\">None</span>\n        self.neighbors = []\n        self.edges = {}  <span class=\"hljs-comment\"># {vertex:distance}</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__lt__</span>(<span class=\"hljs-params\">self, other</span>):\n        <span class=\"hljs-string\">&quot;&quot;&quot;Comparison rule to &lt; operator.&quot;&quot;&quot;</span>\n        <span class=\"hljs-keyword\">return</span> self.key &lt; other.key\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__repr__</span>(<span class=\"hljs-params\">self</span>):\n        <span class=\"hljs-string\">&quot;&quot;&quot;Return the vertex id.&quot;&quot;&quot;</span>\n        <span class=\"hljs-keyword\">return</span> self.<span class=\"hljs-built_in\">id</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add_neighbor</span>(<span class=\"hljs-params\">self, vertex</span>):\n        <span class=\"hljs-string\">&quot;&quot;&quot;Add a pointer to a vertex at neighbor&#x27;s list.&quot;&quot;&quot;</span>\n        self.neighbors.append(vertex)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add_edge</span>(<span class=\"hljs-params\">self, vertex, weight</span>):\n        <span class=\"hljs-string\">&quot;&quot;&quot;Destination vertex and weight.&quot;&quot;&quot;</span>\n        self.edges[vertex.<span class=\"hljs-built_in\">id</span>] = weight\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">connect</span>(<span class=\"hljs-params\">graph, a, b, edge</span>):\n    <span class=\"hljs-comment\"># add the neighbors:</span>\n    graph[a - <span class=\"hljs-number\">1</span>].add_neighbor(graph[b - <span class=\"hljs-number\">1</span>])\n    graph[b - <span class=\"hljs-number\">1</span>].add_neighbor(graph[a - <span class=\"hljs-number\">1</span>])\n    <span class=\"hljs-comment\"># add the edges:</span>\n    graph[a - <span class=\"hljs-number\">1</span>].add_edge(graph[b - <span class=\"hljs-number\">1</span>], edge)\n    graph[b - <span class=\"hljs-number\">1</span>].add_edge(graph[a - <span class=\"hljs-number\">1</span>], edge)\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">prim</span>(<span class=\"hljs-params\">graph: <span class=\"hljs-built_in\">list</span>, root: Vertex</span>) -&gt; <span class=\"hljs-built_in\">list</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;Prim&#x27;s Algorithm.\n\n    Runtime:\n        O(mn) with `m` edges and `n` vertices\n\n    Return:\n        List with the edges of a Minimum Spanning Tree\n\n    Usage:\n        prim(graph, graph[0])\n    &quot;&quot;&quot;</span>\n    a = []\n    <span class=\"hljs-keyword\">for</span> u <span class=\"hljs-keyword\">in</span> graph:\n        u.key = math.inf\n        u.pi = <span class=\"hljs-literal\">None</span>\n    root.key = <span class=\"hljs-number\">0</span>\n    q = graph[:]\n    <span class=\"hljs-keyword\">while</span> q:\n        u = <span class=\"hljs-built_in\">min</span>(q)\n        q.remove(u)\n        <span class=\"hljs-keyword\">for</span> v <span class=\"hljs-keyword\">in</span> u.neighbors:\n            <span class=\"hljs-keyword\">if</span> (v <span class=\"hljs-keyword\">in</span> q) <span class=\"hljs-keyword\">and</span> (u.edges[v.<span class=\"hljs-built_in\">id</span>] &lt; v.key):\n                v.pi = u\n                v.key = u.edges[v.<span class=\"hljs-built_in\">id</span>]\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">len</span>(graph)):\n        a.append((<span class=\"hljs-built_in\">int</span>(graph[i].<span class=\"hljs-built_in\">id</span>) + <span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">int</span>(graph[i].pi.<span class=\"hljs-built_in\">id</span>) + <span class=\"hljs-number\">1</span>))\n    <span class=\"hljs-keyword\">return</span> a\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">prim_heap</span>(<span class=\"hljs-params\">graph: <span class=\"hljs-built_in\">list</span>, root: Vertex</span>) -&gt; Iterator[<span class=\"hljs-built_in\">tuple</span>]:\n    <span class=\"hljs-string\">&quot;&quot;&quot;Prim&#x27;s Algorithm with min heap.\n\n    Runtime:\n        O((m + n)log n) with `m` edges and `n` vertices\n\n    Yield:\n        Edges of a Minimum Spanning Tree\n\n    Usage:\n        prim(graph, graph[0])\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-keyword\">for</span> u <span class=\"hljs-keyword\">in</span> graph:\n        u.key = math.inf\n        u.pi = <span class=\"hljs-literal\">None</span>\n    root.key = <span class=\"hljs-number\">0</span>\n\n    h = <span class=\"hljs-built_in\">list</span>(graph)\n    hq.heapify(h)\n\n    <span class=\"hljs-keyword\">while</span> h:\n        u = hq.heappop(h)\n        <span class=\"hljs-keyword\">for</span> v <span class=\"hljs-keyword\">in</span> u.neighbors:\n            <span class=\"hljs-keyword\">if</span> (v <span class=\"hljs-keyword\">in</span> h) <span class=\"hljs-keyword\">and</span> (u.edges[v.<span class=\"hljs-built_in\">id</span>] &lt; v.key):\n                v.pi = u\n                v.key = u.edges[v.<span class=\"hljs-built_in\">id</span>]\n                hq.heapify(h)\n\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">len</span>(graph)):\n        <span class=\"hljs-keyword\">yield</span> (<span class=\"hljs-built_in\">int</span>(graph[i].<span class=\"hljs-built_in\">id</span>) + <span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">int</span>(graph[i].pi.<span class=\"hljs-built_in\">id</span>) + <span class=\"hljs-number\">1</span>)\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">test_vector</span>() -&gt; <span class=\"hljs-literal\">None</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    # Creates a list to store x vertices.\n    &gt;&gt;&gt; x = 5\n    &gt;&gt;&gt; G = [Vertex(n) for n in range(x)]\n\n    &gt;&gt;&gt; connect(G, 1, 2, 15)\n    &gt;&gt;&gt; connect(G, 1, 3, 12)\n    &gt;&gt;&gt; connect(G, 2, 4, 13)\n    &gt;&gt;&gt; connect(G, 2, 5, 5)\n    &gt;&gt;&gt; connect(G, 3, 2, 6)\n    &gt;&gt;&gt; connect(G, 3, 4, 6)\n    &gt;&gt;&gt; connect(G, 0, 0, 0)  # Generate the minimum spanning tree:\n    &gt;&gt;&gt; G_heap = G[:]\n    &gt;&gt;&gt; MST = prim(G, G[0])\n    &gt;&gt;&gt; MST_heap = prim_heap(G, G[0])\n    &gt;&gt;&gt; for i in MST:\n    ...     print(i)\n    (2, 3)\n    (3, 1)\n    (4, 3)\n    (5, 2)\n    &gt;&gt;&gt; for i in MST_heap:\n    ...     print(i)\n    (2, 3)\n    (3, 1)\n    (4, 3)\n    (5, 2)\n    &quot;&quot;&quot;</span>\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    <span class=\"hljs-keyword\">import</span> doctest\n\n    doctest.testmod()\n"
    },
    "c-plus-plus": {
      "dir": "graph/prim.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph/prim.cpp",
      "code": "<span class=\"hljs-comment\">// C++ program to implement Prim&#x27;s Algorithm</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> PII = std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">prim</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-keyword\">const</span> std::vector&lt;std::vector&lt;PII&gt; &gt; &amp;graph)</span> </span>{\n    <span class=\"hljs-comment\">// priority queue to maintain edges with respect to weights</span>\n    std::priority_queue&lt;PII, std::vector&lt;PII&gt;, std::greater&lt;PII&gt; &gt; Q;\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">bool</span>&gt; <span class=\"hljs-title\">marked</span><span class=\"hljs-params\">(graph.size(), <span class=\"hljs-literal\">false</span>)</span></span>;\n    <span class=\"hljs-type\">int</span> minimum_cost = <span class=\"hljs-number\">0</span>;\n\n    Q.<span class=\"hljs-built_in\">push</span>(std::<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">0</span>, x));\n    <span class=\"hljs-keyword\">while</span> (!Q.<span class=\"hljs-built_in\">empty</span>()) {\n        <span class=\"hljs-comment\">// Select the edge with minimum weight</span>\n        PII p = Q.<span class=\"hljs-built_in\">top</span>();\n        Q.<span class=\"hljs-built_in\">pop</span>();\n        x = p.second;\n        <span class=\"hljs-comment\">// Checking for cycle</span>\n        <span class=\"hljs-keyword\">if</span> (marked[x] == <span class=\"hljs-literal\">true</span>) {\n            <span class=\"hljs-keyword\">continue</span>;\n        }\n        minimum_cost += p.first;\n        marked[x] = <span class=\"hljs-literal\">true</span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> PII &amp;neighbor : graph[x]) {\n            <span class=\"hljs-type\">int</span> y = neighbor.second;\n            <span class=\"hljs-keyword\">if</span> (marked[y] == <span class=\"hljs-literal\">false</span>) {\n                Q.<span class=\"hljs-built_in\">push</span>(neighbor);\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> minimum_cost;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-type\">int</span> nodes = <span class=\"hljs-number\">0</span>, edges = <span class=\"hljs-number\">0</span>;\n    std::cin &gt;&gt; nodes &gt;&gt; edges;  <span class=\"hljs-comment\">// number of nodes &amp; edges in graph</span>\n    <span class=\"hljs-keyword\">if</span> (nodes == <span class=\"hljs-number\">0</span> || edges == <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n    }\n\n    std::vector&lt;std::vector&lt;PII&gt; &gt; <span class=\"hljs-built_in\">graph</span>(nodes);\n\n    <span class=\"hljs-comment\">// Edges with their nodes &amp; weight</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; edges; ++i) {\n        <span class=\"hljs-type\">int</span> x = <span class=\"hljs-number\">0</span>, y = <span class=\"hljs-number\">0</span>, weight = <span class=\"hljs-number\">0</span>;\n        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; weight;\n        graph[x].<span class=\"hljs-built_in\">push_back</span>(std::<span class=\"hljs-built_in\">make_pair</span>(weight, y));\n        graph[y].<span class=\"hljs-built_in\">push_back</span>(std::<span class=\"hljs-built_in\">make_pair</span>(weight, x));\n    }\n\n    <span class=\"hljs-comment\">// Selecting 1 as the starting node</span>\n    <span class=\"hljs-type\">int</span> minimum_cost = <span class=\"hljs-built_in\">prim</span>(<span class=\"hljs-number\">1</span>, graph);\n    std::cout &lt;&lt; minimum_cost &lt;&lt; std::endl;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "c": {
      "dir": "greedy_approach/prim.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/greedy_approach/prim.c",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * @author [Timothy Maloney](https://github.com/sl1mb0)\n * @brief [Prim&#x27;s algorithm](https://en.wikipedia.org/wiki/Prim%27s_algorithm)\n * implementation in C to find the MST of a weighted, connected graph.\n * @details Prim&#x27;s algorithm uses a greedy approach to generate the MST of a weighted connected graph.\n * The algorithm begins at an arbitrary vertex v, and selects a next vertex u, \n * where v and u are connected by a weighted edge whose weight is the minimum of all edges connected to v. \n * @references Page 319 &quot;Introduction to the Design and Analysis of Algorithms&quot; - Anany Levitin\n *\n * To test - run &#x27;./prim -test&#x27;\n * prim() will find the MST of the following adj. matrix:\n *\t  \n *\t  0  1  2  3\n *        1  0  4  6\n *        2  4  0  5\n *        3  6  5  0\n * \n * The minimum spanning tree for the above weighted connected graph is given by the following adj matrix:\n *\t   \n *\t  0  1  2  3\n *\t  1  0  0  0\n *\t  2  0  0  0\n *\t  3  0  0  0\n *\n *\n * The following [link](https://visualgo.net/en/mst) provides a visual representation of graphs that can be used to test/verify the algorithm for different adj\n * matrices and their weighted, connected graphs.\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span>        <span class=\"hljs-comment\">/// for IO operations</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string.h&gt;</span>      <span class=\"hljs-comment\">/// for string comparison</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span>     <span class=\"hljs-comment\">/// for assert()</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;inttypes.h&gt;</span>  <span class=\"hljs-comment\">/// for uint16_t</span></span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> MAX 20</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> INF 999</span>\n\n<span class=\"hljs-comment\">/**\n * @brief Finds index of minimum element in edge list for an arbitrary vertex\n * @param arr graph row\n * @param N number of elements in arr\n * @returns index of minimum element in arr\n */</span>\n<span class=\"hljs-type\">uint16_t</span> <span class=\"hljs-title function_\">minimum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint16_t</span> arr[], <span class=\"hljs-type\">uint16_t</span> N)</span>\n{\n    <span class=\"hljs-type\">uint16_t</span> index = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">uint16_t</span> min = INF;\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint16_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\n    {\n        <span class=\"hljs-keyword\">if</span> (arr[i] &lt; min)\n        {\n            min = arr[i];\n            index = i;\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> index;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Used to find MST of user-generated adj matrix G\n * @returns void\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">prim</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint16_t</span> G[][MAX], <span class=\"hljs-type\">uint16_t</span> MST[][MAX], <span class=\"hljs-type\">uint16_t</span> V)</span>\n{\n    <span class=\"hljs-type\">uint16_t</span> u, v;\n    <span class=\"hljs-type\">uint16_t</span> E_t[MAX], path[MAX];\n    <span class=\"hljs-type\">uint16_t</span> V_t[MAX], no_of_edges;\n\n    E_t[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// edges for current vertex</span>\n    V_t[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">// list of visited vertices</span>\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint16_t</span> i = <span class=\"hljs-number\">1</span>; i &lt; V; i++)\n    {\n        E_t[i] = G[i][<span class=\"hljs-number\">0</span>];\n        path[i] = <span class=\"hljs-number\">0</span>;\n        V_t[i] = <span class=\"hljs-number\">0</span>;\n    }\n\n    no_of_edges = V - <span class=\"hljs-number\">1</span>;\n\n    <span class=\"hljs-keyword\">while</span> (no_of_edges &gt; <span class=\"hljs-number\">0</span>)\n    {\n        u = minimum(E_t, V);\n        <span class=\"hljs-keyword\">while</span> (V_t[u] == <span class=\"hljs-number\">1</span>)\n        {\n            E_t[u] = INF;\n            u = minimum(E_t, V);\n        }\n\n        v = path[u];\n        MST[v][u] = E_t[u];\n        MST[u][v] = E_t[u];\n        no_of_edges--;\n        V_t[u] = <span class=\"hljs-number\">1</span>;\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint16_t</span> i = <span class=\"hljs-number\">1</span>; i &lt; V; i++)\n        {\n            <span class=\"hljs-keyword\">if</span> (V_t[i] == <span class=\"hljs-number\">0</span> &amp;&amp; G[u][i] &lt; E_t[i])\n            {\n                E_t[i] = G[u][i];\n                path[i] = v;\n            }\n        }\n    }\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Self-test implementations\n * @returns void\n */</span>\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint16_t</span> G[][MAX], <span class=\"hljs-type\">uint16_t</span> MST[][MAX], <span class=\"hljs-type\">uint16_t</span> V)</span>\n{\n \n  <span class=\"hljs-type\">uint16_t</span> test[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">4</span>] = {{<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>},{<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">6</span>},{<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">5</span>},{<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">0</span>}};\n  <span class=\"hljs-type\">uint16_t</span> solution[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">4</span>] = {{<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>},{<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>},{<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>},{<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>}};\n\n  V = <span class=\"hljs-number\">4</span>;\n\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">uint16_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; ++i)\n  {\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">uint16_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; V; ++j)\n    {\n      G[i][j] = test[i][j];\n    }\n  }\n\n  prim(&amp;(*G),&amp;(*MST),V);\n\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">uint16_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; ++i)\n  {\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">uint16_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; V; ++j)\n    {\n      assert(MST[i][j] == solution[i][j]);\n    }\n  }\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Function user_graph();\n * gets user input adj. matrix and finds MST of that graph\n * @returns void\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">user_graph</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint16_t</span> G[][MAX], <span class=\"hljs-type\">uint16_t</span> MST[][MAX], <span class=\"hljs-type\">uint16_t</span> V)</span>\n{\n      <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter the number of vertices: &quot;</span>);\n      <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot; %hd&quot;</span>, &amp;V);\n\n      assert(V &lt;= MAX);\n\n      <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter the adj matrix\\n&quot;</span>);\n      <span class=\"hljs-type\">uint16_t</span> i, j;\n      <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; V; ++i)\n      {\n          <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; V; ++j)\n          {\n              <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;G[%d][%d]: &quot;</span>, i, j);\n              <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot; %hd&quot;</span>, &amp;G[i][j]);\n              <span class=\"hljs-keyword\">if</span> (G[i][j] == <span class=\"hljs-number\">0</span>)\n                  G[i][j] = INF;\n          }\n      }\n\n      prim(&amp;(*G),&amp;(*MST),V);\n\n      <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;minimum spanning tree:\\n&quot;</span>);\n      <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; V; ++i)\n      {\n          <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>);\n          <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; V; ++j)\n          {\n              <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\t&quot;</span>, MST[i][j]);\n          }\n      }\n}\n\n\n<span class=\"hljs-comment\">/**\n * @brief Main function\n * @param argc commandline argument count (ignored)\n * @param argv commandline array of arguments (ignored)\n * @returns 0 on exit\n */</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> <span class=\"hljs-keyword\">const</span> *argv[])</span>\n{   \n\n    <span class=\"hljs-type\">uint16_t</span> G[MAX][MAX];    <span class=\"hljs-comment\">///&lt; weighted, connected graph G</span>\n    <span class=\"hljs-type\">uint16_t</span> MST[MAX][MAX];  <span class=\"hljs-comment\">///&lt; adj matrix to hold minimum spanning tree of G</span>\n    <span class=\"hljs-type\">uint16_t</span> V;              <span class=\"hljs-comment\">///&lt; number of vertices in V in G</span>\n\n\n    <span class=\"hljs-keyword\">if</span>(argc == <span class=\"hljs-number\">2</span> &amp;&amp; <span class=\"hljs-built_in\">strcmp</span>(argv[<span class=\"hljs-number\">1</span>],<span class=\"hljs-string\">&quot;-test&quot;</span>) == <span class=\"hljs-number\">0</span>)\n    {\n      test(&amp;(*G),&amp;(*MST),V);\n    }\n    <span class=\"hljs-keyword\">else</span>\n    {\n      user_graph(&amp;(*G),&amp;(*MST),V);\n    }\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 1
    },
    {
      "name": "shellhub",
      "email": "shellhub.me@gmail.com",
      "commits": 1
    },
    {
      "name": "Tim Maloney",
      "email": "tmaloney@pdx.edu",
      "commits": 1
    },
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Mansi Mittal",
      "email": "m16mittal@gmail.com",
      "commits": 1
    },
    {
      "name": "Himanshu Airan",
      "email": "62210670+Himanshu-77@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Kyle",
      "email": "40903431+kylepw@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Bruno Santos",
      "email": "7022432+dunderbruno@users.noreply.github.com",
      "commits": 2
    },
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 4
    }
  ],
  "explanationUrl": {}
}
