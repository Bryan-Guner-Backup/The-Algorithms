{
  "slug": "tabu-search",
  "name": "Tabu Search",
  "categories": ["searches"],
  "body": {},
  "implementations": {
    "python": {
      "dir": "searches/tabu_search.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/searches/tabu_search.py",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;\nThis is pure Python implementation of Tabu search algorithm for a Travelling Salesman\nProblem, that the distances between the cities are symmetric (the distance between city\n&#x27;a&#x27; and city &#x27;b&#x27; is the same between city &#x27;b&#x27; and city &#x27;a&#x27;).\nThe TSP can be represented into a graph. The cities are represented by nodes and the\ndistance between them is represented by the weight of the ark between the nodes.\n\nThe .txt file with the graph has the form:\n\nnode1 node2 distance_between_node1_and_node2\nnode1 node3 distance_between_node1_and_node3\n...\n\nBe careful node1, node2 and the distance between them, must exist only once. This means\nin the .txt file should not exist:\nnode1 node2 distance_between_node1_and_node2\nnode2 node1 distance_between_node2_and_node1\n\nFor pytests run following command:\npytest\n\nFor manual testing run:\npython tabu_search.py -f your_file_name.txt -number_of_iterations_of_tabu_search \\\n    -s size_of_tabu_search\ne.g. python tabu_search.py -f tabudata2.txt -i 4 -s 3\n&quot;&quot;&quot;</span>\n<span class=\"hljs-keyword\">import</span> argparse\n<span class=\"hljs-keyword\">import</span> copy\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">generate_neighbours</span>(<span class=\"hljs-params\">path</span>):\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Pure implementation of generating a dictionary of neighbors and the cost with each\n    neighbor, given a path file that includes a graph.\n\n    :param path: The path to the .txt file that includes the graph (e.g.tabudata2.txt)\n    :return dict_of_neighbours: Dictionary with key each node and value a list of lists\n        with the neighbors of the node and the cost (distance) for each neighbor.\n\n    Example of dict_of_neighbours:\n    &gt;&gt;) dict_of_neighbours[a]\n    [[b,20],[c,18],[d,22],[e,26]]\n\n    This indicates the neighbors of node (city) &#x27;a&#x27;, which has neighbor the node &#x27;b&#x27;\n    with distance 20, the node &#x27;c&#x27; with distance 18, the node &#x27;d&#x27; with distance 22 and\n    the node &#x27;e&#x27; with distance 26.\n    &quot;&quot;&quot;</span>\n\n    dict_of_neighbours = {}\n\n    <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(path) <span class=\"hljs-keyword\">as</span> f:\n        <span class=\"hljs-keyword\">for</span> line <span class=\"hljs-keyword\">in</span> f:\n            <span class=\"hljs-keyword\">if</span> line.split()[<span class=\"hljs-number\">0</span>] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> dict_of_neighbours:\n                _<span class=\"hljs-built_in\">list</span> = <span class=\"hljs-built_in\">list</span>()\n                _<span class=\"hljs-built_in\">list</span>.append([line.split()[<span class=\"hljs-number\">1</span>], line.split()[<span class=\"hljs-number\">2</span>]])\n                dict_of_neighbours[line.split()[<span class=\"hljs-number\">0</span>]] = _<span class=\"hljs-built_in\">list</span>\n            <span class=\"hljs-keyword\">else</span>:\n                dict_of_neighbours[line.split()[<span class=\"hljs-number\">0</span>]].append(\n                    [line.split()[<span class=\"hljs-number\">1</span>], line.split()[<span class=\"hljs-number\">2</span>]]\n                )\n            <span class=\"hljs-keyword\">if</span> line.split()[<span class=\"hljs-number\">1</span>] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> dict_of_neighbours:\n                _<span class=\"hljs-built_in\">list</span> = <span class=\"hljs-built_in\">list</span>()\n                _<span class=\"hljs-built_in\">list</span>.append([line.split()[<span class=\"hljs-number\">0</span>], line.split()[<span class=\"hljs-number\">2</span>]])\n                dict_of_neighbours[line.split()[<span class=\"hljs-number\">1</span>]] = _<span class=\"hljs-built_in\">list</span>\n            <span class=\"hljs-keyword\">else</span>:\n                dict_of_neighbours[line.split()[<span class=\"hljs-number\">1</span>]].append(\n                    [line.split()[<span class=\"hljs-number\">0</span>], line.split()[<span class=\"hljs-number\">2</span>]]\n                )\n\n    <span class=\"hljs-keyword\">return</span> dict_of_neighbours\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">generate_first_solution</span>(<span class=\"hljs-params\">path, dict_of_neighbours</span>):\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Pure implementation of generating the first solution for the Tabu search to start,\n    with the redundant resolution strategy. That means that we start from the starting\n    node (e.g. node &#x27;a&#x27;), then we go to the city nearest (lowest distance) to this node\n    (let&#x27;s assume is node &#x27;c&#x27;), then we go to the nearest city of the node &#x27;c&#x27;, etc.\n    till we have visited all cities and return to the starting node.\n\n    :param path: The path to the .txt file that includes the graph (e.g.tabudata2.txt)\n    :param dict_of_neighbours: Dictionary with key each node and value a list of lists\n        with the neighbors of the node and the cost (distance) for each neighbor.\n    :return first_solution: The solution for the first iteration of Tabu search using\n        the redundant resolution strategy in a list.\n    :return distance_of_first_solution: The total distance that Travelling Salesman\n        will travel, if he follows the path in first_solution.\n    &quot;&quot;&quot;</span>\n\n    <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(path) <span class=\"hljs-keyword\">as</span> f:\n        start_node = f.read(<span class=\"hljs-number\">1</span>)\n    end_node = start_node\n\n    first_solution = []\n\n    visiting = start_node\n\n    distance_of_first_solution = <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">while</span> visiting <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> first_solution:\n        minim = <span class=\"hljs-number\">10000</span>\n        <span class=\"hljs-keyword\">for</span> k <span class=\"hljs-keyword\">in</span> dict_of_neighbours[visiting]:\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">int</span>(k[<span class=\"hljs-number\">1</span>]) &lt; <span class=\"hljs-built_in\">int</span>(minim) <span class=\"hljs-keyword\">and</span> k[<span class=\"hljs-number\">0</span>] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> first_solution:\n                minim = k[<span class=\"hljs-number\">1</span>]\n                best_node = k[<span class=\"hljs-number\">0</span>]\n\n        first_solution.append(visiting)\n        distance_of_first_solution = distance_of_first_solution + <span class=\"hljs-built_in\">int</span>(minim)\n        visiting = best_node\n\n    first_solution.append(end_node)\n\n    position = <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">for</span> k <span class=\"hljs-keyword\">in</span> dict_of_neighbours[first_solution[-<span class=\"hljs-number\">2</span>]]:\n        <span class=\"hljs-keyword\">if</span> k[<span class=\"hljs-number\">0</span>] == start_node:\n            <span class=\"hljs-keyword\">break</span>\n        position += <span class=\"hljs-number\">1</span>\n\n    distance_of_first_solution = (\n        distance_of_first_solution\n        + <span class=\"hljs-built_in\">int</span>(dict_of_neighbours[first_solution[-<span class=\"hljs-number\">2</span>]][position][<span class=\"hljs-number\">1</span>])\n        - <span class=\"hljs-number\">10000</span>\n    )\n    <span class=\"hljs-keyword\">return</span> first_solution, distance_of_first_solution\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">find_neighborhood</span>(<span class=\"hljs-params\">solution, dict_of_neighbours</span>):\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Pure implementation of generating the neighborhood (sorted by total distance of\n    each solution from lowest to highest) of a solution with 1-1 exchange method, that\n    means we exchange each node in a solution with each other node and generating a\n    number of solution named neighborhood.\n\n    :param solution: The solution in which we want to find the neighborhood.\n    :param dict_of_neighbours: Dictionary with key each node and value a list of lists\n        with the neighbors of the node and the cost (distance) for each neighbor.\n    :return neighborhood_of_solution: A list that includes the solutions and the total\n        distance of each solution (in form of list) that are produced with 1-1 exchange\n        from the solution that the method took as an input\n\n    Example:\n    &gt;&gt;&gt; find_neighborhood([&#x27;a&#x27;, &#x27;c&#x27;, &#x27;b&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;a&#x27;],\n    ...                   {&#x27;a&#x27;: [[&#x27;b&#x27;, &#x27;20&#x27;], [&#x27;c&#x27;, &#x27;18&#x27;], [&#x27;d&#x27;, &#x27;22&#x27;], [&#x27;e&#x27;, &#x27;26&#x27;]],\n    ...                    &#x27;c&#x27;: [[&#x27;a&#x27;, &#x27;18&#x27;], [&#x27;b&#x27;, &#x27;10&#x27;], [&#x27;d&#x27;, &#x27;23&#x27;], [&#x27;e&#x27;, &#x27;24&#x27;]],\n    ...                    &#x27;b&#x27;: [[&#x27;a&#x27;, &#x27;20&#x27;], [&#x27;c&#x27;, &#x27;10&#x27;], [&#x27;d&#x27;, &#x27;11&#x27;], [&#x27;e&#x27;, &#x27;12&#x27;]],\n    ...                    &#x27;e&#x27;: [[&#x27;a&#x27;, &#x27;26&#x27;], [&#x27;b&#x27;, &#x27;12&#x27;], [&#x27;c&#x27;, &#x27;24&#x27;], [&#x27;d&#x27;, &#x27;40&#x27;]],\n    ...                    &#x27;d&#x27;: [[&#x27;a&#x27;, &#x27;22&#x27;], [&#x27;b&#x27;, &#x27;11&#x27;], [&#x27;c&#x27;, &#x27;23&#x27;], [&#x27;e&#x27;, &#x27;40&#x27;]]}\n    ...                   )  # doctest: +NORMALIZE_WHITESPACE\n    [[&#x27;a&#x27;, &#x27;e&#x27;, &#x27;b&#x27;, &#x27;d&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, 90],\n     [&#x27;a&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;a&#x27;, 90],\n     [&#x27;a&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;e&#x27;, &#x27;a&#x27;, 93],\n     [&#x27;a&#x27;, &#x27;c&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;d&#x27;, &#x27;a&#x27;, 102],\n     [&#x27;a&#x27;, &#x27;c&#x27;, &#x27;e&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, 113],\n     [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;a&#x27;, 119]]\n    &quot;&quot;&quot;</span>\n\n    neighborhood_of_solution = []\n\n    <span class=\"hljs-keyword\">for</span> n <span class=\"hljs-keyword\">in</span> solution[<span class=\"hljs-number\">1</span>:-<span class=\"hljs-number\">1</span>]:\n        idx1 = solution.index(n)\n        <span class=\"hljs-keyword\">for</span> kn <span class=\"hljs-keyword\">in</span> solution[<span class=\"hljs-number\">1</span>:-<span class=\"hljs-number\">1</span>]:\n            idx2 = solution.index(kn)\n            <span class=\"hljs-keyword\">if</span> n == kn:\n                <span class=\"hljs-keyword\">continue</span>\n\n            _tmp = copy.deepcopy(solution)\n            _tmp[idx1] = kn\n            _tmp[idx2] = n\n\n            distance = <span class=\"hljs-number\">0</span>\n\n            <span class=\"hljs-keyword\">for</span> k <span class=\"hljs-keyword\">in</span> _tmp[:-<span class=\"hljs-number\">1</span>]:\n                next_node = _tmp[_tmp.index(k) + <span class=\"hljs-number\">1</span>]\n                <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> dict_of_neighbours[k]:\n                    <span class=\"hljs-keyword\">if</span> i[<span class=\"hljs-number\">0</span>] == next_node:\n                        distance = distance + <span class=\"hljs-built_in\">int</span>(i[<span class=\"hljs-number\">1</span>])\n            _tmp.append(distance)\n\n            <span class=\"hljs-keyword\">if</span> _tmp <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> neighborhood_of_solution:\n                neighborhood_of_solution.append(_tmp)\n\n    indexOfLastItemInTheList = <span class=\"hljs-built_in\">len</span>(neighborhood_of_solution[<span class=\"hljs-number\">0</span>]) - <span class=\"hljs-number\">1</span>\n\n    neighborhood_of_solution.sort(key=<span class=\"hljs-keyword\">lambda</span> x: x[indexOfLastItemInTheList])\n    <span class=\"hljs-keyword\">return</span> neighborhood_of_solution\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">tabu_search</span>(<span class=\"hljs-params\">\n    first_solution, distance_of_first_solution, dict_of_neighbours, iters, size\n</span>):\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Pure implementation of Tabu search algorithm for a Travelling Salesman Problem in\n    Python.\n\n    :param first_solution: The solution for the first iteration of Tabu search using\n        the redundant resolution strategy in a list.\n    :param distance_of_first_solution: The total distance that Travelling Salesman will\n        travel, if he follows the path in first_solution.\n    :param dict_of_neighbours: Dictionary with key each node and value a list of lists\n        with the neighbors of the node and the cost (distance) for each neighbor.\n    :param iters: The number of iterations that Tabu search will execute.\n    :param size: The size of Tabu List.\n    :return best_solution_ever: The solution with the lowest distance that occurred\n        during the execution of Tabu search.\n    :return best_cost: The total distance that Travelling Salesman will travel, if he\n        follows the path in best_solution ever.\n    &quot;&quot;&quot;</span>\n    count = <span class=\"hljs-number\">1</span>\n    solution = first_solution\n    tabu_list = <span class=\"hljs-built_in\">list</span>()\n    best_cost = distance_of_first_solution\n    best_solution_ever = solution\n\n    <span class=\"hljs-keyword\">while</span> count &lt;= iters:\n        neighborhood = find_neighborhood(solution, dict_of_neighbours)\n        index_of_best_solution = <span class=\"hljs-number\">0</span>\n        best_solution = neighborhood[index_of_best_solution]\n        best_cost_index = <span class=\"hljs-built_in\">len</span>(best_solution) - <span class=\"hljs-number\">1</span>\n\n        found = <span class=\"hljs-literal\">False</span>\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">not</span> found:\n            i = <span class=\"hljs-number\">0</span>\n            <span class=\"hljs-keyword\">while</span> i &lt; <span class=\"hljs-built_in\">len</span>(best_solution):\n\n                <span class=\"hljs-keyword\">if</span> best_solution[i] != solution[i]:\n                    first_exchange_node = best_solution[i]\n                    second_exchange_node = solution[i]\n                    <span class=\"hljs-keyword\">break</span>\n                i = i + <span class=\"hljs-number\">1</span>\n\n            <span class=\"hljs-keyword\">if</span> [first_exchange_node, second_exchange_node] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> tabu_list <span class=\"hljs-keyword\">and</span> [\n                second_exchange_node,\n                first_exchange_node,\n            ] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> tabu_list:\n                tabu_list.append([first_exchange_node, second_exchange_node])\n                found = <span class=\"hljs-literal\">True</span>\n                solution = best_solution[:-<span class=\"hljs-number\">1</span>]\n                cost = neighborhood[index_of_best_solution][best_cost_index]\n                <span class=\"hljs-keyword\">if</span> cost &lt; best_cost:\n                    best_cost = cost\n                    best_solution_ever = solution\n            <span class=\"hljs-keyword\">else</span>:\n                index_of_best_solution = index_of_best_solution + <span class=\"hljs-number\">1</span>\n                best_solution = neighborhood[index_of_best_solution]\n\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(tabu_list) &gt;= size:\n            tabu_list.pop(<span class=\"hljs-number\">0</span>)\n\n        count = count + <span class=\"hljs-number\">1</span>\n\n    <span class=\"hljs-keyword\">return</span> best_solution_ever, best_cost\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\">args=<span class=\"hljs-literal\">None</span></span>):\n    dict_of_neighbours = generate_neighbours(args.File)\n\n    first_solution, distance_of_first_solution = generate_first_solution(\n        args.File, dict_of_neighbours\n    )\n\n    best_sol, best_cost = tabu_search(\n        first_solution,\n        distance_of_first_solution,\n        dict_of_neighbours,\n        args.Iterations,\n        args.Size,\n    )\n\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;Best solution: <span class=\"hljs-subst\">{best_sol}</span>, with total distance: <span class=\"hljs-subst\">{best_cost}</span>.&quot;</span>)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    parser = argparse.ArgumentParser(description=<span class=\"hljs-string\">&quot;Tabu Search&quot;</span>)\n    parser.add_argument(\n        <span class=\"hljs-string\">&quot;-f&quot;</span>,\n        <span class=\"hljs-string\">&quot;--File&quot;</span>,\n        <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-built_in\">str</span>,\n        <span class=\"hljs-built_in\">help</span>=<span class=\"hljs-string\">&quot;Path to the file containing the data&quot;</span>,\n        required=<span class=\"hljs-literal\">True</span>,\n    )\n    parser.add_argument(\n        <span class=\"hljs-string\">&quot;-i&quot;</span>,\n        <span class=\"hljs-string\">&quot;--Iterations&quot;</span>,\n        <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-built_in\">int</span>,\n        <span class=\"hljs-built_in\">help</span>=<span class=\"hljs-string\">&quot;How many iterations the algorithm should perform&quot;</span>,\n        required=<span class=\"hljs-literal\">True</span>,\n    )\n    parser.add_argument(\n        <span class=\"hljs-string\">&quot;-s&quot;</span>, <span class=\"hljs-string\">&quot;--Size&quot;</span>, <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">help</span>=<span class=\"hljs-string\">&quot;Size of the tabu list&quot;</span>, required=<span class=\"hljs-literal\">True</span>\n    )\n\n    <span class=\"hljs-comment\"># Pass the arguments to main method</span>\n    main(parser.parse_args())\n"
    }
  },
  "contributors": [
    {
      "name": "Harshil Darji",
      "email": "darjiharshil2994@gmail.com",
      "commits": 1
    },
    {
      "name": "onlinejudge95",
      "email": "44158581+onlinejudge95@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "matkosoric",
      "email": "soric.matko@gmail.com",
      "commits": 1
    },
    {
      "name": "GeorgeChambi",
      "email": "charalambous99@gmail.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Mickaël Schoentgen",
      "email": "contact@tiger-222.fr",
      "commits": 1
    },
    {
      "name": "irokafetzaki",
      "email": "iro.kafetzaki@gmail.com",
      "commits": 1
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 5
    }
  ],
  "explanationUrl": {}
}
