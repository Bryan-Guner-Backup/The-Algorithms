{
  "slug": "binomial-heap",
  "name": "Binomial Heap",
  "categories": ["datastructures", "heap"],
  "body": {},
  "implementations": {
    "python": {
      "dir": "data_structures/heap/binomial_heap.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/data_structures/heap/binomial_heap.py",
      "code": "<span class=\"hljs-comment\"># flake8: noqa</span>\r\n\r\n<span class=\"hljs-string\">&quot;&quot;&quot;\r\nBinomial Heap\r\nReference: Advanced Data Structures, Peter Brass\r\n&quot;&quot;&quot;</span>\r\n\r\n\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Node</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Node in a doubly-linked binomial tree, containing:\r\n        - value\r\n        - size of left subtree\r\n        - link to left, right and parent nodes\r\n    &quot;&quot;&quot;</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, val</span>):\r\n        self.val = val\r\n        <span class=\"hljs-comment\"># Number of nodes in left subtree</span>\r\n        self.left_tree_size = <span class=\"hljs-number\">0</span>\r\n        self.left = <span class=\"hljs-literal\">None</span>\r\n        self.right = <span class=\"hljs-literal\">None</span>\r\n        self.parent = <span class=\"hljs-literal\">None</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">mergeTrees</span>(<span class=\"hljs-params\">self, other</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        In-place merge of two binomial trees of equal size.\r\n        Returns the root of the resulting tree\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-keyword\">assert</span> self.left_tree_size == other.left_tree_size, <span class=\"hljs-string\">&quot;Unequal Sizes of Blocks&quot;</span>\r\n\r\n        <span class=\"hljs-keyword\">if</span> self.val &lt; other.val:\r\n            other.left = self.right\r\n            other.parent = <span class=\"hljs-literal\">None</span>\r\n            <span class=\"hljs-keyword\">if</span> self.right:\r\n                self.right.parent = other\r\n            self.right = other\r\n            self.left_tree_size = self.left_tree_size * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>\r\n            <span class=\"hljs-keyword\">return</span> self\r\n        <span class=\"hljs-keyword\">else</span>:\r\n            self.left = other.right\r\n            self.parent = <span class=\"hljs-literal\">None</span>\r\n            <span class=\"hljs-keyword\">if</span> other.right:\r\n                other.right.parent = self\r\n            other.right = self\r\n            other.left_tree_size = other.left_tree_size * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>\r\n            <span class=\"hljs-keyword\">return</span> other\r\n\r\n\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BinomialHeap</span>:\r\n    <span class=\"hljs-string\">r&quot;&quot;&quot;\r\n    Min-oriented priority queue implemented with the Binomial Heap data\r\n    structure implemented with the BinomialHeap class. It supports:\r\n        - Insert element in a heap with n elements: Guaranteed logn, amoratized 1\r\n        - Merge (meld) heaps of size m and n: O(logn + logm)\r\n        - Delete Min: O(logn)\r\n        - Peek (return min without deleting it): O(1)\r\n\r\n    Example:\r\n\r\n    Create a random permutation of 30 integers to be inserted and 19 of them deleted\r\n    &gt;&gt;&gt; import numpy as np\r\n    &gt;&gt;&gt; permutation = np.random.permutation(list(range(30)))\r\n\r\n    Create a Heap and insert the 30 integers\r\n    __init__() test\r\n    &gt;&gt;&gt; first_heap = BinomialHeap()\r\n\r\n    30 inserts - insert() test\r\n    &gt;&gt;&gt; for number in permutation:\r\n    ...     first_heap.insert(number)\r\n\r\n    Size test\r\n    &gt;&gt;&gt; print(first_heap.size)\r\n    30\r\n\r\n    Deleting - delete() test\r\n    &gt;&gt;&gt; for i in range(25):\r\n    ...     print(first_heap.deleteMin(), end=&quot; &quot;)\r\n    0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \r\n\r\n    Create a new Heap\r\n    &gt;&gt;&gt; second_heap = BinomialHeap()\r\n    &gt;&gt;&gt; vals = [17, 20, 31, 34]\r\n    &gt;&gt;&gt; for value in vals:\r\n    ...     second_heap.insert(value)\r\n\r\n\r\n    The heap should have the following structure:\r\n\r\n                    17\r\n                   /  \\\r\n                  #    31\r\n                      /  \\\r\n                    20    34\r\n                   /  \\  /  \\\r\n                  #    # #   #\r\n\r\n    preOrder() test\r\n    &gt;&gt;&gt; print(second_heap.preOrder())\r\n    [(17, 0), (&#x27;#&#x27;, 1), (31, 1), (20, 2), (&#x27;#&#x27;, 3), (&#x27;#&#x27;, 3), (34, 2), (&#x27;#&#x27;, 3), (&#x27;#&#x27;, 3)]\r\n\r\n    printing Heap - __str__() test\r\n    &gt;&gt;&gt; print(second_heap)\r\n    17\r\n    -#\r\n    -31\r\n    --20\r\n    ---#\r\n    ---#\r\n    --34\r\n    ---#\r\n    ---#\r\n\r\n    mergeHeaps() test\r\n    &gt;&gt;&gt; merged = second_heap.mergeHeaps(first_heap)\r\n    &gt;&gt;&gt; merged.peek()\r\n    17\r\n\r\n    values in merged heap; (merge is inplace)\r\n    &gt;&gt;&gt; while not first_heap.isEmpty():\r\n    ...     print(first_heap.deleteMin(), end=&quot; &quot;)\r\n    17 20 25 26 27 28 29 31 34 \r\n    &quot;&quot;&quot;</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, bottom_root=<span class=\"hljs-literal\">None</span>, min_node=<span class=\"hljs-literal\">None</span>, heap_size=<span class=\"hljs-number\">0</span></span>):\r\n        self.size = heap_size\r\n        self.bottom_root = bottom_root\r\n        self.min_node = min_node\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">mergeHeaps</span>(<span class=\"hljs-params\">self, other</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        In-place merge of two binomial heaps.\r\n        Both of them become the resulting merged heap\r\n        &quot;&quot;&quot;</span>\r\n\r\n        <span class=\"hljs-comment\"># Empty heaps corner cases</span>\r\n        <span class=\"hljs-keyword\">if</span> other.size == <span class=\"hljs-number\">0</span>:\r\n            <span class=\"hljs-keyword\">return</span>\r\n        <span class=\"hljs-keyword\">if</span> self.size == <span class=\"hljs-number\">0</span>:\r\n            self.size = other.size\r\n            self.bottom_root = other.bottom_root\r\n            self.min_node = other.min_node\r\n            <span class=\"hljs-keyword\">return</span>\r\n        <span class=\"hljs-comment\"># Update size</span>\r\n        self.size = self.size + other.size\r\n\r\n        <span class=\"hljs-comment\"># Update min.node</span>\r\n        <span class=\"hljs-keyword\">if</span> self.min_node.val &gt; other.min_node.val:\r\n            self.min_node = other.min_node\r\n        <span class=\"hljs-comment\"># Merge</span>\r\n\r\n        <span class=\"hljs-comment\"># Order roots by left_subtree_size</span>\r\n        combined_roots_list = []\r\n        i, j = self.bottom_root, other.bottom_root\r\n        <span class=\"hljs-keyword\">while</span> i <span class=\"hljs-keyword\">or</span> j:\r\n            <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-keyword\">and</span> ((<span class=\"hljs-keyword\">not</span> j) <span class=\"hljs-keyword\">or</span> i.left_tree_size &lt; j.left_tree_size):\r\n                combined_roots_list.append((i, <span class=\"hljs-literal\">True</span>))\r\n                i = i.parent\r\n            <span class=\"hljs-keyword\">else</span>:\r\n                combined_roots_list.append((j, <span class=\"hljs-literal\">False</span>))\r\n                j = j.parent\r\n        <span class=\"hljs-comment\"># Insert links between them</span>\r\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(combined_roots_list) - <span class=\"hljs-number\">1</span>):\r\n            <span class=\"hljs-keyword\">if</span> combined_roots_list[i][<span class=\"hljs-number\">1</span>] != combined_roots_list[i + <span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">1</span>]:\r\n                combined_roots_list[i][<span class=\"hljs-number\">0</span>].parent = combined_roots_list[i + <span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">0</span>]\r\n                combined_roots_list[i + <span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">0</span>].left = combined_roots_list[i][<span class=\"hljs-number\">0</span>]\r\n        <span class=\"hljs-comment\"># Consecutively merge roots with same left_tree_size</span>\r\n        i = combined_roots_list[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>]\r\n        <span class=\"hljs-keyword\">while</span> i.parent:\r\n            <span class=\"hljs-keyword\">if</span> (\r\n                (i.left_tree_size == i.parent.left_tree_size) <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-keyword\">not</span> i.parent.parent)\r\n            ) <span class=\"hljs-keyword\">or</span> (\r\n                i.left_tree_size == i.parent.left_tree_size\r\n                <span class=\"hljs-keyword\">and</span> i.left_tree_size != i.parent.parent.left_tree_size\r\n            ):\r\n\r\n                <span class=\"hljs-comment\"># Neighbouring Nodes</span>\r\n                previous_node = i.left\r\n                next_node = i.parent.parent\r\n\r\n                <span class=\"hljs-comment\"># Merging trees</span>\r\n                i = i.mergeTrees(i.parent)\r\n\r\n                <span class=\"hljs-comment\"># Updating links</span>\r\n                i.left = previous_node\r\n                i.parent = next_node\r\n                <span class=\"hljs-keyword\">if</span> previous_node:\r\n                    previous_node.parent = i\r\n                <span class=\"hljs-keyword\">if</span> next_node:\r\n                    next_node.left = i\r\n            <span class=\"hljs-keyword\">else</span>:\r\n                i = i.parent\r\n        <span class=\"hljs-comment\"># Updating self.bottom_root</span>\r\n        <span class=\"hljs-keyword\">while</span> i.left:\r\n            i = i.left\r\n        self.bottom_root = i\r\n\r\n        <span class=\"hljs-comment\"># Update other</span>\r\n        other.size = self.size\r\n        other.bottom_root = self.bottom_root\r\n        other.min_node = self.min_node\r\n\r\n        <span class=\"hljs-comment\"># Return the merged heap</span>\r\n        <span class=\"hljs-keyword\">return</span> self\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">insert</span>(<span class=\"hljs-params\">self, val</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        insert a value in the heap\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-keyword\">if</span> self.size == <span class=\"hljs-number\">0</span>:\r\n            self.bottom_root = Node(val)\r\n            self.size = <span class=\"hljs-number\">1</span>\r\n            self.min_node = self.bottom_root\r\n        <span class=\"hljs-keyword\">else</span>:\r\n            <span class=\"hljs-comment\"># Create new node</span>\r\n            new_node = Node(val)\r\n\r\n            <span class=\"hljs-comment\"># Update size</span>\r\n            self.size += <span class=\"hljs-number\">1</span>\r\n\r\n            <span class=\"hljs-comment\"># update min_node</span>\r\n            <span class=\"hljs-keyword\">if</span> val &lt; self.min_node.val:\r\n                self.min_node = new_node\r\n            <span class=\"hljs-comment\"># Put new_node as a bottom_root in heap</span>\r\n            self.bottom_root.left = new_node\r\n            new_node.parent = self.bottom_root\r\n            self.bottom_root = new_node\r\n\r\n            <span class=\"hljs-comment\"># Consecutively merge roots with same left_tree_size</span>\r\n            <span class=\"hljs-keyword\">while</span> (\r\n                self.bottom_root.parent\r\n                <span class=\"hljs-keyword\">and</span> self.bottom_root.left_tree_size\r\n                == self.bottom_root.parent.left_tree_size\r\n            ):\r\n\r\n                <span class=\"hljs-comment\"># Next node</span>\r\n                next_node = self.bottom_root.parent.parent\r\n\r\n                <span class=\"hljs-comment\"># Merge</span>\r\n                self.bottom_root = self.bottom_root.mergeTrees(self.bottom_root.parent)\r\n\r\n                <span class=\"hljs-comment\"># Update Links</span>\r\n                self.bottom_root.parent = next_node\r\n                self.bottom_root.left = <span class=\"hljs-literal\">None</span>\r\n                <span class=\"hljs-keyword\">if</span> next_node:\r\n                    next_node.left = self.bottom_root\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">peek</span>(<span class=\"hljs-params\">self</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        return min element without deleting it\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-keyword\">return</span> self.min_node.val\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isEmpty</span>(<span class=\"hljs-params\">self</span>):\r\n        <span class=\"hljs-keyword\">return</span> self.size == <span class=\"hljs-number\">0</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">deleteMin</span>(<span class=\"hljs-params\">self</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        delete min element and return it\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-comment\"># assert not self.isEmpty(), &quot;Empty Heap&quot;</span>\r\n\r\n        <span class=\"hljs-comment\"># Save minimal value</span>\r\n        min_value = self.min_node.val\r\n\r\n        <span class=\"hljs-comment\"># Last element in heap corner case</span>\r\n        <span class=\"hljs-keyword\">if</span> self.size == <span class=\"hljs-number\">1</span>:\r\n            <span class=\"hljs-comment\"># Update size</span>\r\n            self.size = <span class=\"hljs-number\">0</span>\r\n\r\n            <span class=\"hljs-comment\"># Update bottom root</span>\r\n            self.bottom_root = <span class=\"hljs-literal\">None</span>\r\n\r\n            <span class=\"hljs-comment\"># Update min_node</span>\r\n            self.min_node = <span class=\"hljs-literal\">None</span>\r\n\r\n            <span class=\"hljs-keyword\">return</span> min_value\r\n        <span class=\"hljs-comment\"># No right subtree corner case</span>\r\n        <span class=\"hljs-comment\"># The structure of the tree implies that this should be the bottom root</span>\r\n        <span class=\"hljs-comment\"># and there is at least one other root</span>\r\n        <span class=\"hljs-keyword\">if</span> self.min_node.right <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:\r\n            <span class=\"hljs-comment\"># Update size</span>\r\n            self.size -= <span class=\"hljs-number\">1</span>\r\n\r\n            <span class=\"hljs-comment\"># Update bottom root</span>\r\n            self.bottom_root = self.bottom_root.parent\r\n            self.bottom_root.left = <span class=\"hljs-literal\">None</span>\r\n\r\n            <span class=\"hljs-comment\"># Update min_node</span>\r\n            self.min_node = self.bottom_root\r\n            i = self.bottom_root.parent\r\n            <span class=\"hljs-keyword\">while</span> i:\r\n                <span class=\"hljs-keyword\">if</span> i.val &lt; self.min_node.val:\r\n                    self.min_node = i\r\n                i = i.parent\r\n            <span class=\"hljs-keyword\">return</span> min_value\r\n        <span class=\"hljs-comment\"># General case</span>\r\n        <span class=\"hljs-comment\"># Find the BinomialHeap of the right subtree of min_node</span>\r\n        bottom_of_new = self.min_node.right\r\n        bottom_of_new.parent = <span class=\"hljs-literal\">None</span>\r\n        min_of_new = bottom_of_new\r\n        size_of_new = <span class=\"hljs-number\">1</span>\r\n\r\n        <span class=\"hljs-comment\"># Size, min_node and bottom_root</span>\r\n        <span class=\"hljs-keyword\">while</span> bottom_of_new.left:\r\n            size_of_new = size_of_new * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>\r\n            bottom_of_new = bottom_of_new.left\r\n            <span class=\"hljs-keyword\">if</span> bottom_of_new.val &lt; min_of_new.val:\r\n                min_of_new = bottom_of_new\r\n        <span class=\"hljs-comment\"># Corner case of single root on top left path</span>\r\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">not</span> self.min_node.left) <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-keyword\">not</span> self.min_node.parent):\r\n            self.size = size_of_new\r\n            self.bottom_root = bottom_of_new\r\n            self.min_node = min_of_new\r\n            <span class=\"hljs-comment\"># print(&quot;Single root, multiple nodes case&quot;)</span>\r\n            <span class=\"hljs-keyword\">return</span> min_value\r\n        <span class=\"hljs-comment\"># Remaining cases</span>\r\n        <span class=\"hljs-comment\"># Construct heap of right subtree</span>\r\n        newHeap = BinomialHeap(\r\n            bottom_root=bottom_of_new, min_node=min_of_new, heap_size=size_of_new\r\n        )\r\n\r\n        <span class=\"hljs-comment\"># Update size</span>\r\n        self.size = self.size - <span class=\"hljs-number\">1</span> - size_of_new\r\n\r\n        <span class=\"hljs-comment\"># Neighbour nodes</span>\r\n        previous_node = self.min_node.left\r\n        next_node = self.min_node.parent\r\n\r\n        <span class=\"hljs-comment\"># Initialize new bottom_root and min_node</span>\r\n        self.min_node = previous_node <span class=\"hljs-keyword\">or</span> next_node\r\n        self.bottom_root = next_node\r\n\r\n        <span class=\"hljs-comment\"># Update links of previous_node and search below for new min_node and</span>\r\n        <span class=\"hljs-comment\"># bottom_root</span>\r\n        <span class=\"hljs-keyword\">if</span> previous_node:\r\n            previous_node.parent = next_node\r\n\r\n            <span class=\"hljs-comment\"># Update bottom_root and search for min_node below</span>\r\n            self.bottom_root = previous_node\r\n            self.min_node = previous_node\r\n            <span class=\"hljs-keyword\">while</span> self.bottom_root.left:\r\n                self.bottom_root = self.bottom_root.left\r\n                <span class=\"hljs-keyword\">if</span> self.bottom_root.val &lt; self.min_node.val:\r\n                    self.min_node = self.bottom_root\r\n        <span class=\"hljs-keyword\">if</span> next_node:\r\n            next_node.left = previous_node\r\n\r\n            <span class=\"hljs-comment\"># Search for new min_node above min_node</span>\r\n            i = next_node\r\n            <span class=\"hljs-keyword\">while</span> i:\r\n                <span class=\"hljs-keyword\">if</span> i.val &lt; self.min_node.val:\r\n                    self.min_node = i\r\n                i = i.parent\r\n        <span class=\"hljs-comment\"># Merge heaps</span>\r\n        self.mergeHeaps(newHeap)\r\n\r\n        <span class=\"hljs-keyword\">return</span> min_value\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">preOrder</span>(<span class=\"hljs-params\">self</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        Returns the Pre-order representation of the heap including\r\n        values of nodes plus their level distance from the root;\r\n        Empty nodes appear as #\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-comment\"># Find top root</span>\r\n        top_root = self.bottom_root\r\n        <span class=\"hljs-keyword\">while</span> top_root.parent:\r\n            top_root = top_root.parent\r\n        <span class=\"hljs-comment\"># preorder</span>\r\n        heap_preOrder = []\r\n        self.__traversal(top_root, heap_preOrder)\r\n        <span class=\"hljs-keyword\">return</span> heap_preOrder\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__traversal</span>(<span class=\"hljs-params\">self, curr_node, preorder, level=<span class=\"hljs-number\">0</span></span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        Pre-order traversal of nodes\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-keyword\">if</span> curr_node:\r\n            preorder.append((curr_node.val, level))\r\n            self.__traversal(curr_node.left, preorder, level + <span class=\"hljs-number\">1</span>)\r\n            self.__traversal(curr_node.right, preorder, level + <span class=\"hljs-number\">1</span>)\r\n        <span class=\"hljs-keyword\">else</span>:\r\n            preorder.append((<span class=\"hljs-string\">&quot;#&quot;</span>, level))\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__str__</span>(<span class=\"hljs-params\">self</span>):\r\n        <span class=\"hljs-string\">&quot;&quot;&quot;\r\n        Overwriting str for a pre-order print of nodes in heap;\r\n        Performance is poor, so use only for small examples\r\n        &quot;&quot;&quot;</span>\r\n        <span class=\"hljs-keyword\">if</span> self.isEmpty():\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>\r\n        preorder_heap = self.preOrder()\r\n\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;\\n&quot;</span>.join((<span class=\"hljs-string\">&quot;-&quot;</span> * level + <span class=\"hljs-built_in\">str</span>(value)) <span class=\"hljs-keyword\">for</span> value, level <span class=\"hljs-keyword\">in</span> preorder_heap)\r\n\r\n\r\n<span class=\"hljs-comment\"># Unit Tests</span>\r\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\r\n    <span class=\"hljs-keyword\">import</span> doctest\r\n\r\n    doctest.testmod()\r\n"
    }
  },
  "contributors": [
    {
      "name": "himanshujain171",
      "email": "43314193+himanshujain171@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Denis Trofimov",
      "email": "silaradost@yandex.ru",
      "commits": 1
    },
    {
      "name": "Kiril Bangachev",
      "email": "51961981+KirilBangachev@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}
