<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>README</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <h1 id="the-algorithms---dart">The Algorithms - Dart</h1>
    <p>
      <a href="https://travis-ci.com/TheAlgorithms/Dart"
        ><img
          src="https://travis-ci.com/TheAlgorithms/Dart.svg?branch=master"
          alt="Build Status"
      /></a>
      <a href="https://www.paypal.me/TheAlgorithms/100"
        ><img
          src="https://img.shields.io/badge/Donate-PayPal-green.svg"
          alt="Donate"
      /></a>
       
      <a href="https://gitter.im/TheAlgorithms"
        ><img
          src="https://badges.gitter.im/gitterHQ/gitter.png"
          alt="Gitter chat"
      /></a>
       
    </p>
    <h3 id="all-algorithms-implemented-in-dart-for-education">
      All algorithms implemented in Dart (for education)
    </h3>
    <p>
      These implementations are for learning purposes. They may be less
      efficient than the implementations in the Dart standard library.
    </p>
    <h2 id="list-of-algorithms">List of Algorithms</h2>
    <p>
      See our
      <a href="https://github.com/TheAlgorithms/Dart/blob/master/DIRECTORY.md"
        >directory</a
      >
      for full list of all algorithms. A few of the algorithms (the most common
      ones) are explained here.
    </p>
    <h2 id="search-algorithms">Search Algorithms</h2>
    <h3 id="linear">Linear</h3>
    <figure>
      <img
        src="http://www.tutorialspoint.com/data_structures_algorithms/images/linear_search.gif"
        alt="alt text"
      />
      <figcaption>alt text</figcaption>
    </figure>
    <p>
      From <a href="https://en.wikipedia.org/wiki/Linear_search">Wikipedia</a>:
      linear search or sequential search is a method for finding a target value
      within a list. It sequentially checks each element of the list for the
      target value until a match is found or until all the elements have been
      searched. Linear search runs in at the worst linear time and makes at most
      n comparisons, where n is the length of the list.
    </p>
    <p><strong>Properties</strong></p>
    <ul>
      <li>Worst case performance O(n)</li>
      <li>Best case performance O(1)</li>
      <li>Average case performance O(n)</li>
      <li>Worst case space complexity O(1) iterative</li>
    </ul>
    <h3 id="binary">Binary</h3>
    <figure>
      <img
        src="https://upload.wikimedia.org/wikipedia/commons/f/f7/Binary_search_into_array.png"
        alt="alt text"
      />
      <figcaption>alt text</figcaption>
    </figure>
    <p>
      From
      <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm"
        >Wikipedia</a
      >: Binary search, also known as half-interval search or logarithmic
      search, is a search algorithm that finds the position of a target value
      within a sorted array. It compares the target value to the middle element
      of the array; if they are unequal, the half in which the target cannot lie
      is eliminated and the search continues on the remaining half until it is
      successful.
    </p>
    <p><strong>Properties</strong></p>
    <ul>
      <li>Worst case performance O(log n)</li>
      <li>Best case performance O(1)</li>
      <li>Average case performance O(log n)</li>
      <li>Worst case space complexity O(1)</li>
    </ul>
    <hr />
    <h2 id="sort-algorithms">Sort Algorithms</h2>
    <h3 id="bubble">Bubble</h3>
    <figure>
      <img
        src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/83/Bubblesort-edited-color.svg/220px-Bubblesort-edited-color.svg.png"
        title="Bubble Sort"
        alt="alt text"
      />
      <figcaption>alt text</figcaption>
    </figure>
    <p>
      From <a href="https://en.wikipedia.org/wiki/Bubble_sort">Wikipedia</a>:
      Bubble sort, sometimes referred to as sinking sort, is a simple sorting
      algorithm that repeatedly steps through the list to be sorted, compares
      each pair of adjacent items and swaps them if they are in the wrong order.
      The pass through the list is repeated until no swaps are needed, which
      indicates that the list is sorted.
    </p>
    <p><strong>Properties</strong></p>
    <ul>
      <li>Worst case performance O(n^2)</li>
      <li>Best case performance O(n)</li>
      <li>Average case performance O(n^2)</li>
    </ul>
    <h6 id="view-the-algorithm-in-actionbubble-toptal">
      View the algorithm in
      <a href="https://www.toptal.com/developers/sorting-algorithms/bubble-sort"
        >action</a
      >
    </h6>
    <h3 id="insertion">Insertion</h3>
    <figure>
      <img
        src="https://upload.wikimedia.org/wikipedia/commons/7/7e/Insertionsort-edited.png"
        title="Insertion Sort"
        alt="alt text"
      />
      <figcaption>alt text</figcaption>
    </figure>
    <p>
      From <a href="https://en.wikipedia.org/wiki/Insertion_sort">Wikipedia</a>:
      Insertion sort is a simple sorting algorithm that builds the final sorted
      array (or list) one item at a time. It is much less efficient on large
      lists than more advanced algorithms such as quicksort, heapsort, or merge
      sort.
    </p>
    <p><strong>Properties</strong></p>
    <ul>
      <li>Worst case performance O(n^2)</li>
      <li>Best case performance O(n)</li>
      <li>Average case performance O(n^2)</li>
    </ul>
    <h6 id="view-the-algorithm-in-actioninsertion-toptal">
      View the algorithm in
      <a
        href="https://www.toptal.com/developers/sorting-algorithms/insertion-sort"
        >action</a
      >
    </h6>
    <h3 id="quick">Quick</h3>
    <figure>
      <img
        src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif"
        title="Quick Sort"
        alt="alt text"
      />
      <figcaption>alt text</figcaption>
    </figure>
    <p>
      From <a href="https://en.wikipedia.org/wiki/Quicksort">Wikipedia</a>:
      Quicksort (sometimes called partition-exchange sort) is an efficient
      sorting algorithm, serving as a systematic method for placing the elements
      of an array in order.
    </p>
    <p><strong>Properties</strong></p>
    <ul>
      <li>Worst case performance O(n^2)</li>
      <li>Best case performance O(n log n) or O(n) with three-way partition</li>
      <li>Average case performance O(n^2)</li>
    </ul>
    <h6 id="view-the-algorithm-in-actionquick-toptal">
      View the algorithm in
      <a href="https://www.toptal.com/developers/sorting-algorithms/quick-sort"
        >action</a
      >
    </h6>
    <h3 id="selection">Selection</h3>
    <figure>
      <img
        src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b0/Selection_sort_animation.gif/250px-Selection_sort_animation.gif"
        title="Selection Sort Sort"
        alt="alt text"
      />
      <figcaption>alt text</figcaption>
    </figure>
    <p>
      From <a href="https://en.wikipedia.org/wiki/Selection_sort">Wikipedia</a>:
      The algorithm divides the input list into two parts: the sublist of items
      already sorted, which is built up from left to right at the front (left)
      of the list, and the sublist of items remaining to be sorted that occupy
      the rest of the list. Initially, the sorted sublist is empty and the
      unsorted sublist is the entire input list. The algorithm proceeds by
      finding the smallest (or largest, depending on sorting order) element in
      the unsorted sublist, exchanging (swapping) it with the leftmost unsorted
      element (putting it in sorted order), and moving the sublist boundaries
      one element to the right.
    </p>
    <p><strong>Properties</strong></p>
    <ul>
      <li>Worst case performance O(n^2)</li>
      <li>Best case performance O(n^2)</li>
      <li>Average case performance O(n^2)</li>
    </ul>
    <h6 id="view-the-algorithm-in-actionselection-toptal">
      View the algorithm in
      <a
        href="https://www.toptal.com/developers/sorting-algorithms/selection-sort"
        >action</a
      >
    </h6>
    <h3 id="merge">Merge</h3>
    <figure>
      <img
        src="https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif"
        title="Merge Sort"
        alt="alt text"
      />
      <figcaption>alt text</figcaption>
    </figure>
    <p>
      From <a href="https://en.wikipedia.org/wiki/Merge_sort">Wikipedia</a>:
      Merge sort (also commonly spelled mergesort) is a divide and conquer
      algorithm that was invented by John von Neumann in 1945. The algorithm
      dirst divides the list into the smallest unit (1 element), then compares
      each element with the adjacent list to sort and merge the two adjacent
      lists. Finally all the elements are sorted and merged. It is an efficient,
      general-purpose, comparison-based sorting algorithm.
    </p>
    <p><strong>Properties</strong></p>
    <ul>
      <li>Worst case performance O(n log n)</li>
      <li>Best case performance O(n log n)</li>
      <li>Average case performance O(n log n)</li>
    </ul>
    <h6 id="view-the-algorithm-in-actionmerge-toptal">
      View the algorithm in
      <a href="https://www.toptal.com/developers/sorting-algorithms/merge-sort"
        >action</a
      >
    </h6>
    <h3 id="shell">Shell</h3>
    <figure>
      <img
        src="https://upload.wikimedia.org/wikipedia/commons/d/d8/Sorting_shellsort_anim.gif"
        title="Shell Sort"
        alt="alt text"
      />
      <figcaption>alt text</figcaption>
    </figure>
    <p>
      From <a href="https://en.wikipedia.org/wiki/Shellsort">Wikipedia</a>:
      Shellsort is a generalization of insertion sort that allows the exchange
      of items that are far apart. The idea is to arrange the list of elements
      so that, starting anywhere, considering every nth element gives a sorted
      list. Such a list is said to be h-sorted. Equivalently, it can be thought
      of as h interleaved lists, each individually sorted.
    </p>
    <p><strong>Properties</strong></p>
    <ul>
      <li>Worst case performance O(nlog2 2n)</li>
      <li>Best case performance O(n log n)</li>
      <li>Average case performance depends on gap sequence</li>
    </ul>
    <h6 id="view-the-algorithm-in-actionshell-toptal">
      View the algorithm in
      <a href="https://www.toptal.com/developers/sorting-algorithms/shell-sort"
        >action</a
      >
    </h6>
    <h3 id="time-complexity-graphs">Time-Complexity Graphs</h3>
    <p>
      Comparing the complexity of sorting algorithms (Bubble Sort, Insertion
      Sort, Selection Sort)
    </p>
    <p>
      <a
        href="https://github.com/prateekiiest/Python/blob/master/sorts/sortinggraphs.png"
        >Complexity Graphs</a
      >
    </p>
    <hr />
    <h2 id="community-channel">Community Channel</h2>
    <p>
      We’re on <a href="https://gitter.im/TheAlgorithms">Gitter</a>! Please join
      us.
    </p>
    <h2 id="contribution">Contribution</h2>
    <p>
      Please read our
      <a
        href="https://github.com/TheAlgorithms/Dart/blob/master/CONTRIBUTING.md"
        >CONTRIBUTING.md</a
      >.
    </p>
    <h2 id="license">License</h2>
    <p>
      <a href="https://github.com/TheAlgorithms/Dart/blob/master/LICENSE"
        >MIT</a
      >
    </p>
  </body>
</html>
