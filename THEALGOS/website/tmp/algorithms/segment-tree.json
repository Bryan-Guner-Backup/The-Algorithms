{
  "slug": "segment-tree",
  "name": "Segment Tree",
  "categories": ["datastructures", "binarytree"],
  "body": {},
  "implementations": {
    "python": {
      "dir": "data_structures/binary_tree/segment_tree.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/data_structures/binary_tree/segment_tree.py",
      "code": "<span class=\"hljs-keyword\">import</span> math\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SegmentTree</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, A</span>):\n        self.N = <span class=\"hljs-built_in\">len</span>(A)\n        self.st = [<span class=\"hljs-number\">0</span>] * (\n            <span class=\"hljs-number\">4</span> * self.N\n        )  <span class=\"hljs-comment\"># approximate the overall size of segment tree with array N</span>\n        self.build(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, self.N - <span class=\"hljs-number\">1</span>)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">left</span>(<span class=\"hljs-params\">self, idx</span>):\n        <span class=\"hljs-keyword\">return</span> idx * <span class=\"hljs-number\">2</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">right</span>(<span class=\"hljs-params\">self, idx</span>):\n        <span class=\"hljs-keyword\">return</span> idx * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">self, idx, l, r</span>):  <span class=\"hljs-comment\"># noqa: E741</span>\n        <span class=\"hljs-keyword\">if</span> l == r:  <span class=\"hljs-comment\"># noqa: E741</span>\n            self.st[idx] = A[l]\n        <span class=\"hljs-keyword\">else</span>:\n            mid = (l + r) // <span class=\"hljs-number\">2</span>\n            self.build(self.left(idx), l, mid)\n            self.build(self.right(idx), mid + <span class=\"hljs-number\">1</span>, r)\n            self.st[idx] = <span class=\"hljs-built_in\">max</span>(self.st[self.left(idx)], self.st[self.right(idx)])\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">update</span>(<span class=\"hljs-params\">self, a, b, val</span>):\n        <span class=\"hljs-keyword\">return</span> self.update_recursive(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, self.N - <span class=\"hljs-number\">1</span>, a - <span class=\"hljs-number\">1</span>, b - <span class=\"hljs-number\">1</span>, val)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">update_recursive</span>(<span class=\"hljs-params\">self, idx, l, r, a, b, val</span>):  <span class=\"hljs-comment\"># noqa: E741</span>\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        update(1, 1, N, a, b, v) for update val v to [a,b]\n        &quot;&quot;&quot;</span>\n        <span class=\"hljs-keyword\">if</span> r &lt; a <span class=\"hljs-keyword\">or</span> l &gt; b:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n        <span class=\"hljs-keyword\">if</span> l == r:  <span class=\"hljs-comment\"># noqa: E741</span>\n            self.st[idx] = val\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n        mid = (l + r) // <span class=\"hljs-number\">2</span>\n        self.update_recursive(self.left(idx), l, mid, a, b, val)\n        self.update_recursive(self.right(idx), mid + <span class=\"hljs-number\">1</span>, r, a, b, val)\n        self.st[idx] = <span class=\"hljs-built_in\">max</span>(self.st[self.left(idx)], self.st[self.right(idx)])\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">query</span>(<span class=\"hljs-params\">self, a, b</span>):\n        <span class=\"hljs-keyword\">return</span> self.query_recursive(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, self.N - <span class=\"hljs-number\">1</span>, a - <span class=\"hljs-number\">1</span>, b - <span class=\"hljs-number\">1</span>)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">query_recursive</span>(<span class=\"hljs-params\">self, idx, l, r, a, b</span>):  <span class=\"hljs-comment\"># noqa: E741</span>\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        query(1, 1, N, a, b) for query max of [a,b]\n        &quot;&quot;&quot;</span>\n        <span class=\"hljs-keyword\">if</span> r &lt; a <span class=\"hljs-keyword\">or</span> l &gt; b:\n            <span class=\"hljs-keyword\">return</span> -math.inf\n        <span class=\"hljs-keyword\">if</span> l &gt;= a <span class=\"hljs-keyword\">and</span> r &lt;= b:  <span class=\"hljs-comment\"># noqa: E741</span>\n            <span class=\"hljs-keyword\">return</span> self.st[idx]\n        mid = (l + r) // <span class=\"hljs-number\">2</span>\n        q1 = self.query_recursive(self.left(idx), l, mid, a, b)\n        q2 = self.query_recursive(self.right(idx), mid + <span class=\"hljs-number\">1</span>, r, a, b)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">max</span>(q1, q2)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">showData</span>(<span class=\"hljs-params\">self</span>):\n        showList = []\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, N + <span class=\"hljs-number\">1</span>):\n            showList += [self.query(i, i)]\n        <span class=\"hljs-built_in\">print</span>(showList)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    A = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, -<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">3</span>, -<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">11</span>, -<span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">14</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>, -<span class=\"hljs-number\">8</span>]\n    N = <span class=\"hljs-number\">15</span>\n    segt = SegmentTree(A)\n    <span class=\"hljs-built_in\">print</span>(segt.query(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>))\n    <span class=\"hljs-built_in\">print</span>(segt.query(<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>))\n    <span class=\"hljs-built_in\">print</span>(segt.query(<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">12</span>))\n    segt.update(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">111</span>)\n    <span class=\"hljs-built_in\">print</span>(segt.query(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">15</span>))\n    segt.update(<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">235</span>)\n    segt.showData()\n"
    },
    "c": {
      "dir": "data_structures/binary_trees/segment_tree.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/data_structures/binary_trees/segment_tree.c",
      "code": "<span class=\"hljs-comment\">/**\n * @file segment_tree.c\n * @brief segment trees with only point updates\n * @details\n * This code implements segment trees. Segment trees are general structures\n * which allow range based queries in a given array in logN time.\n * Segment tree with point updates allow update of single element in the array\n * in logN time.\n * [Learn more about segment trees\n * here](https://codeforces.com/blog/entry/18051)\n * @author [Lakhan Nad](https://github.com/Lakhan-Nad)\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span>   <span class=\"hljs-comment\">/* for assert */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;inttypes.h&gt;</span> <span class=\"hljs-comment\">/* for int32 */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span>    <span class=\"hljs-comment\">/* for scanf printf */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span>   <span class=\"hljs-comment\">/* for malloc, free */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string.h&gt;</span>   <span class=\"hljs-comment\">/* for memcpy, memset */</span></span>\n\n<span class=\"hljs-comment\">/**\n * Function that combines two data to generate a new one\n * The name of function might be misleading actually combine here signifies the\n * fact that in segment trees we take partial result from two ranges and using\n * partial results we derive the result for joint range of those two ranges\n * For Example: array(1,2,3,4,5,6) sum of range [0,2] = 6\n * and sum of range [3,5] = 15 the combined sum of two range is 6+15=21\n * @note The function is same to binary function in Discrete Mathematics\n * @param a pointer to first data\n * @param b pointer to second data\n * @param result pointer to memory location where result of combining a and b is\n * to be stored\n */</span>\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-title function_\">void</span> <span class=\"hljs-params\">(*combine_function)</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">void</span> *a, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">void</span> *b, <span class=\"hljs-type\">void</span> *result)</span>;\n\n<span class=\"hljs-comment\">/**\n * This structures holds all the data that is required by a segment tree\n */</span>\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">segment_tree</span>\n{</span>\n    <span class=\"hljs-type\">void</span> *root;       <span class=\"hljs-comment\">/**&lt; the root of formed segment tree */</span>\n    <span class=\"hljs-type\">void</span> *identity;   <span class=\"hljs-comment\">/**&lt; identity element for combine function */</span>\n    <span class=\"hljs-type\">size_t</span> elem_size; <span class=\"hljs-comment\">/**&lt; size in bytes of each data element */</span>\n    <span class=\"hljs-type\">size_t</span> length;    <span class=\"hljs-comment\">/**&lt; total size of array which segment tree represents*/</span>\n    <span class=\"hljs-comment\">/** the function to be used to combine two node&#x27;s\n     * data to form parent&#x27;s data\n     */</span>\n    combine_function combine;\n} segment_tree;\n\n<span class=\"hljs-comment\">/**\n * Builds a Segment tree\n * It is assumed that leaves of tree already contains data.\n * @param tree pointer to segment tree to be build\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">segment_tree_build</span><span class=\"hljs-params\">(segment_tree *tree)</span>\n{\n    <span class=\"hljs-type\">size_t</span> elem_size = tree-&gt;elem_size;\n    <span class=\"hljs-type\">int</span> index = (tree-&gt;length - <span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-type\">size_t</span> b, l, r;\n    <span class=\"hljs-type\">char</span> *ptr = (<span class=\"hljs-type\">char</span> *)tree-&gt;root;\n    <span class=\"hljs-keyword\">for</span> (; index &gt;= <span class=\"hljs-number\">0</span>; index--)\n    {\n        b = index * elem_size;\n        l = (<span class=\"hljs-number\">2</span> * index + <span class=\"hljs-number\">1</span>) * elem_size;\n        r = (<span class=\"hljs-number\">2</span> * index + <span class=\"hljs-number\">2</span>) * elem_size;\n        tree-&gt;combine(ptr + l, ptr + r, ptr + b);\n    }\n}\n\n<span class=\"hljs-comment\">/**\n * For point updates\n * This function updates the element at given index and also updates segment\n * tree accordingly\n *\n * @param tree pointer to segment tree\n * @param index the index whose element is to be updated (0 based indexing used)\n * @param val pointer to value that is to be replaced at given index\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">segment_tree_update</span><span class=\"hljs-params\">(segment_tree *tree, <span class=\"hljs-type\">size_t</span> index, <span class=\"hljs-type\">void</span> *val)</span>\n{\n    <span class=\"hljs-type\">size_t</span> elem_size = tree-&gt;elem_size;\n    index = index + tree-&gt;length - <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-type\">char</span> *base = (<span class=\"hljs-type\">char</span> *)tree-&gt;root;\n    <span class=\"hljs-type\">char</span> *t = base + index * elem_size;\n    <span class=\"hljs-built_in\">memcpy</span>(t, val, elem_size);\n    <span class=\"hljs-keyword\">while</span> (index &gt; <span class=\"hljs-number\">0</span>)\n    {\n        index = ((index - <span class=\"hljs-number\">1</span>) &gt;&gt; <span class=\"hljs-number\">1</span>);\n        tree-&gt;combine(base + (<span class=\"hljs-number\">2</span> * index + <span class=\"hljs-number\">1</span>) * elem_size,\n                      base + (<span class=\"hljs-number\">2</span> * index + <span class=\"hljs-number\">2</span>) * elem_size,\n                      base + index * elem_size);\n    }\n}\n\n<span class=\"hljs-comment\">/**\n * Query the segment tree\n * This function helps in range query of segment tree\n * This function assumes that the given range is valid\n * Performs the query in range [l,r]\n * @param tree pointer to segment tree\n * @param l the start of range\n * @param r the end of range\n * @param res the pointer to memory where result of query is stored\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">segment_tree_query</span><span class=\"hljs-params\">(segment_tree *tree, <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> l, <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> r, <span class=\"hljs-type\">void</span> *res)</span>\n{\n    <span class=\"hljs-type\">size_t</span> elem_size = tree-&gt;elem_size;\n    <span class=\"hljs-built_in\">memcpy</span>(res, tree-&gt;identity, elem_size);\n    elem_size = tree-&gt;elem_size;\n    <span class=\"hljs-type\">char</span> *root = (<span class=\"hljs-type\">char</span> *)tree-&gt;root;\n    l += tree-&gt;length - <span class=\"hljs-number\">1</span>;\n    r += tree-&gt;length - <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">while</span> (l &lt;= r)\n    {\n        <span class=\"hljs-keyword\">if</span> (!(l &amp; <span class=\"hljs-number\">1</span>))\n        {\n            tree-&gt;combine(res, root + l * elem_size, res);\n        }\n        <span class=\"hljs-keyword\">if</span> (r &amp; <span class=\"hljs-number\">1</span>)\n        {\n            tree-&gt;combine(res, root + r * elem_size, res);\n        }\n        r = (r &gt;&gt; <span class=\"hljs-number\">1</span>) - <span class=\"hljs-number\">1</span>;\n        l = (l &gt;&gt; <span class=\"hljs-number\">1</span>);\n    }\n}\n\n<span class=\"hljs-comment\">/**\n * Initializes Segment Tree\n * Accquires memory for segment tree\n * and fill the leaves of segment tree with data from array\n * @param arr the array data upon which segment tree is build\n * @param elem_size size of each element in segment tree\n * @param len total no of elements in array\n * @param identity the identity element for combine_function\n * @param func the combine_function used to build segment tree\n *\n * @returns pointer to sgement tree build\n */</span>\nsegment_tree *<span class=\"hljs-title function_\">segment_tree_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *arr, <span class=\"hljs-type\">size_t</span> elem_size, <span class=\"hljs-type\">size_t</span> len,\n                                <span class=\"hljs-type\">void</span> *identity, combine_function func)</span>\n{\n    segment_tree *tree = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(segment_tree));\n    tree-&gt;elem_size = elem_size;\n    tree-&gt;length = len;\n    tree-&gt;combine = func;\n    tree-&gt;root = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">char</span>) * elem_size * (<span class=\"hljs-number\">2</span> * len - <span class=\"hljs-number\">1</span>));\n    tree-&gt;identity = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">char</span>) * elem_size);\n    <span class=\"hljs-type\">char</span> *ptr = (<span class=\"hljs-type\">char</span> *)tree-&gt;root;\n    <span class=\"hljs-built_in\">memset</span>(ptr, <span class=\"hljs-number\">0</span>, (len - <span class=\"hljs-number\">1</span>) * elem_size);  <span class=\"hljs-comment\">// Initializing memory</span>\n    ptr = ptr + (len - <span class=\"hljs-number\">1</span>) * elem_size;\n    <span class=\"hljs-built_in\">memcpy</span>(ptr, arr, elem_size * len);  <span class=\"hljs-comment\">// copy the leaf nodes i.e. array data</span>\n    <span class=\"hljs-built_in\">memcpy</span>(tree-&gt;identity, identity, elem_size);  <span class=\"hljs-comment\">// copy identity element</span>\n    <span class=\"hljs-keyword\">return</span> tree;\n}\n\n<span class=\"hljs-comment\">/**\n * Dispose Segment Tree\n * Frees all heap memory accquired by segment tree\n * @param tree pointer to segment tree\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">segment_tree_dispose</span><span class=\"hljs-params\">(segment_tree *tree)</span>\n{\n    <span class=\"hljs-built_in\">free</span>(tree-&gt;root);\n    <span class=\"hljs-built_in\">free</span>(tree-&gt;identity);\n}\n\n<span class=\"hljs-comment\">/**\n * Prints the data in segment tree\n * The data should be of int type\n * A utility to print segment tree\n * with data type of int\n * @param tree pointer to segment tree\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">segment_tree_print_int</span><span class=\"hljs-params\">(segment_tree *tree)</span>\n{\n    <span class=\"hljs-type\">char</span> *base = (<span class=\"hljs-type\">char</span> *)tree-&gt;root;\n    <span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">for</span> (; i &lt; <span class=\"hljs-number\">2</span> * tree-&gt;length - <span class=\"hljs-number\">1</span>; i++)\n    {\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d &quot;</span>, *(<span class=\"hljs-type\">int</span> *)(base + i * tree-&gt;elem_size));\n    }\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>);\n}\n\n<span class=\"hljs-comment\">/**\n * Utility for test\n * A function compare for minimum between two integers\n * This function is used as combine_function for RMQ\n * @param a pointer to integer a\n * @param b pointer to integer b\n * @param c pointer where minimum of a and b is tored as result\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">minimum</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">void</span> *a, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">void</span> *b, <span class=\"hljs-type\">void</span> *c)</span>\n{\n    *(<span class=\"hljs-type\">int</span> *)c = *(<span class=\"hljs-type\">int</span> *)a &lt; *(<span class=\"hljs-type\">int</span> *)b ? *(<span class=\"hljs-type\">int</span> *)a : *(<span class=\"hljs-type\">int</span> *)b;\n}\n\n<span class=\"hljs-comment\">/**\n * Test RMQ\n * Testing Segment tree using\n * Range Minimum Queries\n * @returns void\n */</span>\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">()</span>\n{\n    <span class=\"hljs-type\">int32_t</span> arr[<span class=\"hljs-number\">10</span>] = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">-2</span>, <span class=\"hljs-number\">8</span>};\n    <span class=\"hljs-type\">int32_t</span> identity = __INT32_MAX__;\n    segment_tree *tree =\n        segment_tree_init(arr, <span class=\"hljs-keyword\">sizeof</span>(*arr), <span class=\"hljs-number\">10</span>, &amp;identity, minimum);\n    segment_tree_build(tree);\n    <span class=\"hljs-type\">int32_t</span> result;\n    segment_tree_query(tree, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>, &amp;result);\n    assert(result == <span class=\"hljs-number\">2</span>);\n    segment_tree_query(tree, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>, &amp;result);\n    assert(result == <span class=\"hljs-number\">-2</span>);\n    result = <span class=\"hljs-number\">12</span>;\n    segment_tree_update(tree, <span class=\"hljs-number\">5</span>, &amp;result);\n    segment_tree_update(tree, <span class=\"hljs-number\">8</span>, &amp;result);\n    segment_tree_query(tree, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, &amp;result);\n    assert(result == <span class=\"hljs-number\">0</span>);\n    segment_tree_query(tree, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>, &amp;result);\n    assert(result == <span class=\"hljs-number\">8</span>);\n    segment_tree_dispose(tree);\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Main Function\n * @returns 0 on exit\n */</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span>\n{\n    test();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "c-sharp": {
      "dir": "DataStructures/SegmentTrees/SegmentTree.cs",
      "url": "https://github.com/TheAlgorithms/C-Sharp/blob/master/DataStructures/SegmentTrees/SegmentTree.cs",
      "code": "<span class=\"hljs-keyword\">using</span> System;\n\n<span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">DataStructures.SegmentTrees</span>\n{\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Goal:   Data structure with which you can quickly perform queries on an array (i.e. sum of subarray)</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     and at the same time efficiently update an entry</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     or apply a distributive operation to a subarray.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Idea:   Preprocessing special queries</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Hint:   The query operation HAS to be associative (in this example addition).</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SegmentTree</span>\n    {\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Initializes a new instance of the <span class=\"hljs-doctag\">&lt;see cref=&quot;SegmentTree&quot; /&gt;</span> class.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Runtime complexity: O(n) where n equals the array-length.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;arr&quot;&gt;</span>Array on which the queries should be made.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">SegmentTree</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span>[] arr</span>)</span>\n        {\n            <span class=\"hljs-comment\">// Calculates next power of two</span>\n            <span class=\"hljs-keyword\">var</span> pow = (<span class=\"hljs-built_in\">int</span>)Math.Pow(<span class=\"hljs-number\">2</span>, Math.Ceiling(Math.Log(arr.Length, <span class=\"hljs-number\">2</span>)));\n            Tree = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[<span class=\"hljs-number\">2</span> * pow];\n\n            <span class=\"hljs-comment\">// Transfers the input array into the last half of the segment tree array</span>\n            Array.Copy(arr, <span class=\"hljs-number\">0</span>, Tree, pow, arr.Length);\n\n            <span class=\"hljs-comment\">// Calculates the first half</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = pow - <span class=\"hljs-number\">1</span>; i &gt; <span class=\"hljs-number\">0</span>; --i)\n            {\n                Tree[i] = Tree[Left(i)] + Tree[Right(i)];\n            }\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span>Gets the segment tree array.<span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span>[] Tree { <span class=\"hljs-keyword\">get</span>; }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Starts a query.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Runtime complexity: O(logN) where n equals the array-length.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;l&quot;&gt;</span>Left border of the query.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;r&quot;&gt;</span>Right border of the query.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Sum of the subarray between <span class=\"hljs-doctag\">&lt;c&gt;</span>l<span class=\"hljs-doctag\">&lt;/c&gt;</span> and <span class=\"hljs-doctag\">&lt;c&gt;</span>r<span class=\"hljs-doctag\">&lt;/c&gt;</span> (including <span class=\"hljs-doctag\">&lt;c&gt;</span>l<span class=\"hljs-doctag\">&lt;/c&gt;</span> and <span class=\"hljs-doctag\">&lt;c&gt;</span>r<span class=\"hljs-doctag\">&lt;/c&gt;</span>).<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-comment\">// Editing of query start at node with 1.</span>\n        <span class=\"hljs-comment\">// Node with index 1 includes the whole input subarray.</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> <span class=\"hljs-title\">Query</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span> l, <span class=\"hljs-built_in\">int</span> r</span>)</span> =&gt;\n            Query(++l, ++r, <span class=\"hljs-number\">1</span>, Tree.Length / <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>);\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Calculates the right child of a node.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;node&quot;&gt;</span>Current node.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Index of the right child.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-built_in\">int</span> <span class=\"hljs-title\">Right</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span> node</span>)</span> =&gt; <span class=\"hljs-number\">2</span> * node + <span class=\"hljs-number\">1</span>;\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Calculates the left child of a node.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;node&quot;&gt;</span>Current node.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Index of the left child.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-built_in\">int</span> <span class=\"hljs-title\">Left</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span> node</span>)</span> =&gt; <span class=\"hljs-number\">2</span> * node;\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Calculates the parent of a node.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;node&quot;&gt;</span>Current node.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Index of the parent node.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-built_in\">int</span> <span class=\"hljs-title\">Parent</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span> node</span>)</span> =&gt; node / <span class=\"hljs-number\">2</span>;\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Edits a query.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;l&quot;&gt;</span>Left border of the query.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;r&quot;&gt;</span>Right border of the query.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;a&quot;&gt;</span>Left end of the subarray enclosed by <span class=\"hljs-doctag\">&lt;c&gt;</span>i<span class=\"hljs-doctag\">&lt;/c&gt;</span>.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;b&quot;&gt;</span>Right end of the subarray enclosed by <span class=\"hljs-doctag\">&lt;c&gt;</span>i<span class=\"hljs-doctag\">&lt;/c&gt;</span>.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;i&quot;&gt;</span>Current node.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Sum of a subarray between <span class=\"hljs-doctag\">&lt;c&gt;</span>l<span class=\"hljs-doctag\">&lt;/c&gt;</span> and <span class=\"hljs-doctag\">&lt;c&gt;</span>r<span class=\"hljs-doctag\">&lt;/c&gt;</span> (including <span class=\"hljs-doctag\">&lt;c&gt;</span>l<span class=\"hljs-doctag\">&lt;/c&gt;</span> and <span class=\"hljs-doctag\">&lt;c&gt;</span>r<span class=\"hljs-doctag\">&lt;/c&gt;</span>).<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-built_in\">int</span> <span class=\"hljs-title\">Query</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span> l, <span class=\"hljs-built_in\">int</span> r, <span class=\"hljs-built_in\">int</span> a, <span class=\"hljs-built_in\">int</span> b, <span class=\"hljs-built_in\">int</span> i</span>)</span>\n        {\n            <span class=\"hljs-comment\">// If a and b are in the (by l and r) specified subarray</span>\n            <span class=\"hljs-keyword\">if</span> (l &lt;= a &amp;&amp; b &lt;= r)\n            {\n                <span class=\"hljs-keyword\">return</span> Tree[i];\n            }\n\n            <span class=\"hljs-comment\">// If a or b are out of the by l and r specified subarray</span>\n            <span class=\"hljs-keyword\">if</span> (r &lt; a || b &lt; l)\n            {\n                <span class=\"hljs-comment\">// Returns the neutral value of the operation</span>\n                <span class=\"hljs-comment\">// (in this case 0, because x + 0 = x)</span>\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n            }\n\n            <span class=\"hljs-comment\">// Calculates index m of the node that cuts the current subarray in half</span>\n            <span class=\"hljs-keyword\">var</span> m = (a + b) / <span class=\"hljs-number\">2</span>;\n\n            <span class=\"hljs-comment\">// Start query of new two subarrays a:m and m+1:b</span>\n            <span class=\"hljs-comment\">// The right and left child cover this intervals</span>\n            <span class=\"hljs-keyword\">return</span> Query(l, r, a, m, Left(i)) + Query(l, r, m + <span class=\"hljs-number\">1</span>, b, Right(i));\n        }\n    }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "lakhan_nad",
      "email": "lakhannad1999@gmail.com",
      "commits": 1
    },
    {
      "name": "Anshul",
      "email": "malikanshul29@gmail.com",
      "commits": 1
    },
    {
      "name": "AlexDvorak",
      "email": "opti.jawsome@gmail.com",
      "commits": 1
    },
    {
      "name": "Antony",
      "email": "45163503+DuckNrOne@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "cclauss",
      "email": "cclauss@bluewin.ch",
      "commits": 1
    },
    {
      "name": "97arushisharma",
      "email": "97arushisharma@gmail.com",
      "commits": 1
    },
    {
      "name": "Sarot Busala",
      "email": "sabuza97@gmail.com",
      "commits": 1
    },
    {
      "name": "Andrii Siriak",
      "email": "siryaka@gmail.com",
      "commits": 2
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 3
    }
  ],
  "explanationUrl": {}
}
