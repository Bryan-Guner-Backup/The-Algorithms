{
  "slug": "trie-multiple-search",
  "name": "Trie Multiple Search",
  "categories": ["operationsondatastructures"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "operations_on_datastructures/trie_multiple_search.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/operations_on_datastructures/trie_multiple_search.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file\r\n * @brief [Trie datastructure](https://iq.opengenus.org/autocomplete-using-trie-data-structure/)\r\n * with search variants\r\n * @details\r\n * This provides multiple variants of search functions\r\n * on a trie structure utilizing STL. The trie is valid\r\n * for only English alphabets.\r\n * @author [Ghanashyam](https://github.com/g-s-k-zoro)\r\n */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span>  <span class=\"hljs-comment\">/// for std::count</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>    <span class=\"hljs-comment\">/// for assert</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cctype&gt;</span>     <span class=\"hljs-comment\">/// for tolower</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstring&gt;</span>    <span class=\"hljs-comment\">/// for string operations</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>   <span class=\"hljs-comment\">/// for IO Operations</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span>      <span class=\"hljs-comment\">/// for std::priority_queue</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @namespace operations_on_datastructures\r\n * @brief Operations on data structures\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> operations_on_datastructures {\r\n<span class=\"hljs-comment\">/**\r\n * @namespace trie_operations\r\n * @brief Functions for [Trie datastructure](https://iq.opengenus.org/autocomplete-using-trie-data-structure/)\r\n * implementation\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> trie_operations {\r\n<span class=\"hljs-comment\">/**\r\n * @brief Class defining the structure of trie node and containing the methods\r\n * to perform operations on them.\r\n */</span>\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Tnode</span> {\r\n <span class=\"hljs-keyword\">private</span>:\r\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">uint8_t</span> ENGLISH_ALPHABET_SIZE = <span class=\"hljs-number\">26</span>;\r\n    <span class=\"hljs-comment\">// pointers to alphabets</span>\r\n    std::vector&lt;Tnode *&gt; english;\r\n\r\n    <span class=\"hljs-comment\">// To mark the end of word</span>\r\n    <span class=\"hljs-type\">bool</span> endOfWord;\r\n\r\n    <span class=\"hljs-comment\">// To store the frequency of searches for the word</span>\r\n    <span class=\"hljs-type\">uint32_t</span> frequency;\r\n\r\n <span class=\"hljs-keyword\">public</span>:\r\n    <span class=\"hljs-built_in\">Tnode</span>() {\r\n        english.<span class=\"hljs-built_in\">resize</span>(ENGLISH_ALPHABET_SIZE, <span class=\"hljs-literal\">nullptr</span>);\r\n        endOfWord = <span class=\"hljs-literal\">false</span>;\r\n        frequency = <span class=\"hljs-number\">0</span>;\r\n    }\r\n    <span class=\"hljs-comment\">// Copy Constructor</span>\r\n    <span class=\"hljs-built_in\">Tnode</span>(<span class=\"hljs-keyword\">const</span> Tnode &amp;node) {\r\n        english = node.english;\r\n        endOfWord = node.endOfWord;\r\n        frequency = node.frequency;\r\n    }\r\n\r\n    Tnode &amp;<span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-keyword\">const</span> Tnode &amp;node) = <span class=\"hljs-keyword\">default</span>;\r\n\r\n    <span class=\"hljs-built_in\">Tnode</span>(Tnode &amp;&amp;) = <span class=\"hljs-keyword\">default</span>;\r\n\r\n    Tnode &amp;<span class=\"hljs-keyword\">operator</span>=(Tnode &amp;&amp;) = <span class=\"hljs-keyword\">default</span>;\r\n    <span class=\"hljs-comment\">/**\r\n     * @brief Function to count the number of children a node in the trie has\r\n     * @param node a trie node whose children need to be counted\r\n     * @return count of the number of children of the given node (max 26)\r\n     */</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">uint8_t</span> <span class=\"hljs-title\">numberOfChildren</span><span class=\"hljs-params\">(Tnode *node)</span> </span>{\r\n        <span class=\"hljs-keyword\">return</span> ENGLISH_ALPHABET_SIZE -\r\n               std::<span class=\"hljs-built_in\">count</span>(node-&gt;english.<span class=\"hljs-built_in\">begin</span>(), node-&gt;english.<span class=\"hljs-built_in\">end</span>(), <span class=\"hljs-literal\">nullptr</span>);\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// Functions to perform operations on trie</span>\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Insert</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string &amp;entry)</span></span>;\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Delete</span><span class=\"hljs-params\">(std::string entry)</span></span>;\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">DeleteFrom</span><span class=\"hljs-params\">(Tnode *delete_from, std::string delete_string,\r\n                    <span class=\"hljs-type\">int</span> remove_index)</span></span>;\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">SearchPresence</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string &amp;key)</span></span>;\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SuggestAutocomplete</span><span class=\"hljs-params\">(Tnode *new_root, <span class=\"hljs-keyword\">const</span> std::string &amp;prefix)</span></span>;\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SearchSuggestions</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string &amp;key)</span></span>;\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SuggestFreqAutocomplete</span><span class=\"hljs-params\">(\r\n        Tnode *new_root, <span class=\"hljs-keyword\">const</span> std::string &amp;prefix,\r\n        std::priority_queue&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, std::string&gt; &gt; *suggestions)</span></span>;\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SearchFreqSuggestions</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string &amp;key)</span></span>;\r\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SelectionTop_3</span><span class=\"hljs-params\">(\r\n        std::priority_queue&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, std::string&gt; &gt; *suggestions)</span></span>;\r\n\r\n    <span class=\"hljs-comment\">// To free up the dynamically allocated objects</span>\r\n    ~<span class=\"hljs-built_in\">Tnode</span>() {\r\n        <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;\r\n        <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; ENGLISH_ALPHABET_SIZE; i++) {\r\n            <span class=\"hljs-keyword\">if</span> (english[i]) {\r\n                <span class=\"hljs-keyword\">delete</span> english[i];\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Function to insert a word in the trie\r\n * @param entry string entry to be inserted in the trie\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Tnode::Insert</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string &amp;entry)</span> </span>{\r\n    Tnode *cur_pos = <span class=\"hljs-keyword\">this</span>;\r\n    <span class=\"hljs-type\">int</span> letter_index = <span class=\"hljs-number\">0</span>;\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;i : entry) {\r\n        <span class=\"hljs-comment\">// To ignore case</span>\r\n        letter_index = <span class=\"hljs-built_in\">tolower</span>(i) - <span class=\"hljs-number\">97</span>;\r\n\r\n        <span class=\"hljs-comment\">// Allocate a node for each character of entry if not present in the</span>\r\n        <span class=\"hljs-comment\">// trie</span>\r\n        <span class=\"hljs-keyword\">if</span> (cur_pos-&gt;english[letter_index] == <span class=\"hljs-literal\">nullptr</span>) {\r\n            cur_pos-&gt;english[letter_index] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Tnode</span>();\r\n        }\r\n\r\n        cur_pos = cur_pos-&gt;english[letter_index];\r\n    }\r\n    <span class=\"hljs-comment\">// cur_pos points to the last char, mark it as end of word</span>\r\n    cur_pos-&gt;endOfWord = <span class=\"hljs-literal\">true</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Function recursively deletes the substring character by\r\n * character iterating through the string to be deleted. It traverses till the\r\n * end of word in a recursive fashion, from there it deletes characters one by\r\n * one till it reaches back to the initial call.\r\n * @param delete_from the acting root to the required suffix to be deleted\r\n * @param delete_string the string to be deleted from the trie\r\n * @param remove_index index denoting the beginning of the substring to be\r\n * deleted\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Tnode::DeleteFrom</span><span class=\"hljs-params\">(Tnode *delete_from, std::string delete_string,\r\n                       <span class=\"hljs-type\">int</span> remove_index)</span> </span>{\r\n    <span class=\"hljs-keyword\">if</span> (delete_string.<span class=\"hljs-built_in\">size</span>() == remove_index) {\r\n        <span class=\"hljs-type\">int</span> letter_index = <span class=\"hljs-built_in\">tolower</span>(delete_string[remove_index]) - <span class=\"hljs-number\">97</span>;\r\n\r\n        <span class=\"hljs-built_in\">DeleteFrom</span>(delete_from-&gt;english[letter_index], delete_string,\r\n                   remove_index + <span class=\"hljs-number\">1</span>);\r\n\r\n        <span class=\"hljs-keyword\">delete</span> delete_from;\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Function to verify presence and hence delete an entry from the trie\r\n * @param entry string entry to be deleted from the trie\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Tnode::Delete</span><span class=\"hljs-params\">(std::string entry)</span> </span>{\r\n    Tnode *cur_pos = <span class=\"hljs-keyword\">this</span>,\r\n          *delete_from = <span class=\"hljs-keyword\">this</span>;  <span class=\"hljs-comment\">// Current pointer pointing to root</span>\r\n    <span class=\"hljs-type\">int</span> letter_index = <span class=\"hljs-number\">0</span>, delete_from_index = <span class=\"hljs-number\">0</span>, i = <span class=\"hljs-number\">0</span>, n = entry.<span class=\"hljs-built_in\">size</span>();\r\n\r\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; n; i++) {\r\n        <span class=\"hljs-comment\">// To ignore case</span>\r\n        letter_index = <span class=\"hljs-built_in\">tolower</span>(entry[i]) - <span class=\"hljs-number\">97</span>;\r\n\r\n        <span class=\"hljs-comment\">// Display error message when given entry is not present in the tree</span>\r\n        <span class=\"hljs-keyword\">if</span> (cur_pos-&gt;english[letter_index] == <span class=\"hljs-literal\">nullptr</span>) {\r\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Entry not Found&quot;</span> &lt;&lt; std::endl;\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n        <span class=\"hljs-comment\">// If the current node is end of word for the current prefix or if it</span>\r\n        <span class=\"hljs-comment\">// has 2 or more branches It cannot be deleted while deleting the</span>\r\n        <span class=\"hljs-comment\">// required entry.</span>\r\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">numberOfChildren</span>(cur_pos) &gt; <span class=\"hljs-number\">1</span> || cur_pos-&gt;endOfWord) {\r\n            delete_from = cur_pos;      <span class=\"hljs-comment\">// denotes the beginning of the shortest</span>\r\n                                        <span class=\"hljs-comment\">// suffix that is allowed to be deleted</span>\r\n            delete_from_index = i - <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">// Beginning index of the suffix</span>\r\n                                        <span class=\"hljs-comment\">// corresponding to the &#x27;entry&#x27;</span>\r\n        }\r\n\r\n        <span class=\"hljs-comment\">// Traversing through the entry</span>\r\n        cur_pos = cur_pos-&gt;english[letter_index];\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// cur_pos now points to the last char of entry. Display message if that</span>\r\n    <span class=\"hljs-comment\">// entry does not exist</span>\r\n    <span class=\"hljs-keyword\">if</span> (!cur_pos-&gt;endOfWord) {\r\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Entry not Found&quot;</span> &lt;&lt; std::endl;\r\n        <span class=\"hljs-keyword\">return</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// If cur_pos is not a leaf node, unmark end of word and assign 0 to it&#x27;s</span>\r\n    <span class=\"hljs-comment\">// frequency for deletion</span>\r\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">numberOfChildren</span>(cur_pos)) {\r\n        cur_pos-&gt;endOfWord = <span class=\"hljs-literal\">false</span>;\r\n        cur_pos-&gt;frequency = <span class=\"hljs-number\">0</span>;\r\n        <span class=\"hljs-keyword\">return</span>;\r\n    }\r\n\r\n    <span class=\"hljs-comment\">// The first character of the suffix to be deleted</span>\r\n    letter_index = <span class=\"hljs-built_in\">tolower</span>(entry[delete_from_index + <span class=\"hljs-number\">1</span>]) - <span class=\"hljs-number\">97</span>;\r\n    <span class=\"hljs-comment\">// Point cur_pos to the next node</span>\r\n    cur_pos = delete_from-&gt;english[letter_index];\r\n    <span class=\"hljs-comment\">// Sever the connection from the main trie</span>\r\n    delete_from-&gt;english[letter_index] = <span class=\"hljs-literal\">nullptr</span>;\r\n\r\n    <span class=\"hljs-comment\">// If number of characters in the suffix are more than 1, recursively delete</span>\r\n    <span class=\"hljs-comment\">// each character starting from cur_pos using the helper function</span>\r\n    <span class=\"hljs-keyword\">if</span> (n &gt; delete_from_index + <span class=\"hljs-number\">2</span>) {\r\n        <span class=\"hljs-built_in\">DeleteFrom</span>(cur_pos, entry, delete_from_index + <span class=\"hljs-number\">2</span>);\r\n    }\r\n    <span class=\"hljs-comment\">// If the suffix is only 1 char in length</span>\r\n    <span class=\"hljs-keyword\">else</span> {\r\n        <span class=\"hljs-keyword\">delete</span> cur_pos;\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Function to check a word&#x27;s presence in the trie (Basic)\r\n * @param key the string key to be searched in the trie\r\n * @return true if the key is found\r\n * @return false if the key is not found\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">Tnode::SearchPresence</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string &amp;key)</span> </span>{\r\n    Tnode *cur_pos = <span class=\"hljs-keyword\">this</span>;\r\n    <span class=\"hljs-type\">int</span> letter_index = <span class=\"hljs-number\">0</span>;\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;i : key) {\r\n        letter_index = <span class=\"hljs-built_in\">tolower</span>(i) - <span class=\"hljs-number\">97</span>;\r\n        <span class=\"hljs-comment\">// If any character in the order of the key is absent, word not found!</span>\r\n        <span class=\"hljs-keyword\">if</span> (cur_pos-&gt;english[letter_index] == <span class=\"hljs-literal\">nullptr</span>) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n        }\r\n        cur_pos = cur_pos-&gt;english[letter_index];\r\n    }\r\n    <span class=\"hljs-comment\">// Word is only present in the trie if the key is a valid complete entry and</span>\r\n    <span class=\"hljs-comment\">// not just a prefix.</span>\r\n    <span class=\"hljs-keyword\">if</span> (cur_pos-&gt;endOfWord) {\r\n        (cur_pos-&gt;frequency)++;\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\r\n    } <span class=\"hljs-keyword\">else</span> {\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Recursive function to suggest all the entries of trie\r\n * which have a given common prefix\r\n * @param new_root pointer pointing to the node corresponding to the last char\r\n * of prefix\r\n * @param prefix the common prefix that all the suggestions must have\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Tnode::SuggestAutocomplete</span><span class=\"hljs-params\">(Tnode *new_root, <span class=\"hljs-keyword\">const</span> std::string &amp;prefix)</span> </span>{\r\n    <span class=\"hljs-comment\">// Iterate through all 26 nodes as we have to print all strings with the</span>\r\n    <span class=\"hljs-comment\">// given prefix</span>\r\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; ENGLISH_ALPHABET_SIZE; i++) {\r\n        <span class=\"hljs-keyword\">if</span> (new_root-&gt;english[i] != <span class=\"hljs-literal\">nullptr</span>) {\r\n            <span class=\"hljs-comment\">// Print the sugestion only if it&#x27;s a valid complete entry and not</span>\r\n            <span class=\"hljs-comment\">// just a prefix</span>\r\n            <span class=\"hljs-keyword\">if</span> (new_root-&gt;english[i]-&gt;endOfWord) {\r\n                std::cout &lt;&lt; prefix + <span class=\"hljs-built_in\">char</span>(i + <span class=\"hljs-number\">97</span>) &lt;&lt; std::endl;\r\n            }\r\n\r\n            <span class=\"hljs-built_in\">SuggestAutocomplete</span>(new_root-&gt;english[i], prefix + <span class=\"hljs-built_in\">char</span>(i + <span class=\"hljs-number\">97</span>));\r\n        }\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Lists out all the words in trie with the longest prefix\r\n * of the search key that is present in the trie. For example - if trie contains\r\n * &quot;abc&quot;, &quot;abcde&quot;, &quot;abcdefg&quot;, &quot;abcddef&quot; and if the search key is &quot;abcdezz&quot;, then\r\n * the longest common prefix is &quot;abcde&quot; and hence search results will be\r\n * &quot;abcde&quot;, &quot;abcdefg&quot;.\r\n * @param key the string key to be searched for suggestions\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Tnode::SearchSuggestions</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string &amp;key)</span> </span>{\r\n    Tnode *cur_pos = <span class=\"hljs-literal\">nullptr</span>, *prev_pos = <span class=\"hljs-literal\">nullptr</span>;\r\n    cur_pos = prev_pos = <span class=\"hljs-keyword\">this</span>;  <span class=\"hljs-comment\">// maintaining 2 pointers, initialized to root</span>\r\n    <span class=\"hljs-type\">int</span> letter_index = <span class=\"hljs-number\">0</span>;\r\n    std::string prefix =\r\n        <span class=\"hljs-string\">&quot;&quot;</span>;  <span class=\"hljs-comment\">// variable storing the updated value of longest common prefix</span>\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;i : key) {\r\n        letter_index = <span class=\"hljs-built_in\">tolower</span>(i) - <span class=\"hljs-number\">97</span>;\r\n        prev_pos = cur_pos;  <span class=\"hljs-comment\">// Previous pointer updated to point to the last</span>\r\n                             <span class=\"hljs-comment\">// char of the longest common prefix</span>\r\n\r\n        <span class=\"hljs-comment\">// When the node for the character does not exist, longest prefix has</span>\r\n        <span class=\"hljs-comment\">// been determined and SuggestAutocomplete is called</span>\r\n        <span class=\"hljs-keyword\">if</span> (cur_pos-&gt;english[letter_index] == <span class=\"hljs-literal\">nullptr</span>) {\r\n            <span class=\"hljs-built_in\">SuggestAutocomplete</span>(prev_pos, prefix);\r\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - &quot;</span>\r\n                      &lt;&lt; std::endl;\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n        <span class=\"hljs-comment\">// Updating the longest common prefix</span>\r\n        prefix += <span class=\"hljs-built_in\">char</span>(<span class=\"hljs-built_in\">tolower</span>(i));\r\n        cur_pos = cur_pos-&gt;english[letter_index];\r\n    }\r\n    <span class=\"hljs-comment\">// If the key is a valid entry of trie, display it @ top of the suggestions</span>\r\n    <span class=\"hljs-keyword\">if</span> (cur_pos-&gt;endOfWord) {\r\n        std::cout &lt;&lt; key &lt;&lt; std::endl;\r\n        (cur_pos-&gt;frequency)++;\r\n    }\r\n\r\n    (<span class=\"hljs-type\">void</span>)prev_pos;  <span class=\"hljs-comment\">// Idiom to ignore previous pointer</span>\r\n\r\n    <span class=\"hljs-comment\">// Call for suggestions when the search key is present as an entry/a prefix</span>\r\n    <span class=\"hljs-comment\">// in the trie</span>\r\n    <span class=\"hljs-built_in\">SuggestAutocomplete</span>(cur_pos, prefix);\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - &quot;</span>\r\n              &lt;&lt; std::endl;\r\n    <span class=\"hljs-keyword\">return</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Function to display the 3 suggestions with highest frequency\r\n * of search hits\r\n * @param suggestions a max heap that contains pairs of (frequency, word)\r\n * heapified based on frequency\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Tnode::SelectionTop_3</span><span class=\"hljs-params\">(\r\n    std::priority_queue&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, std::string&gt; &gt; *suggestions)</span> </span>{\r\n    <span class=\"hljs-comment\">// Display Either top 3 or total number of suggestions, whichever is smaller</span>\r\n    <span class=\"hljs-type\">int</span> n = suggestions-&gt;<span class=\"hljs-built_in\">size</span>(), Top = <span class=\"hljs-number\">0</span>;\r\n    Top = n &lt; <span class=\"hljs-number\">3</span> ? n : <span class=\"hljs-number\">3</span>;\r\n    <span class=\"hljs-keyword\">while</span> (Top--) {\r\n        std::cout &lt;&lt; suggestions-&gt;<span class=\"hljs-built_in\">top</span>().second &lt;&lt; std::endl;\r\n        suggestions-&gt;<span class=\"hljs-built_in\">pop</span>();\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Recursive function to suggest most frequently\r\n * searched entries of trie which have a given common prefix\r\n * @param new_root pointer pointing to the node corresponding to the last char\r\n * of prefix\r\n * @param prefix the common prefix that all the suggestions must have\r\n * @param suggestions a max heap that contains pairs of (frequency, word)\r\n * heapified based on frequency\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Tnode::SuggestFreqAutocomplete</span><span class=\"hljs-params\">(\r\n    Tnode *new_root, <span class=\"hljs-keyword\">const</span> std::string &amp;prefix,\r\n    std::priority_queue&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, std::string&gt; &gt; *suggestions)</span> </span>{\r\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; ENGLISH_ALPHABET_SIZE; i++) {\r\n        <span class=\"hljs-keyword\">if</span> (new_root-&gt;english[i] != <span class=\"hljs-literal\">nullptr</span>) {\r\n            <span class=\"hljs-comment\">// Add to sugestions only if it&#x27;s a valid complete entry and not</span>\r\n            <span class=\"hljs-comment\">// just a prefix</span>\r\n            <span class=\"hljs-keyword\">if</span> (new_root-&gt;english[i]-&gt;endOfWord) {\r\n                suggestions-&gt;<span class=\"hljs-built_in\">push</span>(std::<span class=\"hljs-built_in\">make_pair</span>(\r\n                    new_root-&gt;english[i]-&gt;frequency, prefix + <span class=\"hljs-built_in\">char</span>(i + <span class=\"hljs-number\">97</span>)));\r\n            }\r\n\r\n            <span class=\"hljs-built_in\">SuggestFreqAutocomplete</span>(new_root-&gt;english[i], prefix + <span class=\"hljs-built_in\">char</span>(i + <span class=\"hljs-number\">97</span>),\r\n                                    suggestions);\r\n        }\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Lists out the most frequent words in trie with the\r\n * longest prefix of the search key that is present in the trie. For example -\r\n * if trie contains &quot;abc&quot;, &quot;abcde&quot;, &quot;abcdefg&quot;, &quot;abcddef&quot; and they have been\r\n * previously searched for 3, 1, 2, 4 times respectively, if the search key is\r\n * &quot;ab&quot;, then the longest common prefix is &quot;ab&quot; and only the top 3 frequencies\r\n * among the matches would be displayed viz. &quot;abcddef&quot;, &quot;abc&quot;, &quot;abcdefg&quot;.\r\n * @param key the string key to be searched for suggestions\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Tnode::SearchFreqSuggestions</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string &amp;key)</span> </span>{\r\n    Tnode *cur_pos = <span class=\"hljs-literal\">nullptr</span>, *prev_pos = <span class=\"hljs-literal\">nullptr</span>;\r\n    cur_pos = prev_pos = <span class=\"hljs-keyword\">this</span>;  <span class=\"hljs-comment\">// maintaining 2 pointers, initialized to root</span>\r\n    <span class=\"hljs-type\">int</span> letter_index = <span class=\"hljs-number\">0</span>;\r\n    std::string prefix =\r\n        <span class=\"hljs-string\">&quot;&quot;</span>;  <span class=\"hljs-comment\">// variable storing the updated value of longest common prefix</span>\r\n    std::priority_queue&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, std::string&gt; &gt;\r\n        suggestions;  <span class=\"hljs-comment\">// max heap to store (frequency, word) in descending order</span>\r\n                      <span class=\"hljs-comment\">// of freq</span>\r\n\r\n    std::priority_queue&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, std::string&gt; &gt; *Suggestions =\r\n        &amp;suggestions;\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;i : key) {\r\n        letter_index = <span class=\"hljs-built_in\">tolower</span>(i) - <span class=\"hljs-number\">97</span>;\r\n        prev_pos = cur_pos;  <span class=\"hljs-comment\">// Previous pointer updated to point to the last</span>\r\n                             <span class=\"hljs-comment\">// char of the longest common prefix</span>\r\n\r\n        <span class=\"hljs-comment\">// When the node for the character does not exist, longest prefix has</span>\r\n        <span class=\"hljs-comment\">// been determined and SuggestFreqAutocomplete is called</span>\r\n        <span class=\"hljs-keyword\">if</span> (cur_pos-&gt;english[letter_index] == <span class=\"hljs-literal\">nullptr</span>) {\r\n            <span class=\"hljs-built_in\">SuggestFreqAutocomplete</span>(prev_pos, prefix, Suggestions);\r\n            <span class=\"hljs-comment\">// To display the top 3 results</span>\r\n            <span class=\"hljs-built_in\">SelectionTop_3</span>(Suggestions);\r\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - &quot;</span>\r\n                      &lt;&lt; std::endl;\r\n            <span class=\"hljs-keyword\">return</span>;\r\n        }\r\n        <span class=\"hljs-comment\">// Updating the longest common prefix</span>\r\n        prefix += <span class=\"hljs-built_in\">char</span>(<span class=\"hljs-built_in\">tolower</span>(i));\r\n        cur_pos = cur_pos-&gt;english[letter_index];\r\n    }\r\n    <span class=\"hljs-comment\">// If the key is a valid entry of trie, display it @ top of the suggestions</span>\r\n    <span class=\"hljs-keyword\">if</span> (cur_pos-&gt;endOfWord) {\r\n        (cur_pos-&gt;frequency)++;\r\n        std::cout &lt;&lt; key &lt;&lt; std::endl;\r\n    }\r\n\r\n    (<span class=\"hljs-type\">void</span>)prev_pos;  <span class=\"hljs-comment\">// Idiom to ignore previous pointer</span>\r\n\r\n    <span class=\"hljs-comment\">// Call for Suggestions when the search key is present as an entry/a prefix</span>\r\n    <span class=\"hljs-comment\">// in the trie</span>\r\n    <span class=\"hljs-built_in\">SuggestFreqAutocomplete</span>(cur_pos, prefix, Suggestions);\r\n    <span class=\"hljs-comment\">// Display the top 3 results</span>\r\n    <span class=\"hljs-built_in\">SelectionTop_3</span>(Suggestions);\r\n\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - &quot;</span>\r\n              &lt;&lt; std::endl;\r\n    <span class=\"hljs-keyword\">return</span>;\r\n}\r\n}  <span class=\"hljs-comment\">// namespace trie_operations</span>\r\n}  <span class=\"hljs-comment\">// namespace operations_on_datastructures</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Function to test a simple search before and after deleting\r\n * an entry. And to test out the multiple variants of search.\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-keyword\">auto</span> root = <span class=\"hljs-keyword\">new</span> operations_on_datastructures::trie_operations::<span class=\"hljs-built_in\">Tnode</span>();\r\n    std::vector&lt;std::string&gt; inputs = {\r\n        <span class=\"hljs-string\">&quot;abcde&quot;</span>, <span class=\"hljs-string\">&quot;sss&quot;</span>,    <span class=\"hljs-string\">&quot;ssss&quot;</span>,  <span class=\"hljs-string\">&quot;ssst&quot;</span>, <span class=\"hljs-string\">&quot;sssu&quot;</span>, <span class=\"hljs-string\">&quot;sssv&quot;</span>,\r\n        <span class=\"hljs-string\">&quot;sst&quot;</span>,   <span class=\"hljs-string\">&quot;ssts&quot;</span>,   <span class=\"hljs-string\">&quot;sstt&quot;</span>,  <span class=\"hljs-string\">&quot;sstu&quot;</span>, <span class=\"hljs-string\">&quot;tutu&quot;</span>, <span class=\"hljs-string\">&quot;tutuv&quot;</span>,\r\n        <span class=\"hljs-string\">&quot;tutuu&quot;</span>, <span class=\"hljs-string\">&quot;tutuvs&quot;</span>, <span class=\"hljs-string\">&quot;tutus&quot;</span>, <span class=\"hljs-string\">&quot;tvst&quot;</span>, <span class=\"hljs-string\">&quot;tvsu&quot;</span>, <span class=\"hljs-string\">&quot;vvvv&quot;</span>};\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;i : inputs) {\r\n        root-&gt;<span class=\"hljs-built_in\">Insert</span>(i);\r\n    }\r\n    <span class=\"hljs-comment\">// Search an existing entry</span>\r\n    <span class=\"hljs-built_in\">assert</span>(root-&gt;<span class=\"hljs-built_in\">SearchPresence</span>(<span class=\"hljs-string\">&quot;vvvv&quot;</span>));\r\n    std::cout &lt;&lt; root-&gt;<span class=\"hljs-built_in\">SearchPresence</span>(<span class=\"hljs-string\">&quot;vvvv&quot;</span>) &lt;&lt; std::endl;\r\n    <span class=\"hljs-comment\">// Delete it</span>\r\n    root-&gt;<span class=\"hljs-built_in\">Delete</span>(<span class=\"hljs-string\">&quot;vvvv&quot;</span>);\r\n    <span class=\"hljs-comment\">// Search for the entry again</span>\r\n    <span class=\"hljs-built_in\">assert</span>(!root-&gt;<span class=\"hljs-built_in\">SearchPresence</span>(<span class=\"hljs-string\">&quot;vvvv&quot;</span>));\r\n    std::cout &lt;&lt; root-&gt;<span class=\"hljs-built_in\">SearchPresence</span>(<span class=\"hljs-string\">&quot;vvvv&quot;</span>) &lt;&lt; std::endl;\r\n\r\n    std::cout &lt;&lt; root-&gt;<span class=\"hljs-built_in\">SearchPresence</span>(<span class=\"hljs-string\">&quot;tutu&quot;</span>) &lt;&lt; std::endl;\r\n    root-&gt;<span class=\"hljs-built_in\">SearchSuggestions</span>(<span class=\"hljs-string\">&quot;tutu&quot;</span>);\r\n    std::cout &lt;&lt; root-&gt;<span class=\"hljs-built_in\">SearchPresence</span>(<span class=\"hljs-string\">&quot;tutu&quot;</span>) &lt;&lt; std::endl;\r\n\r\n    root-&gt;<span class=\"hljs-built_in\">SearchSuggestions</span>(<span class=\"hljs-string\">&quot;tutuv&quot;</span>);\r\n    std::cout &lt;&lt; root-&gt;<span class=\"hljs-built_in\">SearchPresence</span>(<span class=\"hljs-string\">&quot;tutuv&quot;</span>) &lt;&lt; std::endl;\r\n\r\n    root-&gt;<span class=\"hljs-built_in\">SearchSuggestions</span>(<span class=\"hljs-string\">&quot;tutuvs&quot;</span>);\r\n\r\n    root-&gt;<span class=\"hljs-built_in\">SearchFreqSuggestions</span>(\r\n        <span class=\"hljs-string\">&quot;tu&quot;</span>);  <span class=\"hljs-comment\">// The top 3 frequent entries with prefix tu are tutu, tutuv &amp;</span>\r\n                <span class=\"hljs-comment\">// tutuvs respectively</span>\r\n    root-&gt;<span class=\"hljs-built_in\">SearchSuggestions</span>(\r\n        <span class=\"hljs-string\">&quot;&quot;</span>);  <span class=\"hljs-comment\">// Empty search to list all the entries in the trie</span>\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Main function\r\n * @param argc commandline argument count (ignored)\r\n * @param argv commandline array of arguments (ignored)\r\n * @returns 0 on exit\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> <span class=\"hljs-keyword\">const</span> *argv[])</span> </span>{\r\n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">// run self-test implementations</span>\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    }
  },
  "contributors": [
    {
      "name": "g-s-k-zoro",
      "email": "42112703+g-s-k-zoro@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}
