{
  "slug": "hopcroft-karp",
  "name": "Hopcroft Karp",
  "categories": ["graphs"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "graph/hopcroft_karp.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph/hopcroft_karp.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file \n * @brief  Implementation of [Hopcroft–Karp](https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm) algorithm.\n * @details \n * The Hopcroft–Karp algorithm is an algorithm that takes as input a bipartite graph \n * and produces as output a maximum cardinality matching, it runs in O(E√V) time in worst case.\n * \n * ### Bipartite graph\n * A bipartite graph (or bigraph) is a graph whose vertices can be divided into two disjoint \n * and independent sets U and V such that every edge connects a vertex in U to one in V. \n * Vertex sets U and V are usually called the parts of the graph. \n * Equivalently, a bipartite graph is a graph that does not contain any odd-length cycles.\n * \n * ### Matching and Not-Matching edges\n * Given a matching M, edges that are part of matching are called Matching edges and edges that are not part \n * of M (or connect free nodes) are called Not-Matching edges.\n * \n * ### Maximum cardinality matching\n * Given a bipartite graphs G = ( V = ( X , Y ) , E ) whose partition has the parts X and Y, \n * with E denoting the edges of the graph, the goal is to find a matching with as many edges as possible. \n * Equivalently, a matching that covers as many vertices as possible.\n * \n * ### Augmenting paths\n * Given a matching M, an augmenting path is an alternating path that starts from and ends on free vertices. \n * All single edge paths that start and end with free vertices are augmenting paths.\n * \n * \n * ### Concept\n * A matching M is not maximum if there exists an augmenting path. It is also true other way,\n * i.e, a matching is maximum if no augmenting path exists.\n * \n * \n * ### Algorithm\n * 1) Initialize the Maximal Matching M as empty.\n * 2) While there exists an Augmenting Path P\n *   Remove matching edges of P from M and add not-matching edges of P to M\n *   (This increases size of M by 1 as P starts and ends with a free vertex\n *   i.e. a node that is not part of matching.)\n * 3) Return M. \n * \n * \n *\n * @author [Krishna Pal Deora](https://github.com/Krishnapal4050)\n * \n */</span>\n\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdlib&gt;</span> </span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;list&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;climits&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;memory&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\n\n<span class=\"hljs-comment\">/**\n * @namespace graph \n * @brief Graph algorithms\n */</span>\n <span class=\"hljs-keyword\">namespace</span> graph { \n\n<span class=\"hljs-comment\">/**\n * @brief Represents Bipartite graph for\n * Hopcroft Karp implementation\n */</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HKGraph</span>\n{\n    <span class=\"hljs-type\">int</span> m{};  <span class=\"hljs-comment\">///&lt; m is the number of vertices on left side of Bipartite Graph</span>\n    <span class=\"hljs-type\">int</span> n{};  <span class=\"hljs-comment\">///&lt; n is the number of vertices on right side of Bipartite Graph</span>\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> NIL{<span class=\"hljs-number\">0</span>};\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> INF{INT_MAX};\n\n    std::vector&lt;std::list&lt;<span class=\"hljs-type\">int</span>&gt; &gt;adj;  <span class=\"hljs-comment\">///&lt; adj[u] stores adjacents of left side and 0 is used for dummy vertex</span>\n\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; pair_u; <span class=\"hljs-comment\">///&lt; value of vertex &#x27;u&#x27; ranges from 1 to m</span>\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; pair_v; <span class=\"hljs-comment\">///&lt; value of vertex &#x27;v&#x27; ranges from 1 to n</span>\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; dist;   <span class=\"hljs-comment\">///&lt; dist represents the distance between vertex &#x27;u&#x27; and vertex &#x27;v&#x27;</span>\n\n<span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-built_in\">HKGraph</span>();\t\t       <span class=\"hljs-comment\">// Default Constructor</span>\n    <span class=\"hljs-built_in\">HKGraph</span>(<span class=\"hljs-type\">int</span> m, <span class=\"hljs-type\">int</span> n);     <span class=\"hljs-comment\">// Constructor</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addEdge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u, <span class=\"hljs-type\">int</span> v)</span></span>; <span class=\"hljs-comment\">// To add edge</span>\n    \n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">bfs</span><span class=\"hljs-params\">()</span></span>; <span class=\"hljs-comment\">// Returns true if there is an augmenting path    </span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u)</span></span>; <span class=\"hljs-comment\">// Adds augmenting path if there is one beginning with u  </span>\n\t\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">hopcroftKarpAlgorithm</span><span class=\"hljs-params\">()</span></span>;  <span class=\"hljs-comment\">// Returns size of maximum matching</span>\n};\n\n\n<span class=\"hljs-comment\">/**\n * @brief This function counts the number of augmenting paths between left and right sides of the Bipartite graph\n * @returns size of maximum matching\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">HKGraph::hopcroftKarpAlgorithm</span><span class=\"hljs-params\">()</span>\n</span>{\n\n    <span class=\"hljs-comment\">// pair_u[u] stores pair of u in matching on left side of Bipartite Graph.</span>\n    <span class=\"hljs-comment\">// If u doesn&#x27;t have any pair, then pair_u[u] is NIL</span>\n    pair_u = std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(m + <span class=\"hljs-number\">1</span>,NIL); \n\n    <span class=\"hljs-comment\">// pair_v[v] stores pair of v in matching on right side of Biparite Graph.</span>\n    <span class=\"hljs-comment\">// If v doesn&#x27;t have any pair, then pair_u[v] is NIL</span>\n    pair_v = std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(n + <span class=\"hljs-number\">1</span>,NIL); \n\n    dist = std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(m + <span class=\"hljs-number\">1</span>);  <span class=\"hljs-comment\">// dist[u] stores distance of left side vertices</span>\n\n    <span class=\"hljs-type\">int</span> result = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// Initialize result</span>\n\n    <span class=\"hljs-comment\">// Keep updating the result while there is an augmenting path possible.</span>\n    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">bfs</span>())\n    {\n        <span class=\"hljs-comment\">// Find a free vertex to check for a matching</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> u = <span class=\"hljs-number\">1</span>; u &lt;= m; u++){\n\n            <span class=\"hljs-comment\">// If current vertex is free and there is</span>\n            <span class=\"hljs-comment\">// an augmenting path from current vertex</span>\n            <span class=\"hljs-comment\">// then increment the result</span>\n            <span class=\"hljs-keyword\">if</span> (pair_u[u] == NIL &amp;&amp; <span class=\"hljs-built_in\">dfs</span>(u)){\n                result++;\n\t    }\n\t}\n    }\n    <span class=\"hljs-keyword\">return</span> result;\n}\n\n\n<span class=\"hljs-comment\">/**\n * @brief This function checks for the possibility of augmented path availability \n * @returns `true` if there is an augmenting path available\n * @returns `false` if there is no augmenting path available\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">HKGraph::bfs</span><span class=\"hljs-params\">()</span>\n</span>{\n    std::queue&lt;<span class=\"hljs-type\">int</span>&gt; q; <span class=\"hljs-comment\">// an integer queue for bfs</span>\n\n    <span class=\"hljs-comment\">// First layer of vertices (set distance as 0)</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> u = <span class=\"hljs-number\">1</span>; u &lt;= m; u++)\n    {\n        <span class=\"hljs-comment\">// If this is a free vertex, add it to queue</span>\n        <span class=\"hljs-keyword\">if</span> (pair_u[u] == NIL){\n            \n            dist[u] = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// u is not matched so distance is 0</span>\n            q.<span class=\"hljs-built_in\">push</span>(u);\n        }\n\n        <span class=\"hljs-keyword\">else</span>{\n            dist[u] = INF; <span class=\"hljs-comment\">// set distance as infinite so that this vertex is considered next time for availibility</span>\n\t}\n    }\n\n    \n    dist[NIL] = INF; <span class=\"hljs-comment\">// Initialize distance to NIL as infinite</span>\n\n    <span class=\"hljs-comment\">// q is going to contain vertices of left side only.</span>\n    <span class=\"hljs-keyword\">while</span> (!q.<span class=\"hljs-built_in\">empty</span>())\n    {\n        <span class=\"hljs-type\">int</span> u = q.<span class=\"hljs-built_in\">front</span>();  <span class=\"hljs-comment\">// dequeue a vertex</span>\n        q.<span class=\"hljs-built_in\">pop</span>();\n\n        <span class=\"hljs-comment\">// If this node is not NIL and can provide a shorter path to NIL then</span>\n        <span class=\"hljs-keyword\">if</span> (dist[u] &lt; dist[NIL])\n        {\n            <span class=\"hljs-comment\">// Get all the adjacent vertices of the dequeued vertex u</span>\n            std::list&lt;<span class=\"hljs-type\">int</span>&gt;::iterator it;\n            <span class=\"hljs-keyword\">for</span> (it = adj[u].<span class=\"hljs-built_in\">begin</span>(); it != adj[u].<span class=\"hljs-built_in\">end</span>(); ++it)\n            {\n                <span class=\"hljs-type\">int</span> v = *it;\n\n                <span class=\"hljs-comment\">// If pair of v is not considered so far i.e. (v, pair_v[v]) is not yet explored edge.</span>\n                <span class=\"hljs-keyword\">if</span> (dist[pair_v[v]] == INF)\n                {\n                    dist[pair_v[v]] = dist[u] + <span class=\"hljs-number\">1</span>; \n                    q.<span class=\"hljs-built_in\">push</span>(pair_v[v]);    <span class=\"hljs-comment\">// Consider the pair and push it to queue</span>\n                }\n            }\n        }\n    }\n\n   \n   \n    <span class=\"hljs-keyword\">return</span> (dist[NIL] != INF);   <span class=\"hljs-comment\">// If we could come back to NIL using alternating path of distinct vertices then there is an augmenting path available</span>\n}\n\n<span class=\"hljs-comment\">/**\n * @brief This functions checks whether an augmenting path is available exists beginning with free vertex u\n * @param u represents position of vertex\n * @returns `true` if there is an augmenting path beginning with free vertex u\n * @returns `false` if there is no augmenting path beginning with free vertex u\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">HKGraph::dfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u)</span>\n</span>{\n    <span class=\"hljs-keyword\">if</span> (u != NIL)\n    {\n        std::list&lt;<span class=\"hljs-type\">int</span>&gt;::iterator it;\n        <span class=\"hljs-keyword\">for</span> (it = adj[u].<span class=\"hljs-built_in\">begin</span>(); it != adj[u].<span class=\"hljs-built_in\">end</span>(); ++it)\n        {\n            \n            <span class=\"hljs-type\">int</span> v = *it; <span class=\"hljs-comment\">// Adjacent vertex of u</span>\n\n            <span class=\"hljs-comment\">// Follow the distances set by BFS search</span>\n            <span class=\"hljs-keyword\">if</span> (dist[pair_v[v]] == dist[u] + <span class=\"hljs-number\">1</span>)\n            {\n                <span class=\"hljs-comment\">// If dfs for pair of v also return true then new matching possible, store the matching</span>\n                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">dfs</span>(pair_v[v]) == <span class=\"hljs-literal\">true</span>)\n                {   \n                    pair_v[v] = u;\n                    pair_u[u] = v;\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n                }\n            }\n        }\n\n        \n        dist[u] = INF; <span class=\"hljs-comment\">// If there is no augmenting path beginning with u then set distance to infinite.</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Default Constructor for initialization\n */</span>\nHKGraph::<span class=\"hljs-built_in\">HKGraph</span>() = <span class=\"hljs-keyword\">default</span>;\n\n<span class=\"hljs-comment\">/**\n * @brief Constructor for initialization\n * @param m is the number of vertices on left side of Bipartite Graph\n * @param n is the number of vertices on right side of Bipartite Graph\n */</span>\nHKGraph::<span class=\"hljs-built_in\">HKGraph</span>(<span class=\"hljs-type\">int</span> m, <span class=\"hljs-type\">int</span> n) {\n    <span class=\"hljs-keyword\">this</span>-&gt;m = m;\n    <span class=\"hljs-keyword\">this</span>-&gt;n = n;\n    adj = std::vector&lt;std::list&lt;<span class=\"hljs-type\">int</span>&gt; &gt;(m + <span class=\"hljs-number\">1</span>);\n}\n\n<span class=\"hljs-comment\">/**\n * @brief function to add edge from u to v\n * @param u is the position of first vertex\n * @param v is the position of second vertex\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">HKGraph::addEdge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u, <span class=\"hljs-type\">int</span> v)</span>\n</span>{\n    adj[u].<span class=\"hljs-built_in\">push_back</span>(v); <span class=\"hljs-comment\">// Add v to u’s list.</span>\n}\n\n} <span class=\"hljs-comment\">// namespace graph</span>\n\n<span class=\"hljs-keyword\">using</span> graph::HKGraph;\n\n<span class=\"hljs-comment\">/**\n * Self-test implementation\n * @returns none\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">tests</span><span class=\"hljs-params\">()</span></span>{\n     <span class=\"hljs-comment\">// Sample test case 1</span>\n\t     <span class=\"hljs-type\">int</span> v1a = <span class=\"hljs-number\">3</span>, v1b = <span class=\"hljs-number\">5</span>, e1 = <span class=\"hljs-number\">2</span>;  <span class=\"hljs-comment\">// vertices of left side, right side and edges</span>\n\t     <span class=\"hljs-function\">HKGraph <span class=\"hljs-title\">g1</span><span class=\"hljs-params\">(v1a, v1b)</span></span>; <span class=\"hljs-comment\">// execute the algorithm </span>\n\n\t     g1.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>);\n\t     g1.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">4</span>);\n\n\t     <span class=\"hljs-type\">int</span> expected_res1 = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// for the above sample data, this is the expected output</span>\n\t     <span class=\"hljs-type\">int</span> res1 = g1.<span class=\"hljs-built_in\">hopcroftKarpAlgorithm</span>();\n\n\t     <span class=\"hljs-built_in\">assert</span>(res1 == expected_res1); <span class=\"hljs-comment\">// assert check to ensure that the algorithm executed correctly for test 1</span>\n\t\n     <span class=\"hljs-comment\">// Sample test case 2</span>\n     \t     <span class=\"hljs-type\">int</span> v2a = <span class=\"hljs-number\">4</span>, v2b = <span class=\"hljs-number\">4</span>, e2 = <span class=\"hljs-number\">6</span>;  <span class=\"hljs-comment\">// vertices of left side, right side and edges</span>\n\t     <span class=\"hljs-function\">HKGraph <span class=\"hljs-title\">g2</span><span class=\"hljs-params\">(v2a, v2b)</span></span>; <span class=\"hljs-comment\">// execute the algorithm </span>\n\n             g2.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>);\n\t     g2.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>);\n\t     g2.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>);\n\t     g2.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>);\n\t     g2.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">3</span>);\n             g2.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">2</span>);\n\t\n\t     <span class=\"hljs-type\">int</span> expected_res2 = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// for the above sample data, this is the expected output</span>\n\t     <span class=\"hljs-type\">int</span> res2 = g2.<span class=\"hljs-built_in\">hopcroftKarpAlgorithm</span>();\n\n\t     <span class=\"hljs-built_in\">assert</span>(res2 == expected_res2); <span class=\"hljs-comment\">// assert check to ensure that the algorithm executed correctly for test 2</span>\n\t\n      <span class=\"hljs-comment\">// Sample test case 3</span>\n     \t     <span class=\"hljs-type\">int</span> v3a = <span class=\"hljs-number\">6</span>, v3b = <span class=\"hljs-number\">6</span>, e3 = <span class=\"hljs-number\">4</span>;  <span class=\"hljs-comment\">// vertices of left side, right side and edges</span>\n\t     <span class=\"hljs-function\">HKGraph <span class=\"hljs-title\">g3</span><span class=\"hljs-params\">(v3a, v3b)</span></span>; <span class=\"hljs-comment\">// execute the algorithm </span>\n\n             g3.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>);\n\t     g3.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">4</span>);\n\t     g3.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">5</span>);\n\t     g3.<span class=\"hljs-built_in\">addEdge</span>(<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">0</span>);\n\n\t     <span class=\"hljs-type\">int</span> expected_res3 = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// for the above sample data, this is the expected output</span>\n\t     <span class=\"hljs-type\">int</span> res3 = g3.<span class=\"hljs-built_in\">hopcroftKarpAlgorithm</span>();\n\n\t     <span class=\"hljs-built_in\">assert</span>(res3 == expected_res3); <span class=\"hljs-comment\">// assert check to ensure that the algorithm executed correctly for test 3</span>\n\t\n\t\n    \t\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Main function\n * @returns 0 on exit\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span>\n</span>{\n    <span class=\"hljs-built_in\">tests</span>();  <span class=\"hljs-comment\">// perform self-tests</span>\n\n    <span class=\"hljs-type\">int</span> v1 = <span class=\"hljs-number\">0</span>, v2 = <span class=\"hljs-number\">0</span>, e = <span class=\"hljs-number\">0</span>;\n    std::cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; e; <span class=\"hljs-comment\">// vertices of left side, right side and edges</span>\n    <span class=\"hljs-function\">HKGraph <span class=\"hljs-title\">g</span><span class=\"hljs-params\">(v1, v2)</span></span>;  \n    <span class=\"hljs-type\">int</span> u = <span class=\"hljs-number\">0</span>, v = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; e; ++i)\n    {\n        std::cin &gt;&gt; u &gt;&gt; v;\n        g.<span class=\"hljs-built_in\">addEdge</span>(u, v);\n    }\n  \n    <span class=\"hljs-type\">int</span> res = g.<span class=\"hljs-built_in\">hopcroftKarpAlgorithm</span>();\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Maximum matching is &quot;</span> &lt;&lt; res &lt;&lt;<span class=\"hljs-string\">&quot;\\n&quot;</span>;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Krishna Pal Deora",
      "email": "53469625+Krishnapal4050@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}
