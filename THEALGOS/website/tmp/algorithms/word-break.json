{
  "slug": "word-break",
  "name": "Word Break",
  "categories": ["dynamicprogramming"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "dynamic_programming/word_break.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/dynamic_programming/word_break.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * @brief [Word Break Problem](https://leetcode.com/problems/word-break/)\n * @details\n * Given a non-empty string s and a dictionary wordDict containing a list of\n * non-empty words, determine if s can be segmented into a space-separated\n * sequence of one or more dictionary words.\n *\n * Note:\n * The same word in the dictionary may be reused multiple times in the\n * segmentation. You may assume the dictionary does not contain duplicate words.\n *\n * Example 1:\n * Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]\n * Output: true\n * Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.\n *\n * Example 2:\n * Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]\n * Output: true\n * Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple\n * pen apple&quot;. Note that you are allowed to reuse a dictionary word.\n *\n * Example 3:\n * Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]\n * Output: false\n *\n * @author [Akshay Anand] (https://github.com/axayjha)\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;climits&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_set&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\n\n<span class=\"hljs-comment\">/**\n * @namespace dynamic_programming\n * @brief Dynamic programming algorithms\n */</span>\n<span class=\"hljs-keyword\">namespace</span> dynamic_programming {\n\n<span class=\"hljs-comment\">/**\n * @namespace word_break\n * @brief Functions for [Word Break](https://leetcode.com/problems/word-break/)\n * problem\n */</span>\n<span class=\"hljs-keyword\">namespace</span> word_break {\n\n<span class=\"hljs-comment\">/**\n * @brief Function that checks if the string passed in param is present in\n * the the unordered_set passed\n *\n * @param str the string to be searched\n * @param strSet unordered set of string, that is to be looked into\n * @returns `true` if str is present in strSet\n * @returns `false` if str is not present in strSet\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">exists</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string &amp;str,\n            <span class=\"hljs-keyword\">const</span> std::unordered_set&lt;std::string&gt; &amp;strSet)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> strSet.<span class=\"hljs-built_in\">find</span>(str) != strSet.<span class=\"hljs-built_in\">end</span>();\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Function that checks if the string passed in param can be\n * segmented from position &#x27;pos&#x27;, and then correctly go on to segment the\n * rest of the string correctly as well to reach a solution\n *\n * @param s the complete string to be segmented\n * @param strSet unordered set of string, that is to be used as the\n * reference dictionary\n * @param pos the index value at which we will segment string and test\n * further if it is correctly segmented at pos\n * @param dp the vector to memoize solution for each position\n * @returns `true` if a valid solution/segmentation is possible by segmenting at\n * index pos\n * @returns `false` otherwise\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">check</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string &amp;s, <span class=\"hljs-keyword\">const</span> std::unordered_set&lt;std::string&gt; &amp;strSet,\n           <span class=\"hljs-type\">int</span> pos, std::vector&lt;<span class=\"hljs-type\">int</span>&gt; *dp)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (pos == s.<span class=\"hljs-built_in\">length</span>()) {\n        <span class=\"hljs-comment\">// if we have reached till the end of the string, means we have</span>\n        <span class=\"hljs-comment\">// segmented throughout correctly hence we have a solution, thus</span>\n        <span class=\"hljs-comment\">// returning true</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    }\n\n    <span class=\"hljs-keyword\">if</span> (dp-&gt;<span class=\"hljs-built_in\">at</span>(pos) != INT_MAX) {\n        <span class=\"hljs-comment\">// if dp[pos] is not INT_MAX, means we must have saved a solution</span>\n        <span class=\"hljs-comment\">// for the position pos; then return if the solution at pos is true</span>\n        <span class=\"hljs-comment\">// or not</span>\n        <span class=\"hljs-keyword\">return</span> dp-&gt;<span class=\"hljs-built_in\">at</span>(pos) == <span class=\"hljs-number\">1</span>;\n    }\n\n    std::string wordTillNow =\n        <span class=\"hljs-string\">&quot;&quot;</span>;  <span class=\"hljs-comment\">// string to save the prefixes of word till different positons</span>\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = pos; i &lt; s.<span class=\"hljs-built_in\">length</span>(); i++) {\n        <span class=\"hljs-comment\">// Loop starting from pos to end, to check valid set of</span>\n        <span class=\"hljs-comment\">// segmentations if any</span>\n        wordTillNow +=\n            std::<span class=\"hljs-built_in\">string</span>(<span class=\"hljs-number\">1</span>, s[i]);  <span class=\"hljs-comment\">// storing the prefix till the position i</span>\n\n        <span class=\"hljs-comment\">// if the prefix till current position is present in the dictionary</span>\n        <span class=\"hljs-comment\">// and the remaining substring can also be segmented legally, then</span>\n        <span class=\"hljs-comment\">// set solution at position pos in the memo, and return true</span>\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">exists</span>(wordTillNow, strSet) <span class=\"hljs-keyword\">and</span> <span class=\"hljs-built_in\">check</span>(s, strSet, i + <span class=\"hljs-number\">1</span>, dp)) {\n            dp-&gt;<span class=\"hljs-built_in\">at</span>(pos) = <span class=\"hljs-number\">1</span>;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n        }\n    }\n    <span class=\"hljs-comment\">// if function has still not returned, then there must be no legal</span>\n    <span class=\"hljs-comment\">// segmentation possible after segmenting at pos</span>\n    dp-&gt;<span class=\"hljs-built_in\">at</span>(pos) = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// so set solution at pos as false</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;     <span class=\"hljs-comment\">// and return no solution at position pos</span>\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Function that checks if the string passed in param can be\n * segmented into the strings present in the vector.\n * In others words, it checks if any permutation of strings in\n * the vector can be concatenated to form the final string.\n *\n * @param s the complete string to be segmented\n * @param wordDict a vector of words to be used as dictionary to look into\n * @returns `true` if s can be formed by a combination of strings present in\n * wordDict\n * @return `false` otherwise\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">wordBreak</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string &amp;s, <span class=\"hljs-keyword\">const</span> std::vector&lt;std::string&gt; &amp;wordDict)</span> </span>{\n    <span class=\"hljs-comment\">// unordered set to store words in the dictionary for constant time</span>\n    <span class=\"hljs-comment\">// search</span>\n    std::unordered_set&lt;std::string&gt; strSet;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;s : wordDict) {\n        strSet.<span class=\"hljs-built_in\">insert</span>(s);\n    }\n    <span class=\"hljs-comment\">// a vector to be used for memoization, whose value at index i will</span>\n    <span class=\"hljs-comment\">// tell if the string s can be segmented (correctly) at position i.</span>\n    <span class=\"hljs-comment\">// initializing it with INT_MAX (which will denote no solution)</span>\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">dp</span><span class=\"hljs-params\">(s.length(), INT_MAX)</span></span>;\n\n    <span class=\"hljs-comment\">// calling check method with position = 0, to check from left</span>\n    <span class=\"hljs-comment\">// from where can be start segmenting the complete string in correct</span>\n    <span class=\"hljs-comment\">// manner</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">check</span>(s, strSet, <span class=\"hljs-number\">0</span>, &amp;dp);\n}\n\n}  <span class=\"hljs-comment\">// namespace word_break</span>\n}  <span class=\"hljs-comment\">// namespace dynamic_programming</span>\n\n<span class=\"hljs-comment\">/**\n * @brief Test implementations\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// the complete string</span>\n    <span class=\"hljs-keyword\">const</span> std::string s = <span class=\"hljs-string\">&quot;applepenapple&quot;</span>;\n    <span class=\"hljs-comment\">// the dictionary to be used</span>\n    <span class=\"hljs-keyword\">const</span> std::vector&lt;std::string&gt; wordDict = {<span class=\"hljs-string\">&quot;apple&quot;</span>, <span class=\"hljs-string\">&quot;pen&quot;</span>};\n\n    <span class=\"hljs-built_in\">assert</span>(dynamic_programming::word_break::<span class=\"hljs-built_in\">wordBreak</span>(s, wordDict));\n\n    <span class=\"hljs-comment\">// should return true, as applepenapple can be segmented as apple + pen +</span>\n    <span class=\"hljs-comment\">// apple</span>\n    std::cout &lt;&lt; dynamic_programming::word_break::<span class=\"hljs-built_in\">wordBreak</span>(s, wordDict)\n              &lt;&lt; std::endl;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test implementation passed!\\n&quot;</span>;\n}\n<span class=\"hljs-comment\">/**\n * @brief Main function\n * @returns 0 on exit\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">// call the test function :)</span>\n\n    <span class=\"hljs-comment\">// the complete string</span>\n    <span class=\"hljs-keyword\">const</span> std::string s = <span class=\"hljs-string\">&quot;applepenapple&quot;</span>;\n    <span class=\"hljs-comment\">// the dictionary to be used</span>\n    <span class=\"hljs-keyword\">const</span> std::vector&lt;std::string&gt; wordDict = {<span class=\"hljs-string\">&quot;apple&quot;</span>, <span class=\"hljs-string\">&quot;pen&quot;</span>};\n\n    <span class=\"hljs-comment\">// should return true, as applepenapple can be segmented as apple + pen +</span>\n    <span class=\"hljs-comment\">// apple</span>\n    std::cout &lt;&lt; dynamic_programming::word_break::<span class=\"hljs-built_in\">wordBreak</span>(s, wordDict)\n              &lt;&lt; std::endl;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Akshay Anand",
      "email": "akshayjha@live.in",
      "commits": 1
    },
    {
      "name": "Anushka Verma",
      "email": "v.anushka786@gmail.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}
