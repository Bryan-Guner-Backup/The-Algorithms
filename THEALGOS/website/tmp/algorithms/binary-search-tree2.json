{
  "slug": "binary-search-tree2",
  "name": "Binary Search Tree2",
  "categories": ["datastructures"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "data_structures/binary_search_tree2.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/data_structures/binary_search_tree2.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * @brief A generic [binary search tree](https://en.wikipedia.org/wiki/Binary_search_tree) implementation.\n * @see binary_search_tree.cpp\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;functional&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;memory&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\n\n<span class=\"hljs-comment\">/**\n * @brief The Binary Search Tree class.\n *\n * @tparam T The type of the binary search tree key.\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">binary_search_tree</span> {\n <span class=\"hljs-keyword\">private</span>:\n    <span class=\"hljs-comment\">/**\n    * @brief A struct to represent a node in the Binary Search Tree.\n    */</span>\n    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">bst_node</span> {\n        T value; <span class=\"hljs-comment\">/**&lt; The value/key of the node. */</span>\n        std::unique_ptr&lt;bst_node&gt; left; <span class=\"hljs-comment\">/**&lt; Pointer to left subtree. */</span>\n        std::unique_ptr&lt;bst_node&gt; right; <span class=\"hljs-comment\">/**&lt; Pointer to right subtree. */</span>\n\n        <span class=\"hljs-comment\">/**\n        * Constructor for bst_node, used to simplify node construction and\n        * smart pointer construction.\n        * @param _value The value of the constructed node.\n        */</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">bst_node</span><span class=\"hljs-params\">(T _value)</span> </span>{\n            value = _value;\n            left = <span class=\"hljs-literal\">nullptr</span>;\n            right = <span class=\"hljs-literal\">nullptr</span>;\n        }\n    };\n\n    std::unique_ptr&lt;bst_node&gt; root_; <span class=\"hljs-comment\">/**&lt; Pointer to the root of the BST. */</span>\n    std::<span class=\"hljs-type\">size_t</span> size_ = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">/**&lt; Number of elements/nodes in the BST. */</span>\n\n    <span class=\"hljs-comment\">/**\n     * @brief Recursive function to find the maximum value in the BST.\n     *\n     * @param node The node to search from.\n     * @param ret_value Variable to hold the maximum value.\n     * @return true If the maximum value was successfully found.\n     * @return false Otherwise.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">find_max</span><span class=\"hljs-params\">(std::unique_ptr&lt;bst_node&gt;&amp; node, T&amp; ret_value)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (!node) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!node-&gt;right) {\n            ret_value = node-&gt;value;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">find_max</span>(node-&gt;right, ret_value);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Recursive function to find the minimum value in the BST.\n     *\n     * @param node The node to search from.\n     * @param ret_value Variable to hold the minimum value.\n     * @return true If the minimum value was successfully found.\n     * @return false Otherwise.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">find_min</span><span class=\"hljs-params\">(std::unique_ptr&lt;bst_node&gt;&amp; node, T&amp; ret_value)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (!node) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!node-&gt;left) {\n            ret_value = node-&gt;value;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n        }\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">find_min</span>(node-&gt;left, ret_value);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Recursive function to insert a value into the BST.\n     *\n     * @param node The node to search from.\n     * @param new_value The value to insert.\n     * @return true If the insert operation was successful.\n     * @return false Otherwise.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(std::unique_ptr&lt;bst_node&gt;&amp; node, T new_value)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (root_ == node &amp;&amp; !root_) {\n            root_ = std::<span class=\"hljs-built_in\">unique_ptr</span>&lt;bst_node&gt;(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">bst_node</span>(new_value));\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n        }\n\n        <span class=\"hljs-keyword\">if</span> (new_value &lt; node-&gt;value) {\n            <span class=\"hljs-keyword\">if</span> (!node-&gt;left) {\n                node-&gt;left = std::<span class=\"hljs-built_in\">unique_ptr</span>&lt;bst_node&gt;(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">bst_node</span>(new_value));\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">insert</span>(node-&gt;left, new_value);\n            }\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (new_value &gt; node-&gt;value) {\n            <span class=\"hljs-keyword\">if</span> (!node-&gt;right) {\n                node-&gt;right =\n                    std::<span class=\"hljs-built_in\">unique_ptr</span>&lt;bst_node&gt;(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">bst_node</span>(new_value));\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">insert</span>(node-&gt;right, new_value);\n            }\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Recursive function to remove a value from the BST.\n     *\n     * @param parent The parent node of node.\n     * @param node The node to search from.\n     * @param rm_value The value to remove.\n     * @return true If the removal operation was successful.\n     * @return false Otherwise.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(std::unique_ptr&lt;bst_node&gt;&amp; parent,\n                std::unique_ptr&lt;bst_node&gt;&amp; node, T rm_value)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (!node) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n        }\n\n        <span class=\"hljs-keyword\">if</span> (node-&gt;value == rm_value) {\n            <span class=\"hljs-keyword\">if</span> (node-&gt;left &amp;&amp; node-&gt;right) {\n                T successor_node_value{};\n                <span class=\"hljs-built_in\">find_max</span>(node-&gt;left, successor_node_value);\n                <span class=\"hljs-built_in\">remove</span>(root_, root_, successor_node_value);\n                node-&gt;value = successor_node_value;\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (node-&gt;left || node-&gt;right) {\n                std::unique_ptr&lt;bst_node&gt;&amp; non_null =\n                    (node-&gt;left ? node-&gt;left : node-&gt;right);\n\n                <span class=\"hljs-keyword\">if</span> (node == root_) {\n                    root_ = std::<span class=\"hljs-built_in\">move</span>(non_null);\n                } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (rm_value &lt; parent-&gt;value) {\n                    parent-&gt;left = std::<span class=\"hljs-built_in\">move</span>(non_null);\n                } <span class=\"hljs-keyword\">else</span> {\n                    parent-&gt;right = std::<span class=\"hljs-built_in\">move</span>(non_null);\n                }\n\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-keyword\">if</span> (node == root_) {\n                    root_.<span class=\"hljs-built_in\">reset</span>(<span class=\"hljs-literal\">nullptr</span>);\n                } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (rm_value &lt; parent-&gt;value) {\n                    parent-&gt;left.<span class=\"hljs-built_in\">reset</span>(<span class=\"hljs-literal\">nullptr</span>);\n                } <span class=\"hljs-keyword\">else</span> {\n                    parent-&gt;right.<span class=\"hljs-built_in\">reset</span>(<span class=\"hljs-literal\">nullptr</span>);\n                }\n\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n            }\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (rm_value &lt; node-&gt;value) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">remove</span>(node, node-&gt;left, rm_value);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">remove</span>(node, node-&gt;right, rm_value);\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Recursive function to check if a value is in the BST.\n     *\n     * @param node The node to search from.\n     * @param value The value to find.\n     * @return true If the value was found in the BST.\n     * @return false Otherwise.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">contains</span><span class=\"hljs-params\">(std::unique_ptr&lt;bst_node&gt;&amp; node, T value)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (!node) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n        }\n\n        <span class=\"hljs-keyword\">if</span> (value &lt; node-&gt;value) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">contains</span>(node-&gt;left, value);\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (value &gt; node-&gt;value) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">contains</span>(node-&gt;right, value);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Recursive function to traverse the tree in in-order order.\n     *\n     * @param callback Function that is called when a value needs to processed.\n     * @param node The node to traverse from.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">traverse_inorder</span><span class=\"hljs-params\">(std::function&lt;<span class=\"hljs-type\">void</span>(T)&gt; callback,\n                          std::unique_ptr&lt;bst_node&gt;&amp; node)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (!node) {\n            <span class=\"hljs-keyword\">return</span>;\n        }\n\n        <span class=\"hljs-built_in\">traverse_inorder</span>(callback, node-&gt;left);\n        <span class=\"hljs-built_in\">callback</span>(node-&gt;value);\n        <span class=\"hljs-built_in\">traverse_inorder</span>(callback, node-&gt;right);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Recursive function to traverse the tree in pre-order order.\n     *\n     * @param callback Function that is called when a value needs to processed.\n     * @param node The node to traverse from.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">traverse_preorder</span><span class=\"hljs-params\">(std::function&lt;<span class=\"hljs-type\">void</span>(T)&gt; callback,\n                           std::unique_ptr&lt;bst_node&gt;&amp; node)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (!node) {\n            <span class=\"hljs-keyword\">return</span>;\n        }\n\n        <span class=\"hljs-built_in\">callback</span>(node-&gt;value);\n        <span class=\"hljs-built_in\">traverse_preorder</span>(callback, node-&gt;left);\n        <span class=\"hljs-built_in\">traverse_preorder</span>(callback, node-&gt;right);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Recursive function to traverse the tree in post-order order.\n     *\n     * @param callback Function that is called when a value needs to processed.\n     * @param node The node to traverse from.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">traverse_postorder</span><span class=\"hljs-params\">(std::function&lt;<span class=\"hljs-type\">void</span>(T)&gt; callback,\n                            std::unique_ptr&lt;bst_node&gt;&amp; node)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (!node) {\n            <span class=\"hljs-keyword\">return</span>;\n        }\n\n        <span class=\"hljs-built_in\">traverse_postorder</span>(callback, node-&gt;left);\n        <span class=\"hljs-built_in\">traverse_postorder</span>(callback, node-&gt;right);\n        <span class=\"hljs-built_in\">callback</span>(node-&gt;value);\n    }\n\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-comment\">/**\n     * @brief Construct a new Binary Search Tree object.\n     *\n     */</span>\n    <span class=\"hljs-built_in\">binary_search_tree</span>() {\n        root_ = <span class=\"hljs-literal\">nullptr</span>;\n        size_ = <span class=\"hljs-number\">0</span>;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Insert a new value into the BST.\n     *\n     * @param new_value The value to insert into the BST.\n     * @return true If the insertion was successful.\n     * @return false Otherwise.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(T new_value)</span> </span>{\n        <span class=\"hljs-type\">bool</span> result = <span class=\"hljs-built_in\">insert</span>(root_, new_value);\n        <span class=\"hljs-keyword\">if</span> (result) {\n            size_++;\n        }\n        <span class=\"hljs-keyword\">return</span> result;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Remove a specified value from the BST.\n     *\n     * @param rm_value The value to remove.\n     * @return true If the removal was successful.\n     * @return false Otherwise.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(T rm_value)</span> </span>{\n        <span class=\"hljs-type\">bool</span> result = <span class=\"hljs-built_in\">remove</span>(root_, root_, rm_value);\n        <span class=\"hljs-keyword\">if</span> (result) {\n            size_--;\n        }\n        <span class=\"hljs-keyword\">return</span> result;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Check if a value is in the BST.\n     *\n     * @param value The value to find.\n     * @return true If value is in the BST.\n     * @return false Otherwise.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">contains</span><span class=\"hljs-params\">(T value)</span> </span>{ <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">contains</span>(root_, value); }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Find the smallest value in the BST.\n     *\n     * @param ret_value Variable to hold the minimum value.\n     * @return true If minimum value was successfully found.\n     * @return false Otherwise.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">find_min</span><span class=\"hljs-params\">(T&amp; ret_value)</span> </span>{ <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">find_min</span>(root_, ret_value); }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Find the largest value in the BST.\n     *\n     * @param ret_value Variable to hold the maximum value.\n     * @return true If maximum value was successfully found.\n     * @return false Otherwise.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">find_max</span><span class=\"hljs-params\">(T&amp; ret_value)</span> </span>{ <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">find_max</span>(root_, ret_value); }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Get the number of values in the BST.\n     *\n     * @return std::size_t Number of values in the BST.\n     */</span>\n    <span class=\"hljs-function\">std::<span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-keyword\">return</span> size_; }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Get all values of the BST in in-order order.\n     *\n     * @return std::vector&lt;T&gt; List of values, sorted in in-order order.\n     */</span>\n    <span class=\"hljs-function\">std::vector&lt;T&gt; <span class=\"hljs-title\">get_elements_inorder</span><span class=\"hljs-params\">()</span> </span>{\n        std::vector&lt;T&gt; result;\n        <span class=\"hljs-built_in\">traverse_inorder</span>([&amp;](T node_value) { result.<span class=\"hljs-built_in\">push_back</span>(node_value); },\n                         root_);\n        <span class=\"hljs-keyword\">return</span> result;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Get all values of the BST in pre-order order.\n     *\n     * @return std::vector&lt;T&gt; List of values, sorted in pre-order order.\n     */</span>\n    <span class=\"hljs-function\">std::vector&lt;T&gt; <span class=\"hljs-title\">get_elements_preorder</span><span class=\"hljs-params\">()</span> </span>{\n        std::vector&lt;T&gt; result;\n        <span class=\"hljs-built_in\">traverse_preorder</span>([&amp;](T node_value) { result.<span class=\"hljs-built_in\">push_back</span>(node_value); },\n                          root_);\n        <span class=\"hljs-keyword\">return</span> result;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Get all values of the BST in post-order order.\n     *\n     * @return std::vector&lt;T&gt; List of values, sorted in post-order order.\n     */</span>\n    <span class=\"hljs-function\">std::vector&lt;T&gt; <span class=\"hljs-title\">get_elements_postorder</span><span class=\"hljs-params\">()</span> </span>{\n        std::vector&lt;T&gt; result;\n        <span class=\"hljs-built_in\">traverse_postorder</span>([&amp;](T node_value) { result.<span class=\"hljs-built_in\">push_back</span>(node_value); },\n                           root_);\n        <span class=\"hljs-keyword\">return</span> result;\n    }\n};\n\n<span class=\"hljs-comment\">/**\n * @brief Function for testing insert().\n * \n * @returns `void`\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_insert</span><span class=\"hljs-params\">()</span> </span>{\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testing BST insert...&quot;</span>;\n\n    binary_search_tree&lt;<span class=\"hljs-type\">int</span>&gt; tree;\n    <span class=\"hljs-type\">bool</span> res = tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-type\">int</span> min = <span class=\"hljs-number\">-1</span>, max = <span class=\"hljs-number\">-1</span>;\n    <span class=\"hljs-built_in\">assert</span>(res);\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">find_max</span>(max));\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">find_min</span>(min));\n    <span class=\"hljs-built_in\">assert</span>(max == <span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-built_in\">assert</span>(min == <span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">1</span>);\n\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">4</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">3</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">6</span>);\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">find_max</span>(max));\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">find_min</span>(min));\n    <span class=\"hljs-built_in\">assert</span>(max == <span class=\"hljs-number\">6</span>);\n    <span class=\"hljs-built_in\">assert</span>(min == <span class=\"hljs-number\">3</span>);\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">4</span>);\n\n    <span class=\"hljs-type\">bool</span> fail_res = tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">4</span>);\n    <span class=\"hljs-built_in\">assert</span>(!fail_res);\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">4</span>);\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;ok&quot;</span> &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Function for testing remove().\n * \n * @returns `void`\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_remove</span><span class=\"hljs-params\">()</span> </span>{\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testing BST remove...&quot;</span>;\n\n    binary_search_tree&lt;<span class=\"hljs-type\">int</span>&gt; tree;\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">5</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">4</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">3</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">6</span>);\n\n    <span class=\"hljs-type\">bool</span> res = tree.<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-type\">int</span> min = <span class=\"hljs-number\">-1</span>, max = <span class=\"hljs-number\">-1</span>;\n    <span class=\"hljs-built_in\">assert</span>(res);\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">find_max</span>(max));\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">find_min</span>(min));\n    <span class=\"hljs-built_in\">assert</span>(max == <span class=\"hljs-number\">6</span>);\n    <span class=\"hljs-built_in\">assert</span>(min == <span class=\"hljs-number\">3</span>);\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">3</span>);\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">contains</span>(<span class=\"hljs-number\">5</span>) == <span class=\"hljs-literal\">false</span>);\n\n    tree.<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-number\">4</span>);\n    tree.<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-number\">3</span>);\n    tree.<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-number\">6</span>);\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">contains</span>(<span class=\"hljs-number\">6</span>) == <span class=\"hljs-literal\">false</span>);\n\n    <span class=\"hljs-type\">bool</span> fail_res = tree.<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-built_in\">assert</span>(!fail_res);\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>);\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;ok&quot;</span> &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Function for testing contains().\n * \n * @returns `void`\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_contains</span><span class=\"hljs-params\">()</span> </span>{\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testing BST contains...&quot;</span>;\n\n    binary_search_tree&lt;<span class=\"hljs-type\">int</span>&gt; tree;\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">5</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">4</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">3</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">6</span>);\n\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">contains</span>(<span class=\"hljs-number\">5</span>));\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">contains</span>(<span class=\"hljs-number\">4</span>));\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">contains</span>(<span class=\"hljs-number\">3</span>));\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">contains</span>(<span class=\"hljs-number\">6</span>));\n    <span class=\"hljs-built_in\">assert</span>(!tree.<span class=\"hljs-built_in\">contains</span>(<span class=\"hljs-number\">999</span>));\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;ok&quot;</span> &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Function for testing find_min().\n * \n * @returns `void`\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_find_min</span><span class=\"hljs-params\">()</span> </span>{\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testing BST find_min...&quot;</span>;\n\n    <span class=\"hljs-type\">int</span> min = <span class=\"hljs-number\">0</span>;\n    binary_search_tree&lt;<span class=\"hljs-type\">int</span>&gt; tree;\n    <span class=\"hljs-built_in\">assert</span>(!tree.<span class=\"hljs-built_in\">find_min</span>(min));\n\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">5</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">4</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">3</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">6</span>);\n\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">find_min</span>(min));\n    <span class=\"hljs-built_in\">assert</span>(min == <span class=\"hljs-number\">3</span>);\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;ok&quot;</span> &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Function for testing find_max().\n * \n * @returns `void`\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_find_max</span><span class=\"hljs-params\">()</span> </span>{\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testing BST find_max...&quot;</span>;\n\n    <span class=\"hljs-type\">int</span> max = <span class=\"hljs-number\">0</span>;\n    binary_search_tree&lt;<span class=\"hljs-type\">int</span>&gt; tree;\n    <span class=\"hljs-built_in\">assert</span>(!tree.<span class=\"hljs-built_in\">find_max</span>(max));\n\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">5</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">4</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">3</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">6</span>);\n\n    <span class=\"hljs-built_in\">assert</span>(tree.<span class=\"hljs-built_in\">find_max</span>(max));\n    <span class=\"hljs-built_in\">assert</span>(max == <span class=\"hljs-number\">6</span>);\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;ok&quot;</span> &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Function for testing get_elements_inorder().\n * \n * @returns `void`\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_get_elements_inorder</span><span class=\"hljs-params\">()</span> </span>{\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testing BST get_elements_inorder...&quot;</span>;\n\n    binary_search_tree&lt;<span class=\"hljs-type\">int</span>&gt; tree;\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">5</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">4</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">3</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">6</span>);\n\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; expected = {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>};\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; actual = tree.<span class=\"hljs-built_in\">get_elements_inorder</span>();\n    <span class=\"hljs-built_in\">assert</span>(actual == expected);\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;ok&quot;</span> &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Function for testing get_elements_preorder().\n * \n * @returns `void`\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_get_elements_preorder</span><span class=\"hljs-params\">()</span> </span>{\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testing BST get_elements_preorder...&quot;</span>;\n\n    binary_search_tree&lt;<span class=\"hljs-type\">int</span>&gt; tree;\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">5</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">4</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">3</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">6</span>);\n\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; expected = {<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>};\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; actual = tree.<span class=\"hljs-built_in\">get_elements_preorder</span>();\n    <span class=\"hljs-built_in\">assert</span>(actual == expected);\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;ok&quot;</span> &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Function for testing get_elements_postorder().\n * \n * @returns `void`\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_get_elements_postorder</span><span class=\"hljs-params\">()</span> </span>{\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testing BST get_elements_postorder...&quot;</span>;\n\n    binary_search_tree&lt;<span class=\"hljs-type\">int</span>&gt; tree;\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">5</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">4</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">3</span>);\n    tree.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">6</span>);\n\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; expected = {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">5</span>};\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; actual = tree.<span class=\"hljs-built_in\">get_elements_postorder</span>();\n    <span class=\"hljs-built_in\">assert</span>(actual == expected);\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;ok&quot;</span> &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">test_insert</span>();\n    <span class=\"hljs-built_in\">test_remove</span>();\n    <span class=\"hljs-built_in\">test_contains</span>();\n    <span class=\"hljs-built_in\">test_find_max</span>();\n    <span class=\"hljs-built_in\">test_find_min</span>();\n    <span class=\"hljs-built_in\">test_get_elements_inorder</span>();\n    <span class=\"hljs-built_in\">test_get_elements_preorder</span>();\n    <span class=\"hljs-built_in\">test_get_elements_postorder</span>();\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Walt",
      "email": "32001362+Walt280@users.noreply.github.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}
