{
  "slug": "horspoolsearch",
  "name": "HorspoolSearch",
  "categories": ["strings"],
  "body": {},
  "implementations": {
    "java": {
      "dir": "strings/HorspoolSearch.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/strings/HorspoolSearch.java",
      "code": "<span class=\"hljs-keyword\">package</span> strings;\n\n<span class=\"hljs-keyword\">import</span> java.util.HashMap;\n\n<span class=\"hljs-comment\">/**\n * This class is not thread safe&lt;br&gt;\n * &lt;br&gt;\n * (From wikipedia) In computer science, the Boyer–Moore–Horspool algorithm or Horspool&#x27;s algorithm\n * is an algorithm for finding substrings in strings. It was published by Nigel Horspool in 1980.\n * &lt;br&gt;\n * &lt;a href=https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm&gt;Wikipedia\n * page&lt;/a&gt;&lt;br&gt;\n * &lt;br&gt;\n *\n * &lt;p&gt;An explanation:&lt;br&gt;\n *\n * &lt;p&gt;The Horspool algorithm is a simplification of the Boyer-Moore algorithm in that it uses only\n * one of the two heuristic methods for increasing the number of characters shifted when finding a\n * bad match in the text. This method is usually called the &quot;bad symbol&quot; or &quot;bad character&quot; shift.\n * The bad symbol shift method is classified as an input enhancement method in the theory of\n * algorithms. Input enhancement is (from wikipedia) the principle that processing a given input to\n * a problem and altering it in a specific way will increase runtime efficiency or space efficiency,\n * or both. Both algorithms try to match the pattern and text comparing the pattern symbols to the\n * text&#x27;s from right to left.&lt;br&gt;\n * &lt;br&gt;\n *\n * &lt;p&gt;In the bad symbol shift method, a table is created prior to the search, called the &quot;bad symbol\n * table&quot;. The bad symbol table contains the shift values for any symbol in the text and pattern.\n * For these symbols, the value is the length of the pattern, if the symbol is not in the first\n * (length - 1) of the pattern. Else it is the distance from its rightmost occurrence in the pattern\n * to the last symbol of the pattern. In practice, we only calculate the values for the ones that\n * exist in the first (length - 1) of the pattern.&lt;br&gt;\n * &lt;br&gt;\n *\n * &lt;p&gt;For more details on the algorithm and the more advanced Boyer-Moore I recommend checking out\n * the wikipedia page and professor Anany Levitin&#x27;s book: Introduction To The Design And Analysis Of\n * Algorithms.\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HorspoolSearch</span> {\n\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> HashMap&lt;Character, Integer&gt; shiftValues; <span class=\"hljs-comment\">// bad symbol table</span>\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Integer patternLength;\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">comparisons</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// total comparisons in the current/last search</span>\n\n  <span class=\"hljs-comment\">/**\n   * Case sensitive version version of the algorithm\n   *\n   * <span class=\"hljs-doctag\">@param</span> pattern the pattern to be searched for (needle)\n   * <span class=\"hljs-doctag\">@param</span> text the text being searched in (haystack)\n   * <span class=\"hljs-doctag\">@return</span> -1 if not found or first index of the pattern in the text\n   */</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">findFirst</span><span class=\"hljs-params\">(String pattern, String text)</span> {\n    <span class=\"hljs-keyword\">return</span> firstOccurrence(pattern, text, <span class=\"hljs-literal\">true</span>);\n  }\n\n  <span class=\"hljs-comment\">/**\n   * Case insensitive version version of the algorithm\n   *\n   * <span class=\"hljs-doctag\">@param</span> pattern the pattern to be searched for (needle)\n   * <span class=\"hljs-doctag\">@param</span> text the text being searched in (haystack)\n   * <span class=\"hljs-doctag\">@return</span> -1 if not found or first index of the pattern in the text\n   */</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">findFirstInsensitive</span><span class=\"hljs-params\">(String pattern, String text)</span> {\n    <span class=\"hljs-keyword\">return</span> firstOccurrence(pattern, text, <span class=\"hljs-literal\">false</span>);\n  }\n\n  <span class=\"hljs-comment\">/**\n   * Utility method that returns comparisons made by last run (mainly for tests)\n   *\n   * <span class=\"hljs-doctag\">@return</span> number of character comparisons of the last search\n   */</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Integer <span class=\"hljs-title function_\">getLastComparisons</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> HorspoolSearch.comparisons;\n  }\n\n  <span class=\"hljs-comment\">/**\n   * Fairly standard implementation of the Horspool algorithm. Only the index of the last character\n   * of the pattern on the text is saved and shifted by the appropriate amount when a mismatch is\n   * found. The algorithm stops at the first match or when the entire text has been exhausted.\n   *\n   * <span class=\"hljs-doctag\">@param</span> pattern String to be matched in the text\n   * <span class=\"hljs-doctag\">@param</span> text text String\n   * <span class=\"hljs-doctag\">@return</span> index of first occurrence of the pattern in the text\n   */</span>\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">firstOccurrence</span><span class=\"hljs-params\">(String pattern, String text, <span class=\"hljs-type\">boolean</span> caseSensitive)</span> {\n    shiftValues = calcShiftValues(pattern); <span class=\"hljs-comment\">// build the bad symbol table</span>\n    comparisons = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// reset comparisons</span>\n\n    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">textIndex</span> <span class=\"hljs-operator\">=</span>\n        pattern.length() - <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// align pattern with text start and get index of the last character</span>\n\n    <span class=\"hljs-comment\">// while pattern is not out of text bounds</span>\n    <span class=\"hljs-keyword\">while</span> (textIndex &lt; text.length()) {\n\n      <span class=\"hljs-comment\">// try to match pattern with current part of the text starting from last character</span>\n      <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> pattern.length() - <span class=\"hljs-number\">1</span>;\n      <span class=\"hljs-keyword\">while</span> (i &gt;= <span class=\"hljs-number\">0</span>) {\n        comparisons++;\n        <span class=\"hljs-type\">char</span> <span class=\"hljs-variable\">patternChar</span> <span class=\"hljs-operator\">=</span> pattern.charAt(i);\n        <span class=\"hljs-type\">char</span> <span class=\"hljs-variable\">textChar</span> <span class=\"hljs-operator\">=</span> text.charAt((textIndex + i) - (pattern.length() - <span class=\"hljs-number\">1</span>));\n        <span class=\"hljs-keyword\">if</span> (!charEquals(patternChar, textChar, caseSensitive)) { <span class=\"hljs-comment\">// bad character, shift pattern</span>\n          textIndex += getShiftValue(text.charAt(textIndex));\n          <span class=\"hljs-keyword\">break</span>;\n        }\n        i--;\n      }\n\n      <span class=\"hljs-comment\">// check for full match</span>\n      <span class=\"hljs-keyword\">if</span> (i == -<span class=\"hljs-number\">1</span>) {\n        <span class=\"hljs-keyword\">return</span> textIndex - pattern.length() + <span class=\"hljs-number\">1</span>;\n      }\n    }\n\n    <span class=\"hljs-comment\">// text exhausted, return failure</span>\n    <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;\n  }\n\n  <span class=\"hljs-comment\">/**\n   * Compares the argument characters\n   *\n   * <span class=\"hljs-doctag\">@param</span> c1 first character\n   * <span class=\"hljs-doctag\">@param</span> c2 second character\n   * <span class=\"hljs-doctag\">@param</span> caseSensitive boolean determining case sensitivity of comparison\n   * <span class=\"hljs-doctag\">@return</span> truth value of the equality comparison\n   */</span>\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">charEquals</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span> c1, <span class=\"hljs-type\">char</span> c2, <span class=\"hljs-type\">boolean</span> caseSensitive)</span> {\n    <span class=\"hljs-keyword\">if</span> (caseSensitive) {\n      <span class=\"hljs-type\">return</span> <span class=\"hljs-variable\">c1</span> <span class=\"hljs-operator\">=</span>= c2;\n    }\n    <span class=\"hljs-keyword\">return</span> Character.toLowerCase(c1) == Character.toLowerCase(c2);\n  }\n\n  <span class=\"hljs-comment\">/**\n   * Builds the bad symbol table required to run the algorithm. The method starts from the second to\n   * last character of the pattern and moves to the left. When it meets a new character, it is by\n   * definition its rightmost occurrence and therefore puts the distance from the current index to\n   * the index of the last character into the table. If the character is already in the table, then\n   * it is not a rightmost occurrence, so it continues.\n   *\n   * <span class=\"hljs-doctag\">@param</span> pattern basis for the bad symbol table\n   * <span class=\"hljs-doctag\">@return</span> the bad symbol table\n   */</span>\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> HashMap&lt;Character, Integer&gt; <span class=\"hljs-title function_\">calcShiftValues</span><span class=\"hljs-params\">(String pattern)</span> {\n    patternLength = pattern.length();\n    HashMap&lt;Character, Integer&gt; table = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;();\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> pattern.length() - <span class=\"hljs-number\">2</span>;\n        i &gt;= <span class=\"hljs-number\">0</span>;\n        i--) { <span class=\"hljs-comment\">// length - 2 is the index of the second to last character</span>\n      <span class=\"hljs-type\">char</span> <span class=\"hljs-variable\">c</span> <span class=\"hljs-operator\">=</span> pattern.charAt(i);\n      <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">finalI</span> <span class=\"hljs-operator\">=</span> i;\n      table.computeIfAbsent(c, k -&gt; pattern.length() - <span class=\"hljs-number\">1</span> - finalI);\n    }\n\n    <span class=\"hljs-keyword\">return</span> table;\n  }\n\n  <span class=\"hljs-comment\">/**\n   * Helper function that uses the bad symbol shift table to return the appropriate shift value for\n   * a given character\n   *\n   * <span class=\"hljs-doctag\">@param</span> c character\n   * <span class=\"hljs-doctag\">@return</span> shift value that corresponds to the character argument\n   */</span>\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Integer <span class=\"hljs-title function_\">getShiftValue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span> c)</span> {\n    <span class=\"hljs-keyword\">if</span> (shiftValues.get(c) != <span class=\"hljs-literal\">null</span>) {\n      <span class=\"hljs-keyword\">return</span> shiftValues.get(c);\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">return</span> patternLength;\n    }\n  }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "George B",
      "email": "geompokon@csd.auth.gr",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}
