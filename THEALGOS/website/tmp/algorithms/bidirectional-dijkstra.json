{
  "slug": "bidirectional-dijkstra",
  "name": "Bidirectional Dijkstra",
  "categories": ["graphs"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "graph/bidirectional_dijkstra.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph/bidirectional_dijkstra.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * @brief [Bidirectional Dijkstra Shortest Path Algorithm]\n * (https://www.coursera.org/learn/algorithms-on-graphs/lecture/7ml18/bidirectional-dijkstra)\n *\n * @author [Marinovksy](http://github.com/Marinovsky)\n *\n * @details\n * This is basically the same Dijkstra Algorithm but faster because it goes from\n * the source to the target and from target to the source and stops when\n * finding a vertex visited already by the direct search or the reverse one.\n * Here some simulations of it:\n * https://www.youtube.com/watch?v=DINCL5cd_w0&amp;t=24s\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>   <span class=\"hljs-comment\">/// for assert</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>  <span class=\"hljs-comment\">/// for io operations</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;limits&gt;</span>    <span class=\"hljs-comment\">/// for variable INF</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span>     <span class=\"hljs-comment\">/// for the priority_queue of distances</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;utility&gt;</span>   <span class=\"hljs-comment\">/// for make_pair function</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>    <span class=\"hljs-comment\">/// for store the graph, the distances, and the path</span></span>\n\n<span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int64_t</span> INF = std::numeric_limits&lt;<span class=\"hljs-type\">int64_t</span>&gt;::<span class=\"hljs-built_in\">max</span>();\n\n<span class=\"hljs-comment\">/**\n * @namespace graph\n * @brief Graph Algorithms\n */</span>\n<span class=\"hljs-keyword\">namespace</span> graph {\n<span class=\"hljs-comment\">/**\n * @namespace bidirectional_dijkstra\n * @brief Functions for [Bidirectional Dijkstra Shortest Path]\n * (https://www.coursera.org/learn/algorithms-on-graphs/lecture/7ml18/bidirectional-dijkstra)\n * algorithm\n */</span>\n<span class=\"hljs-keyword\">namespace</span> bidirectional_dijkstra {\n<span class=\"hljs-comment\">/**\n * @brief Function that add edge between two nodes or vertices of graph\n *\n * @param adj1 adjacency list for the direct search\n * @param adj2 adjacency list for the reverse search\n * @param u any node or vertex of graph\n * @param v any node or vertex of graph\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addEdge</span><span class=\"hljs-params\">(std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt; *adj1,\n             std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt; *adj2,\n             <span class=\"hljs-type\">uint64_t</span> u, <span class=\"hljs-type\">uint64_t</span> v, <span class=\"hljs-type\">uint64_t</span> w)</span> </span>{\n    (*adj1)[u - <span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">push_back</span>(std::<span class=\"hljs-built_in\">make_pair</span>(v - <span class=\"hljs-number\">1</span>, w));\n    (*adj2)[v - <span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">push_back</span>(std::<span class=\"hljs-built_in\">make_pair</span>(u - <span class=\"hljs-number\">1</span>, w));\n    <span class=\"hljs-comment\">// (*adj)[v - 1].push_back(std::make_pair(u - 1, w));</span>\n}\n<span class=\"hljs-comment\">/**\n * @brief This function returns the shortest distance from the source\n * to the target if there is path between vertices &#x27;s&#x27; and &#x27;t&#x27;.\n *\n * @param workset_ vertices visited in the search\n * @param distance_ vector of distances from the source to the target and\n * from the target to the source\n *\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">uint64_t</span> <span class=\"hljs-title\">Shortest_Path_Distance</span><span class=\"hljs-params\">(\n    <span class=\"hljs-keyword\">const</span> std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; &amp;workset_,\n    <span class=\"hljs-keyword\">const</span> std::vector&lt;std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt;&gt; &amp;distance_)</span> </span>{\n    <span class=\"hljs-type\">int64_t</span> distance = INF;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint64_t</span> i : workset_) {\n        <span class=\"hljs-keyword\">if</span> (distance_[<span class=\"hljs-number\">0</span>][i] + distance_[<span class=\"hljs-number\">1</span>][i] &lt; distance) {\n            distance = distance_[<span class=\"hljs-number\">0</span>][i] + distance_[<span class=\"hljs-number\">1</span>][i];\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> distance;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Function runs the dijkstra algorithm for some source vertex and\n * target vertex in the graph and returns the shortest distance of target\n * from the source.\n *\n * @param adj1 input graph\n * @param adj2 input graph reversed\n * @param s source vertex\n * @param t target vertex\n *\n * @return shortest distance if target is reachable from source else -1 in\n * case if target is not reachable from source.\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Bidijkstra</span><span class=\"hljs-params\">(std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt; *adj1,\n               std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt; *adj2,\n               <span class=\"hljs-type\">uint64_t</span> s, <span class=\"hljs-type\">uint64_t</span> t)</span> </span>{\n    <span class=\"hljs-comment\">/// n denotes the number of vertices in graph</span>\n    <span class=\"hljs-type\">uint64_t</span> n = adj1-&gt;<span class=\"hljs-built_in\">size</span>();\n\n    <span class=\"hljs-comment\">/// setting all the distances initially to INF</span>\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt;&gt; <span class=\"hljs-built_in\">dist</span>(<span class=\"hljs-number\">2</span>, std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">uint64_t</span>&gt;(n, INF));\n\n    <span class=\"hljs-comment\">/// creating a a vector of min heap using priority queue</span>\n    <span class=\"hljs-comment\">/// pq[0] contains the min heap for the direct search</span>\n    <span class=\"hljs-comment\">/// pq[1] contains the min heap for the reverse search</span>\n\n    <span class=\"hljs-comment\">/// first element of pair contains the distance</span>\n    <span class=\"hljs-comment\">/// second element of pair contains the vertex</span>\n    std::vector&lt;\n        std::priority_queue&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;,\n                            std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;,\n                            std::greater&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt;&gt;\n        <span class=\"hljs-built_in\">pq</span>(<span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-comment\">/// vector for store the nodes or vertices in the shortest path</span>\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; <span class=\"hljs-title\">workset</span><span class=\"hljs-params\">(n)</span></span>;\n    <span class=\"hljs-comment\">/// vector for store the nodes or vertices visited</span>\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">bool</span>&gt; <span class=\"hljs-title\">visited</span><span class=\"hljs-params\">(n)</span></span>;\n\n    <span class=\"hljs-comment\">/// pushing the source vertex &#x27;s&#x27; with 0 distance in pq[0] min heap</span>\n    pq[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">push</span>(std::<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">0</span>, s));\n\n    <span class=\"hljs-comment\">/// marking the distance of source as 0</span>\n    dist[<span class=\"hljs-number\">0</span>][s] = <span class=\"hljs-number\">0</span>;\n\n    <span class=\"hljs-comment\">/// pushing the target vertex &#x27;t&#x27; with 0 distance in pq[1] min heap</span>\n    pq[<span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">push</span>(std::<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">0</span>, t));\n\n    <span class=\"hljs-comment\">/// marking the distance of target as 0</span>\n    dist[<span class=\"hljs-number\">1</span>][t] = <span class=\"hljs-number\">0</span>;\n\n    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\n        <span class=\"hljs-comment\">/// direct search</span>\n\n        <span class=\"hljs-comment\">// If pq[0].size() is equal to zero then the node/ vertex is not</span>\n        <span class=\"hljs-comment\">// reachable from s</span>\n        <span class=\"hljs-keyword\">if</span> (pq[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">break</span>;\n        }\n        <span class=\"hljs-comment\">/// second element of pair denotes the node / vertex</span>\n        <span class=\"hljs-type\">uint64_t</span> currentNode = pq[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">top</span>().second;\n\n        <span class=\"hljs-comment\">/// first element of pair denotes the distance</span>\n        <span class=\"hljs-type\">uint64_t</span> currentDist = pq[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">top</span>().first;\n\n        pq[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">pop</span>();\n\n        <span class=\"hljs-comment\">/// for all the reachable vertex from the currently exploring vertex</span>\n        <span class=\"hljs-comment\">/// we will try to minimize the distance</span>\n        <span class=\"hljs-keyword\">for</span> (std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; edge : (*adj1)[currentNode]) {\n            <span class=\"hljs-comment\">/// minimizing distances</span>\n            <span class=\"hljs-keyword\">if</span> (currentDist + edge.second &lt; dist[<span class=\"hljs-number\">0</span>][edge.first]) {\n                dist[<span class=\"hljs-number\">0</span>][edge.first] = currentDist + edge.second;\n                pq[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">push</span>(std::<span class=\"hljs-built_in\">make_pair</span>(dist[<span class=\"hljs-number\">0</span>][edge.first], edge.first));\n            }\n        }\n        <span class=\"hljs-comment\">// store the processed node/ vertex</span>\n        workset.<span class=\"hljs-built_in\">push_back</span>(currentNode);\n\n        <span class=\"hljs-comment\">/// check if currentNode has already been visited</span>\n        <span class=\"hljs-keyword\">if</span> (visited[currentNode] == <span class=\"hljs-number\">1</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Shortest_Path_Distance</span>(workset, dist);\n        }\n        visited[currentNode] = <span class=\"hljs-literal\">true</span>;\n        <span class=\"hljs-comment\">/// reversed search</span>\n\n        <span class=\"hljs-comment\">// If pq[1].size() is equal to zero then the node/ vertex is not</span>\n        <span class=\"hljs-comment\">// reachable from t</span>\n        <span class=\"hljs-keyword\">if</span> (pq[<span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">break</span>;\n        }\n        <span class=\"hljs-comment\">/// second element of pair denotes the node / vertex</span>\n        currentNode = pq[<span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">top</span>().second;\n\n        <span class=\"hljs-comment\">/// first element of pair denotes the distance</span>\n        currentDist = pq[<span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">top</span>().first;\n\n        pq[<span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">pop</span>();\n\n        <span class=\"hljs-comment\">/// for all the reachable vertex from the currently exploring vertex</span>\n        <span class=\"hljs-comment\">/// we will try to minimize the distance</span>\n        <span class=\"hljs-keyword\">for</span> (std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; edge : (*adj2)[currentNode]) {\n            <span class=\"hljs-comment\">/// minimizing distances</span>\n            <span class=\"hljs-keyword\">if</span> (currentDist + edge.second &lt; dist[<span class=\"hljs-number\">1</span>][edge.first]) {\n                dist[<span class=\"hljs-number\">1</span>][edge.first] = currentDist + edge.second;\n                pq[<span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">push</span>(std::<span class=\"hljs-built_in\">make_pair</span>(dist[<span class=\"hljs-number\">1</span>][edge.first], edge.first));\n            }\n        }\n        <span class=\"hljs-comment\">// store the processed node/ vertex</span>\n        workset.<span class=\"hljs-built_in\">push_back</span>(currentNode);\n\n        <span class=\"hljs-comment\">/// check if currentNode has already been visited</span>\n        <span class=\"hljs-keyword\">if</span> (visited[currentNode] == <span class=\"hljs-number\">1</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Shortest_Path_Distance</span>(workset, dist);\n        }\n        visited[currentNode] = <span class=\"hljs-literal\">true</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n}\n}  <span class=\"hljs-comment\">// namespace bidirectional_dijkstra</span>\n}  <span class=\"hljs-comment\">// namespace graph</span>\n\n<span class=\"hljs-comment\">/**\n * @brief Function to test the\n * provided algorithm above\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">tests</span><span class=\"hljs-params\">()</span> </span>{\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Initiatinig Predefined Tests...&quot;</span> &lt;&lt; std::endl;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Initiating Test 1...&quot;</span> &lt;&lt; std::endl;\n    std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt; <span class=\"hljs-built_in\">adj1_1</span>(\n        <span class=\"hljs-number\">4</span>, std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;());\n    std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt; <span class=\"hljs-built_in\">adj1_2</span>(\n        <span class=\"hljs-number\">4</span>, std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;());\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj1_1, &amp;adj1_2, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>);\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj1_1, &amp;adj1_2, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj1_1, &amp;adj1_2, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>);\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj1_1, &amp;adj1_2, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>);\n\n    <span class=\"hljs-type\">uint64_t</span> s = <span class=\"hljs-number\">1</span>, t = <span class=\"hljs-number\">3</span>;\n    <span class=\"hljs-built_in\">assert</span>(graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">Bidijkstra</span>(&amp;adj1_1, &amp;adj1_2, s - <span class=\"hljs-number\">1</span>,\n                                                     t - <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">3</span>);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 1 Passed...&quot;</span> &lt;&lt; std::endl;\n\n    s = <span class=\"hljs-number\">4</span>, t = <span class=\"hljs-number\">3</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Initiating Test 2...&quot;</span> &lt;&lt; std::endl;\n    <span class=\"hljs-built_in\">assert</span>(graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">Bidijkstra</span>(&amp;adj1_1, &amp;adj1_2, s - <span class=\"hljs-number\">1</span>,\n                                                     t - <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">5</span>);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 2 Passed...&quot;</span> &lt;&lt; std::endl;\n\n    std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt; <span class=\"hljs-built_in\">adj2_1</span>(\n        <span class=\"hljs-number\">5</span>, std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;());\n    std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt; <span class=\"hljs-built_in\">adj2_2</span>(\n        <span class=\"hljs-number\">5</span>, std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;());\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2_1, &amp;adj2_2, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>);\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2_1, &amp;adj2_2, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>);\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2_1, &amp;adj2_2, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>);\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2_1, &amp;adj2_2, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>);\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2_1, &amp;adj2_2, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>);\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2_1, &amp;adj2_2, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>);\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2_1, &amp;adj2_2, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>);\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2_1, &amp;adj2_2, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">3</span>);\n    graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2_1, &amp;adj2_2, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span>);\n\n    s = <span class=\"hljs-number\">1</span>, t = <span class=\"hljs-number\">5</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Initiating Test 3...&quot;</span> &lt;&lt; std::endl;\n    <span class=\"hljs-built_in\">assert</span>(graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">Bidijkstra</span>(&amp;adj2_1, &amp;adj2_2, s - <span class=\"hljs-number\">1</span>,\n                                                     t - <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">6</span>);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 3 Passed...&quot;</span> &lt;&lt; std::endl;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;All Test Passed...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Main function\n * @returns 0 on exit\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">tests</span>();  <span class=\"hljs-comment\">// running predefined tests</span>\n    <span class=\"hljs-type\">uint64_t</span> vertices = <span class=\"hljs-built_in\">uint64_t</span>();\n    <span class=\"hljs-type\">uint64_t</span> edges = <span class=\"hljs-built_in\">uint64_t</span>();\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the number of vertices : &quot;</span>;\n    std::cin &gt;&gt; vertices;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the number of edges : &quot;</span>;\n    std::cin &gt;&gt; edges;\n\n    std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt; <span class=\"hljs-built_in\">adj1</span>(\n        vertices, std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;());\n    std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;&gt; <span class=\"hljs-built_in\">adj2</span>(\n        vertices, std::vector&lt;std::pair&lt;<span class=\"hljs-type\">uint64_t</span>, <span class=\"hljs-type\">uint64_t</span>&gt;&gt;());\n\n    <span class=\"hljs-type\">uint64_t</span> u = <span class=\"hljs-built_in\">uint64_t</span>(), v = <span class=\"hljs-built_in\">uint64_t</span>(), w = <span class=\"hljs-built_in\">uint64_t</span>();\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the edges by three integers in this form: u v w &quot;</span>\n              &lt;&lt; std::endl;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Example: if there is and edge between node 1 and node 4 with &quot;</span>\n                 <span class=\"hljs-string\">&quot;weight 7 enter: 1 4 7, and then press enter&quot;</span>\n              &lt;&lt; std::endl;\n    <span class=\"hljs-keyword\">while</span> (edges--) {\n        std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj1, &amp;adj2, u, v, w);\n        <span class=\"hljs-keyword\">if</span> (edges != <span class=\"hljs-number\">0</span>) {\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the next edge&quot;</span> &lt;&lt; std::endl;\n        }\n    }\n\n    <span class=\"hljs-type\">uint64_t</span> s = <span class=\"hljs-built_in\">uint64_t</span>(), t = <span class=\"hljs-built_in\">uint64_t</span>();\n    std::cout\n        &lt;&lt; <span class=\"hljs-string\">&quot;Enter the source node and the target node separated by a space&quot;</span>\n        &lt;&lt; std::endl;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Example: If the source node is 5 and the target node is 6 &quot;</span>\n                 <span class=\"hljs-string\">&quot;enter: 5 6 and press enter&quot;</span>\n              &lt;&lt; std::endl;\n    std::cin &gt;&gt; s &gt;&gt; t;\n    <span class=\"hljs-type\">int</span> dist =\n        graph::bidirectional_dijkstra::<span class=\"hljs-built_in\">Bidijkstra</span>(&amp;adj1, &amp;adj2, s - <span class=\"hljs-number\">1</span>, t - <span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-keyword\">if</span> (dist == <span class=\"hljs-number\">-1</span>) {\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Target not reachable from source&quot;</span> &lt;&lt; std::endl;\n    } <span class=\"hljs-keyword\">else</span> {\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Shortest Path Distance : &quot;</span> &lt;&lt; dist &lt;&lt; std::endl;\n    }\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Ricardo Andrés Marino Rojas",
      "email": "47573394+Marinovsky@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}
