{
  "slug": "modular-division",
  "name": "Modular Division",
  "categories": ["blockchain"],
  "body": {},
  "implementations": {
    "python": {
      "dir": "blockchain/modular_division.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/blockchain/modular_division.py",
      "code": "<span class=\"hljs-keyword\">from</span> typing <span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">Tuple</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">modular_division</span>(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">int</span>, b: <span class=\"hljs-built_in\">int</span>, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Modular Division :\n    An efficient algorithm for dividing b by a modulo n.\n\n    GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\n    Given three integers a, b, and n, such that gcd(a,n)=1 and n&gt;1, the algorithm should\n    return an integer x such that 0≤x≤n−1, and  b/a=x(modn) (that is, b=ax(modn)).\n\n    Theorem:\n    a has a multiplicative inverse modulo n iff gcd(a,n) = 1\n\n\n    This find x = b*a^(-1) mod n\n    Uses ExtendedEuclid to find the inverse of a\n\n    &gt;&gt;&gt; modular_division(4,8,5)\n    2\n\n    &gt;&gt;&gt; modular_division(3,8,5)\n    1\n\n    &gt;&gt;&gt; modular_division(4, 11, 5)\n    4\n\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-keyword\">assert</span> n &gt; <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">and</span> a &gt; <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> greatest_common_divisor(a, n) == <span class=\"hljs-number\">1</span>\n    (d, t, s) = extended_gcd(n, a)  <span class=\"hljs-comment\"># Implemented below</span>\n    x = (b * s) % n\n    <span class=\"hljs-keyword\">return</span> x\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">invert_modulo</span>(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">int</span>, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    This function find the inverses of a i.e., a^(-1)\n\n    &gt;&gt;&gt; invert_modulo(2, 5)\n    3\n\n    &gt;&gt;&gt; invert_modulo(8,7)\n    1\n\n    &quot;&quot;&quot;</span>\n    (b, x) = extended_euclid(a, n)  <span class=\"hljs-comment\"># Implemented below</span>\n    <span class=\"hljs-keyword\">if</span> b &lt; <span class=\"hljs-number\">0</span>:\n        b = (b % n + n) % n\n    <span class=\"hljs-keyword\">return</span> b\n\n\n<span class=\"hljs-comment\"># ------------------ Finding Modular division using invert_modulo -------------------</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">modular_division2</span>(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">int</span>, b: <span class=\"hljs-built_in\">int</span>, n: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    This function used the above inversion of a to find x = (b*a^(-1))mod n\n\n    &gt;&gt;&gt; modular_division2(4,8,5)\n    2\n\n    &gt;&gt;&gt; modular_division2(3,8,5)\n    1\n\n    &gt;&gt;&gt; modular_division2(4, 11, 5)\n    4\n\n    &quot;&quot;&quot;</span>\n    s = invert_modulo(a, n)\n    x = (b * s) % n\n    <span class=\"hljs-keyword\">return</span> x\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">extended_gcd</span>(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">int</span>, b: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-type\">Tuple</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>]:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Extended Euclid&#x27;s Algorithm : If d divides a and b and d = a*x + b*y for integers x\n    and y, then d = gcd(a,b)\n    &gt;&gt;&gt; extended_gcd(10, 6)\n    (2, -1, 2)\n\n    &gt;&gt;&gt; extended_gcd(7, 5)\n    (1, -2, 3)\n\n    ** extended_gcd function is used when d = gcd(a,b) is required in output\n\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-keyword\">assert</span> a &gt;= <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> b &gt;= <span class=\"hljs-number\">0</span>\n\n    <span class=\"hljs-keyword\">if</span> b == <span class=\"hljs-number\">0</span>:\n        d, x, y = a, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">else</span>:\n        (d, p, q) = extended_gcd(b, a % b)\n        x = q\n        y = p - q * (a // b)\n\n    <span class=\"hljs-keyword\">assert</span> a % d == <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> b % d == <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">assert</span> d == a * x + b * y\n\n    <span class=\"hljs-keyword\">return</span> (d, x, y)\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">extended_euclid</span>(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">int</span>, b: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-type\">Tuple</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>]:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Extended Euclid\n    &gt;&gt;&gt; extended_euclid(10, 6)\n    (-1, 2)\n\n    &gt;&gt;&gt; extended_euclid(7, 5)\n    (-2, 3)\n\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-keyword\">if</span> b == <span class=\"hljs-number\">0</span>:\n        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    <span class=\"hljs-keyword\">return</span> (y, x - k * y)\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">greatest_common_divisor</span>(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">int</span>, b: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Euclid&#x27;s Lemma :  d divides a and b, if and only if d divides a-b and b\n    Euclid&#x27;s Algorithm\n\n    &gt;&gt;&gt; greatest_common_divisor(7,5)\n    1\n\n    Note : In number theory, two integers a and b are said to be relatively prime,\n        mutually prime, or co-prime if the only positive integer (factor) that divides\n        both of them is 1  i.e., gcd(a,b) = 1.\n\n    &gt;&gt;&gt; greatest_common_divisor(121, 11)\n    11\n\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-keyword\">if</span> a &lt; b:\n        a, b = b, a\n\n    <span class=\"hljs-keyword\">while</span> a % b != <span class=\"hljs-number\">0</span>:\n        a, b = b, a % b\n\n    <span class=\"hljs-keyword\">return</span> b\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    <span class=\"hljs-keyword\">from</span> doctest <span class=\"hljs-keyword\">import</span> testmod\n\n    testmod(name=<span class=\"hljs-string\">&quot;modular_division&quot;</span>, verbose=<span class=\"hljs-literal\">True</span>)\n    testmod(name=<span class=\"hljs-string\">&quot;modular_division2&quot;</span>, verbose=<span class=\"hljs-literal\">True</span>)\n    testmod(name=<span class=\"hljs-string\">&quot;invert_modulo&quot;</span>, verbose=<span class=\"hljs-literal\">True</span>)\n    testmod(name=<span class=\"hljs-string\">&quot;extended_gcd&quot;</span>, verbose=<span class=\"hljs-literal\">True</span>)\n    testmod(name=<span class=\"hljs-string\">&quot;extended_euclid&quot;</span>, verbose=<span class=\"hljs-literal\">True</span>)\n    testmod(name=<span class=\"hljs-string\">&quot;greatest_common_divisor&quot;</span>, verbose=<span class=\"hljs-literal\">True</span>)\n"
    },
    "c-plus-plus": {
      "dir": "math/modular_division.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/math/modular_division.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * @brief An algorithm to divide two numbers under modulo p [Modular\n * Division](https://www.geeksforgeeks.org/modular-division)\n * @details To calculate division of two numbers under modulo p\n * Modulo operator is not distributive under division, therefore\n * we first have to calculate the inverse of divisor using\n * [Fermat&#x27;s little\n theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem)\n * Now, we can multiply the dividend with the inverse of divisor\n * and modulo is distributive over multiplication operation.\n * Let,\n * We have 3 numbers a, b, p\n * To compute (a/b)%p\n * (a/b)%p ≡ (a*(inverse(b)))%p ≡ ((a%p)*inverse(b)%p)%p\n * <span class=\"hljs-doctag\">NOTE:</span> For the existence of inverse of &#x27;b&#x27;, &#x27;b&#x27; and &#x27;p&#x27; must be coprime\n * For simplicity we take p as prime\n * Time Complexity: O(log(b))\n * Example: ( 24 / 3 ) % 5 =&gt; 8 % 5 = 3 --- (i)\n            Now the inverse of 3 is 2\n            (24 * 2) % 5 = (24 % 5) * (2 % 5) = (4 * 2) % 5 = 3 --- (ii)\n            (i) and (ii) are equal hence the answer is correct.\n * @see modular_inverse_fermat_little_theorem.cpp, modular_exponentiation.cpp\n * @author [Shubham Yadav](https://github.com/shubhamamsa)\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>   <span class=\"hljs-comment\">/// for assert</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>  <span class=\"hljs-comment\">/// for IO operations</span></span>\n\n<span class=\"hljs-comment\">/**\n * @namespace math\n * @brief Mathematical algorithms\n */</span>\n<span class=\"hljs-keyword\">namespace</span> math {\n<span class=\"hljs-comment\">/**\n * @namespace modular_division\n * @brief Functions for [Modular\n * Division](https://www.geeksforgeeks.org/modular-division) implementation\n */</span>\n<span class=\"hljs-keyword\">namespace</span> modular_division {\n<span class=\"hljs-comment\">/**\n * @brief This function calculates a raised to exponent b under modulo c using\n * modular exponentiation.\n * @param a integer base\n * @param b unsigned integer exponent\n * @param c integer modulo\n * @return a raised to power b modulo c\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">uint64_t</span> <span class=\"hljs-title\">power</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint64_t</span> a, <span class=\"hljs-type\">uint64_t</span> b, <span class=\"hljs-type\">uint64_t</span> c)</span> </span>{\n    <span class=\"hljs-type\">uint64_t</span> ans = <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">/// Initialize the answer to be returned</span>\n    a = a % c;         <span class=\"hljs-comment\">/// Update a if it is more than or equal to c</span>\n    <span class=\"hljs-keyword\">if</span> (a == <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">/// In case a is divisible by c;</span>\n    }\n    <span class=\"hljs-keyword\">while</span> (b &gt; <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-comment\">/// If b is odd, multiply a with answer</span>\n        <span class=\"hljs-keyword\">if</span> (b &amp; <span class=\"hljs-number\">1</span>) {\n            ans = ((ans % c) * (a % c)) % c;\n        }\n        <span class=\"hljs-comment\">/// b must be even now</span>\n        b = b &gt;&gt; <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">/// b = b/2</span>\n        a = ((a % c) * (a % c)) % c;\n    }\n    <span class=\"hljs-keyword\">return</span> ans;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief This function calculates modular division\n * @param a integer dividend\n * @param b integer divisor\n * @param p integer modulo\n * @return a/b modulo c\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">uint64_t</span> <span class=\"hljs-title\">mod_division</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint64_t</span> a, <span class=\"hljs-type\">uint64_t</span> b, <span class=\"hljs-type\">uint64_t</span> p)</span> </span>{\n    <span class=\"hljs-type\">uint64_t</span> inverse = <span class=\"hljs-built_in\">power</span>(b, p - <span class=\"hljs-number\">2</span>, p) % p;  <span class=\"hljs-comment\">/// Calculate the inverse of b</span>\n    <span class=\"hljs-type\">uint64_t</span> result =\n        ((a % p) * (inverse % p)) % p;  <span class=\"hljs-comment\">/// Calculate the final result</span>\n    <span class=\"hljs-keyword\">return</span> result;\n}\n}  <span class=\"hljs-comment\">// namespace modular_division</span>\n}  <span class=\"hljs-comment\">// namespace math</span>\n\n<span class=\"hljs-comment\">/**\n * Function for testing power function.\n * test cases and assert statement.\n * @returns `void`\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-type\">uint64_t</span> test_case_1 = math::modular_division::<span class=\"hljs-built_in\">mod_division</span>(<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-built_in\">assert</span>(test_case_1 == <span class=\"hljs-number\">0</span>);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 1 Passed!&quot;</span> &lt;&lt; std::endl;\n    <span class=\"hljs-type\">uint64_t</span> test_case_2 = math::modular_division::<span class=\"hljs-built_in\">mod_division</span>(<span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>);\n    <span class=\"hljs-built_in\">assert</span>(test_case_2 == <span class=\"hljs-number\">5</span>);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 2 Passed!&quot;</span> &lt;&lt; std::endl;\n    <span class=\"hljs-type\">uint64_t</span> test_case_3 = math::modular_division::<span class=\"hljs-built_in\">mod_division</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-built_in\">assert</span>(test_case_3 == <span class=\"hljs-number\">0</span>);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 3 Passed!&quot;</span> &lt;&lt; std::endl;\n    <span class=\"hljs-type\">uint64_t</span> test_case_4 = math::modular_division::<span class=\"hljs-built_in\">mod_division</span>(<span class=\"hljs-number\">81</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-built_in\">assert</span>(test_case_4 == <span class=\"hljs-number\">2</span>);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 4 Passed!&quot;</span> &lt;&lt; std::endl;\n    <span class=\"hljs-type\">uint64_t</span> test_case_5 = math::modular_division::<span class=\"hljs-built_in\">mod_division</span>(<span class=\"hljs-number\">12848</span>, <span class=\"hljs-number\">73</span>, <span class=\"hljs-number\">29</span>);\n    <span class=\"hljs-built_in\">assert</span>(test_case_5 == <span class=\"hljs-number\">2</span>);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 5 Passed!&quot;</span> &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Main function\n * @param argc commandline argument count (ignored)\n * @param argv commandline array of arguments (ignored)\n * @returns 0 on exit\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span> </span>{\n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">// execute the tests</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 1
    },
    {
      "name": "shellhub",
      "email": "shellhub.me@gmail.com",
      "commits": 1
    },
    {
      "name": "John Law",
      "email": "johnlaw.po@gmail.com",
      "commits": 1
    },
    {
      "name": "Jenia Dysin",
      "email": "jenia90@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Jie Han",
      "email": "jay.cn@outlook.com",
      "commits": 1
    },
    {
      "name": "Phyllipe Bezerra",
      "email": "32442929+pmba@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Sushil Singh",
      "email": "36241112+OddExtension5@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}
