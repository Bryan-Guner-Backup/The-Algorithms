{
  "slug": "non-recursive-segment-tree",
  "name": "Non Recursive Segment Tree",
  "categories": ["datastructures", "binarytree"],
  "body": {},
  "implementations": {
    "python": {
      "dir": "data_structures/binary_tree/non_recursive_segment_tree.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/data_structures/binary_tree/non_recursive_segment_tree.py",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;\nA non-recursive Segment Tree implementation with range query and single element update,\nworks virtually with any list of the same type of elements with a &quot;commutative&quot;\ncombiner.\n\nExplanation:\nhttps://www.geeksforgeeks.org/iterative-segment-tree-range-minimum-query/\nhttps://www.geeksforgeeks.org/segment-tree-efficient-implementation/\n\n<span class=\"hljs-meta\">&gt;&gt;&gt; </span>SegmentTree([1, 2, 3], lambda a, b: a + b).query(0, 2)\n6\n<span class=\"hljs-meta\">&gt;&gt;&gt; </span>SegmentTree([3, 1, 2], min).query(0, 2)\n1\n<span class=\"hljs-meta\">&gt;&gt;&gt; </span>SegmentTree([2, 3, 1], max).query(0, 2)\n3\n<span class=\"hljs-meta\">&gt;&gt;&gt; </span>st = SegmentTree([1, 5, 7, -1, 6], lambda a, b: a + b)\n<span class=\"hljs-meta\">&gt;&gt;&gt; </span>st.update(1, -1)\n<span class=\"hljs-meta\">&gt;&gt;&gt; </span>st.update(2, 3)\n<span class=\"hljs-meta\">&gt;&gt;&gt; </span>st.query(1, 2)\n2\n<span class=\"hljs-meta\">&gt;&gt;&gt; </span>st.query(1, 1)\n-1\n<span class=\"hljs-meta\">&gt;&gt;&gt; </span>st.update(4, 1)\n<span class=\"hljs-meta\">&gt;&gt;&gt; </span>st.query(3, 4)\n0\n<span class=\"hljs-meta\">&gt;&gt;&gt; </span>st = SegmentTree([[1, 2, 3], [3, 2, 1], [1, 1, 1]], lambda a, b: [a[i] + b[i] for i\n<span class=\"hljs-meta\">... </span>                                                                  in range(len(a))])\n<span class=\"hljs-meta\">&gt;&gt;&gt; </span>st.query(0, 1)\n[4, 4, 4]\n<span class=\"hljs-meta\">&gt;&gt;&gt; </span>st.query(1, 2)\n[4, 3, 2]\n<span class=\"hljs-meta\">&gt;&gt;&gt; </span>st.update(1, [-1, -1, -1])\n<span class=\"hljs-meta\">&gt;&gt;&gt; </span>st.query(1, 2)\n[0, 0, 0]\n<span class=\"hljs-meta\">&gt;&gt;&gt; </span>st.query(0, 2)\n[1, 2, 3]\n&quot;&quot;&quot;</span>\n<span class=\"hljs-keyword\">from</span> __future__ <span class=\"hljs-keyword\">import</span> annotations\n\n<span class=\"hljs-keyword\">from</span> typing <span class=\"hljs-keyword\">import</span> <span class=\"hljs-type\">Callable</span>, TypeVar\n\nT = TypeVar(<span class=\"hljs-string\">&quot;T&quot;</span>)\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SegmentTree</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, arr: <span class=\"hljs-built_in\">list</span>[T], fnc: <span class=\"hljs-type\">Callable</span>[[T, T], T]</span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        Segment Tree constructor, it works just with commutative combiner.\n        :param arr: list of elements for the segment tree\n        :param fnc: commutative function for combine two elements\n\n        &gt;&gt;&gt; SegmentTree([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], lambda a, b: f&#x27;{a}{b}&#x27;).query(0, 2)\n        &#x27;abc&#x27;\n        &gt;&gt;&gt; SegmentTree([(1, 2), (2, 3), (3, 4)],\n        ...             lambda a, b: (a[0] + b[0], a[1] + b[1])).query(0, 2)\n        (6, 9)\n        &quot;&quot;&quot;</span>\n        self.N = <span class=\"hljs-built_in\">len</span>(arr)\n        self.st = [<span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(arr))] + arr\n        self.fn = fnc\n        self.build()\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">self</span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-keyword\">for</span> p <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(self.N - <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">1</span>):\n            self.st[p] = self.fn(self.st[p * <span class=\"hljs-number\">2</span>], self.st[p * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>])\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">update</span>(<span class=\"hljs-params\">self, p: <span class=\"hljs-built_in\">int</span>, v: T</span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        Update an element in log(N) time\n        :param p: position to be update\n        :param v: new value\n\n        &gt;&gt;&gt; st = SegmentTree([3, 1, 2, 4], min)\n        &gt;&gt;&gt; st.query(0, 3)\n        1\n        &gt;&gt;&gt; st.update(2, -1)\n        &gt;&gt;&gt; st.query(0, 3)\n        -1\n        &quot;&quot;&quot;</span>\n        p += self.N\n        self.st[p] = v\n        <span class=\"hljs-keyword\">while</span> p &gt; <span class=\"hljs-number\">1</span>:\n            p = p // <span class=\"hljs-number\">2</span>\n            self.st[p] = self.fn(self.st[p * <span class=\"hljs-number\">2</span>], self.st[p * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>])\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">query</span>(<span class=\"hljs-params\">self, l: <span class=\"hljs-built_in\">int</span>, r: <span class=\"hljs-built_in\">int</span></span>) -&gt; T:  <span class=\"hljs-comment\"># noqa: E741</span>\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        Get range query value in log(N) time\n        :param l: left element index\n        :param r: right element index\n        :return: element combined in the range [l, r]\n\n        &gt;&gt;&gt; st = SegmentTree([1, 2, 3, 4], lambda a, b: a + b)\n        &gt;&gt;&gt; st.query(0, 2)\n        6\n        &gt;&gt;&gt; st.query(1, 2)\n        5\n        &gt;&gt;&gt; st.query(0, 3)\n        10\n        &gt;&gt;&gt; st.query(2, 3)\n        7\n        &quot;&quot;&quot;</span>\n        l, r = l + self.N, r + self.N  <span class=\"hljs-comment\"># noqa: E741</span>\n        res = <span class=\"hljs-literal\">None</span>\n        <span class=\"hljs-keyword\">while</span> l &lt;= r:  <span class=\"hljs-comment\"># noqa: E741</span>\n            <span class=\"hljs-keyword\">if</span> l % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span>:\n                res = self.st[l] <span class=\"hljs-keyword\">if</span> res <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">else</span> self.fn(res, self.st[l])\n            <span class=\"hljs-keyword\">if</span> r % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n                res = self.st[r] <span class=\"hljs-keyword\">if</span> res <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">else</span> self.fn(res, self.st[r])\n            l, r = (l + <span class=\"hljs-number\">1</span>) // <span class=\"hljs-number\">2</span>, (r - <span class=\"hljs-number\">1</span>) // <span class=\"hljs-number\">2</span>\n        <span class=\"hljs-keyword\">return</span> res\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    <span class=\"hljs-keyword\">from</span> functools <span class=\"hljs-keyword\">import</span> reduce\n\n    test_array = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">10</span>, -<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">9</span>, -<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">4</span>, -<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">11</span>, -<span class=\"hljs-number\">12</span>]\n\n    test_updates = {\n        <span class=\"hljs-number\">0</span>: <span class=\"hljs-number\">7</span>,\n        <span class=\"hljs-number\">1</span>: <span class=\"hljs-number\">2</span>,\n        <span class=\"hljs-number\">2</span>: <span class=\"hljs-number\">6</span>,\n        <span class=\"hljs-number\">3</span>: -<span class=\"hljs-number\">14</span>,\n        <span class=\"hljs-number\">4</span>: <span class=\"hljs-number\">5</span>,\n        <span class=\"hljs-number\">5</span>: <span class=\"hljs-number\">4</span>,\n        <span class=\"hljs-number\">6</span>: <span class=\"hljs-number\">7</span>,\n        <span class=\"hljs-number\">7</span>: -<span class=\"hljs-number\">10</span>,\n        <span class=\"hljs-number\">8</span>: <span class=\"hljs-number\">9</span>,\n        <span class=\"hljs-number\">9</span>: <span class=\"hljs-number\">10</span>,\n        <span class=\"hljs-number\">10</span>: <span class=\"hljs-number\">12</span>,\n        <span class=\"hljs-number\">11</span>: <span class=\"hljs-number\">1</span>,\n    }\n\n    min_segment_tree = SegmentTree(test_array, <span class=\"hljs-built_in\">min</span>)\n    max_segment_tree = SegmentTree(test_array, <span class=\"hljs-built_in\">max</span>)\n    sum_segment_tree = SegmentTree(test_array, <span class=\"hljs-keyword\">lambda</span> a, b: a + b)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">test_all_segments</span>():\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        Test all possible segments\n        &quot;&quot;&quot;</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(test_array)):\n            <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(i, <span class=\"hljs-built_in\">len</span>(test_array)):\n                min_range = reduce(<span class=\"hljs-built_in\">min</span>, test_array[i : j + <span class=\"hljs-number\">1</span>])\n                max_range = reduce(<span class=\"hljs-built_in\">max</span>, test_array[i : j + <span class=\"hljs-number\">1</span>])\n                sum_range = reduce(<span class=\"hljs-keyword\">lambda</span> a, b: a + b, test_array[i : j + <span class=\"hljs-number\">1</span>])\n                <span class=\"hljs-keyword\">assert</span> min_range == min_segment_tree.query(i, j)\n                <span class=\"hljs-keyword\">assert</span> max_range == max_segment_tree.query(i, j)\n                <span class=\"hljs-keyword\">assert</span> sum_range == sum_segment_tree.query(i, j)\n\n    test_all_segments()\n\n    <span class=\"hljs-keyword\">for</span> index, value <span class=\"hljs-keyword\">in</span> test_updates.items():\n        test_array[index] = value\n        min_segment_tree.update(index, value)\n        max_segment_tree.update(index, value)\n        sum_segment_tree.update(index, value)\n        test_all_segments()\n"
    }
  },
  "contributors": [
    {
      "name": "CarsonHam",
      "email": "carson.ham@utexas.edu",
      "commits": 1
    },
    {
      "name": "Jonathan Alberth Quispe Fuentes",
      "email": "qf.jonathan@gmail.com",
      "commits": 1
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 3
    }
  ],
  "explanationUrl": {}
}
