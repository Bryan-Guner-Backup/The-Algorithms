{
  "slug": "quad-tree",
  "name": "Quad Tree",
  "categories": ["datastructures", "quadtree"],
  "body": {},
  "implementations": {
    "dart": {
      "dir": "data_structures/quad_tree/quad_tree.dart",
      "url": "https://github.com/TheAlgorithms/dart/tree/master/data_structures/quad_tree/quad_tree.dart",
      "code": "<span class=\"hljs-comment\">// Author: Jerold Albertson</span>\n<span class=\"hljs-comment\">// Profile: https://github.com/jerold</span>\n<span class=\"hljs-comment\">// Algorithm: https://en.wikipedia.org/wiki/Quadtree</span>\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;dart:math&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;package:test/test.dart&#x27;</span>;\n\n<span class=\"hljs-comment\">// defaults should almost never be used, tune the quad tree to fit your problem</span>\n<span class=\"hljs-built_in\">int</span> default_max_depth = <span class=\"hljs-number\">1000</span>;\n<span class=\"hljs-built_in\">int</span> default_max_items = <span class=\"hljs-number\">100</span>;\n\n<span class=\"hljs-comment\">// names reflect a coordinate system where values increase as one goes left or down</span>\n<span class=\"hljs-keyword\">const</span> _upperLeftIndex = <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-keyword\">const</span> _upperRightIndex = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">const</span> _lowerLeftIndex = <span class=\"hljs-number\">2</span>;\n<span class=\"hljs-keyword\">const</span> _lowerRightIndex = <span class=\"hljs-number\">3</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Node</span>&lt;<span class=\"hljs-title\">T</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Rectangle</span>&lt;<span class=\"hljs-title\">num</span>&gt; </span>{\n  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-built_in\">int</span> maxDepth;\n  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-built_in\">int</span> maxItems;\n\n  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-built_in\">int</span> _depth;\n  <span class=\"hljs-keyword\">final</span> Point&lt;<span class=\"hljs-built_in\">num</span>&gt; _center;\n  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-built_in\">List</span>&lt;_ItemAtPoint&lt;T&gt;&gt; _items = &lt;_ItemAtPoint&lt;T&gt;&gt;[];\n  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-built_in\">List</span>&lt;Node&lt;T&gt;&gt; _children = &lt;Node&lt;T&gt;&gt;[];\n\n  <span class=\"hljs-keyword\">factory</span> Node(<span class=\"hljs-built_in\">num</span> left, <span class=\"hljs-built_in\">num</span> top, <span class=\"hljs-built_in\">num</span> width, <span class=\"hljs-built_in\">num</span> height,\n          {<span class=\"hljs-built_in\">int</span> maxDepth, <span class=\"hljs-built_in\">int</span> maxItems}) =&gt;\n      Node._(left, top, width, height, maxDepth, maxItems, <span class=\"hljs-number\">0</span>);\n\n  Node._(<span class=\"hljs-built_in\">num</span> left, <span class=\"hljs-built_in\">num</span> top, <span class=\"hljs-built_in\">num</span> width, <span class=\"hljs-built_in\">num</span> height, <span class=\"hljs-built_in\">int</span> maxDepth, <span class=\"hljs-built_in\">int</span> maxItems,\n      <span class=\"hljs-built_in\">int</span> depth)\n      : maxDepth = maxDepth ?? default_max_depth,\n        maxItems = maxItems ?? default_max_items,\n        _depth = depth,\n        _center = Point&lt;<span class=\"hljs-built_in\">num</span>&gt;(left + width / <span class=\"hljs-number\">2.0</span>, top + height / <span class=\"hljs-number\">2.0</span>),\n        <span class=\"hljs-keyword\">super</span>(left, top, width, height);\n\n  <span class=\"hljs-built_in\">bool</span> insert(T item, Point&lt;<span class=\"hljs-built_in\">num</span>&gt; atPoint) {\n    <span class=\"hljs-keyword\">if</span> (!containsPoint(atPoint)) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n\n    <span class=\"hljs-keyword\">if</span> (_children.isEmpty) {\n      <span class=\"hljs-keyword\">if</span> (_items.length + <span class=\"hljs-number\">1</span> &lt;= maxItems || _depth + <span class=\"hljs-number\">1</span> &gt; maxDepth) {\n        _items.add(_ItemAtPoint&lt;T&gt;(item, atPoint));\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n      }\n      _splitItemsBetweenChildren();\n    }\n    <span class=\"hljs-keyword\">return</span> _insertItemIntoChildren(item, atPoint);\n  }\n\n  <span class=\"hljs-built_in\">List</span>&lt;T&gt; query(Rectangle range) {\n    <span class=\"hljs-keyword\">if</span> (_children.isEmpty) {\n      <span class=\"hljs-keyword\">return</span> _items\n          .where((item) =&gt; range.containsPoint(item.point))\n          .map((item) =&gt; item.item)\n          .toList();\n    }\n    <span class=\"hljs-keyword\">return</span> _children\n        .where((child) =&gt; child.intersects(range))\n        .expand((child) =&gt; child.query(range))\n        .toList();\n  }\n\n  <span class=\"hljs-built_in\">String</span> toString() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;[<span class=\"hljs-subst\">$_depth</span>](<span class=\"hljs-subst\">${_items.map((item) =&gt; item.item).toList()}</span>:<span class=\"hljs-subst\">$_children</span>)&#x27;</span>;\n  }\n\n  <span class=\"hljs-built_in\">bool</span> _insertItemIntoChildren(T item, Point&lt;<span class=\"hljs-built_in\">num</span>&gt; atPoint) {\n    <span class=\"hljs-keyword\">if</span> (atPoint.x &gt; _center.x) {\n      <span class=\"hljs-keyword\">if</span> (atPoint.y &gt; _center.y) {\n        <span class=\"hljs-keyword\">return</span> _children[_lowerRightIndex].insert(item, atPoint);\n      }\n      <span class=\"hljs-keyword\">return</span> _children[_upperRightIndex].insert(item, atPoint);\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">if</span> (atPoint.y &gt; _center.y) {\n        <span class=\"hljs-keyword\">return</span> _children[_lowerLeftIndex].insert(item, atPoint);\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">return</span> _children[_upperLeftIndex].insert(item, atPoint);\n      }\n    }\n  }\n\n  <span class=\"hljs-keyword\">void</span> _splitItemsBetweenChildren() {\n    _children.addAll([\n      _newUpperLeft, <span class=\"hljs-comment\">// _upperLeftIndex = 0</span>\n      _newUpperRight, <span class=\"hljs-comment\">// _upperRightIndex = 1</span>\n      _newLowerLeft, <span class=\"hljs-comment\">// _lowerLeftIndex = 2</span>\n      _newLowerRight <span class=\"hljs-comment\">// _lowerRightIndex = 3</span>\n    ]);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">final</span> item <span class=\"hljs-keyword\">in</span> _items) {\n      _insertItemIntoChildren(item.item, item.point);\n    }\n    _items.clear();\n  }\n\n  Node&lt;T&gt; <span class=\"hljs-keyword\">get</span> _newUpperLeft =&gt; Node&lt;T&gt;._(\n      left, top, width / <span class=\"hljs-number\">2.0</span>, height / <span class=\"hljs-number\">2.0</span>, maxDepth, maxItems, _depth + <span class=\"hljs-number\">1</span>);\n\n  Node&lt;T&gt; <span class=\"hljs-keyword\">get</span> _newUpperRight =&gt; Node&lt;T&gt;._(_center.x, top, width / <span class=\"hljs-number\">2.0</span>,\n      height / <span class=\"hljs-number\">2.0</span>, maxDepth, maxItems, _depth + <span class=\"hljs-number\">1</span>);\n\n  Node&lt;T&gt; <span class=\"hljs-keyword\">get</span> _newLowerLeft =&gt; Node&lt;T&gt;._(left, _center.y, width / <span class=\"hljs-number\">2.0</span>,\n      height / <span class=\"hljs-number\">2.0</span>, maxDepth, maxItems, _depth + <span class=\"hljs-number\">1</span>);\n\n  Node&lt;T&gt; <span class=\"hljs-keyword\">get</span> _newLowerRight =&gt; Node&lt;T&gt;._(_center.x, _center.y, width / <span class=\"hljs-number\">2.0</span>,\n      height / <span class=\"hljs-number\">2.0</span>, maxDepth, maxItems, _depth + <span class=\"hljs-number\">1</span>);\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">_ItemAtPoint</span>&lt;<span class=\"hljs-title\">T</span>&gt; </span>{\n  <span class=\"hljs-keyword\">final</span> T item;\n  <span class=\"hljs-keyword\">final</span> Point&lt;<span class=\"hljs-built_in\">num</span>&gt; point;\n\n  _ItemAtPoint(<span class=\"hljs-keyword\">this</span>.item, <span class=\"hljs-keyword\">this</span>.point);\n}\n\n<span class=\"hljs-keyword\">void</span> main() {\n  group(<span class=\"hljs-string\">&#x27;QuadTree&#x27;</span>, () {\n    test(<span class=\"hljs-string\">&#x27;items will not insert at points outside the tree\\&#x27;s bounds&#x27;</span>, () {\n      <span class=\"hljs-keyword\">final</span> tree = Node&lt;<span class=\"hljs-built_in\">String</span>&gt;(<span class=\"hljs-number\">-50</span>, <span class=\"hljs-number\">-50</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>);\n      expect(tree.insert(<span class=\"hljs-string\">&quot;a&quot;</span>, Point(<span class=\"hljs-number\">-75</span>, <span class=\"hljs-number\">0</span>)), isFalse);\n      expect(tree.insert(<span class=\"hljs-string\">&quot;b&quot;</span>, Point(<span class=\"hljs-number\">75</span>, <span class=\"hljs-number\">0</span>)), isFalse);\n      expect(tree.insert(<span class=\"hljs-string\">&quot;c&quot;</span>, Point(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-75</span>)), isFalse);\n      expect(tree.insert(<span class=\"hljs-string\">&quot;d&quot;</span>, Point(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">75</span>)), isFalse);\n      expect(tree.toString(), equals(<span class=\"hljs-string\">&quot;[0]([]:[])&quot;</span>));\n    });\n\n    test(<span class=\"hljs-string\">&#x27;maxItems is honored until maxDepth is hit&#x27;</span>, () {\n      <span class=\"hljs-keyword\">final</span> tree = Node&lt;<span class=\"hljs-built_in\">String</span>&gt;(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, maxItems: <span class=\"hljs-number\">2</span>, maxDepth: <span class=\"hljs-number\">2</span>);\n\n      expect(tree.insert(<span class=\"hljs-string\">&quot;a&quot;</span>, Point(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>)), isTrue);\n      expect(tree.toString(), equals(<span class=\"hljs-string\">&quot;[0]([a]:[])&quot;</span>));\n\n      expect(tree.insert(<span class=\"hljs-string\">&quot;b&quot;</span>, Point(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">0</span>)), isTrue);\n      expect(tree.toString(), equals(<span class=\"hljs-string\">&quot;[0]([a, b]:[])&quot;</span>));\n\n      expect(tree.insert(<span class=\"hljs-string\">&quot;c&quot;</span>, Point(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>)), isTrue);\n      expect(\n          tree.toString(),\n          equals(\n              <span class=\"hljs-string\">&quot;[0]([]:[[1]([a]:[]), [1]([b]:[]), [1]([c]:[]), [1]([]:[])])&quot;</span>));\n\n      expect(tree.insert(<span class=\"hljs-string\">&quot;d&quot;</span>, Point(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>)), isTrue);\n      expect(\n          tree.toString(),\n          equals(\n              <span class=\"hljs-string\">&quot;[0]([]:[[1]([a]:[]), [1]([b]:[]), [1]([c]:[]), [1]([d]:[])])&quot;</span>));\n\n      expect(tree.insert(<span class=\"hljs-string\">&quot;e&quot;</span>, Point(<span class=\"hljs-number\">99</span>, <span class=\"hljs-number\">99</span>)), isTrue);\n      expect(tree.insert(<span class=\"hljs-string\">&quot;f&quot;</span>, Point(<span class=\"hljs-number\">99</span>, <span class=\"hljs-number\">99</span>)), isTrue);\n      expect(tree.insert(<span class=\"hljs-string\">&quot;g&quot;</span>, Point(<span class=\"hljs-number\">99</span>, <span class=\"hljs-number\">99</span>)), isTrue);\n      expect(tree.insert(<span class=\"hljs-string\">&quot;h&quot;</span>, Point(<span class=\"hljs-number\">99</span>, <span class=\"hljs-number\">99</span>)), isTrue);\n      expect(\n          tree.toString(),\n          equals(\n              <span class=\"hljs-string\">&quot;[0]([]:[[1]([a]:[]), [1]([b]:[]), [1]([c]:[]), [1]([]:[[2]([]:[]), [2]([]:[]), [2]([]:[]), [2]([d, e, f, g, h]:[])])])&quot;</span>));\n    });\n\n    test(\n        <span class=\"hljs-string\">&#x27;better at finding local points within a large space than simple iteration&#x27;</span>,\n        () {\n      <span class=\"hljs-keyword\">final</span> rand = Random.secure();\n      <span class=\"hljs-keyword\">final</span> items = &lt;<span class=\"hljs-built_in\">int</span>, Point&gt;{};\n\n      <span class=\"hljs-keyword\">final</span> width = <span class=\"hljs-number\">1000</span>;\n      <span class=\"hljs-keyword\">final</span> height = <span class=\"hljs-number\">1000</span>;\n\n      <span class=\"hljs-keyword\">var</span> timesBetter = <span class=\"hljs-number\">0</span>;\n      <span class=\"hljs-keyword\">final</span> numberOfRuns = <span class=\"hljs-number\">100</span>;\n      <span class=\"hljs-comment\">// run the same test x number of times</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; numberOfRuns; j++) {\n        <span class=\"hljs-comment\">// test consists of setting up x items, distributing them randomly</span>\n        <span class=\"hljs-comment\">// within a space, and then searching for a small subset of those</span>\n        <span class=\"hljs-comment\">// using simple rect comparison on all items, or a quad tree query</span>\n        <span class=\"hljs-keyword\">final</span> tree = Node(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, width, height);\n        <span class=\"hljs-keyword\">final</span> numberOfItems = <span class=\"hljs-number\">50000</span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; numberOfItems; i++) {\n          items[i] =\n              Point(rand.nextDouble() * width, rand.nextDouble() * height);\n          expect(tree.insert(i, items[i]), isTrue);\n        }\n\n        <span class=\"hljs-comment\">// set up a box that is 1/10th the size of the total space</span>\n        <span class=\"hljs-keyword\">final</span> rangeSizePercentage = <span class=\"hljs-number\">.1</span>;\n        <span class=\"hljs-keyword\">final</span> rangeWidth = width * rangeSizePercentage;\n        <span class=\"hljs-keyword\">final</span> rangeHeight = height * rangeSizePercentage;\n        <span class=\"hljs-keyword\">final</span> rangeLeft = rand.nextDouble() * (width - rangeWidth);\n        <span class=\"hljs-keyword\">final</span> rangeTop = rand.nextDouble() * (height - rangeHeight);\n\n        <span class=\"hljs-keyword\">final</span> range = Rectangle(rangeLeft, rangeTop, rangeWidth, rangeHeight);\n\n        <span class=\"hljs-comment\">// simple iteration over all items, comparing each to the given range</span>\n        <span class=\"hljs-keyword\">var</span> startTime = <span class=\"hljs-built_in\">DateTime</span>.now();\n        <span class=\"hljs-keyword\">final</span> foundA =\n            items.keys.where((key) =&gt; range.containsPoint(items[key])).toList();\n        <span class=\"hljs-keyword\">var</span> iterationTime = <span class=\"hljs-built_in\">DateTime</span>.now().difference(startTime);\n\n        <span class=\"hljs-comment\">// quad tree query rules out whole quadrants full of points when possible</span>\n        startTime = <span class=\"hljs-built_in\">DateTime</span>.now();\n        <span class=\"hljs-keyword\">final</span> foundB = tree.query(range);\n        <span class=\"hljs-keyword\">var</span> quadTreeTime = <span class=\"hljs-built_in\">DateTime</span>.now().difference(startTime);\n\n        <span class=\"hljs-keyword\">if</span> (iterationTime.compareTo(quadTreeTime) &gt; <span class=\"hljs-number\">0</span>) {\n          timesBetter++;\n        }\n\n        <span class=\"hljs-comment\">// every time, quad tree query results should equal brute force results</span>\n        expect(foundA.toSet().containsAll(foundB), isTrue,\n            reason: <span class=\"hljs-string\">&quot;not all items were found&quot;</span>);\n        expect(foundB.toSet().containsAll(foundA), isTrue,\n            reason: <span class=\"hljs-string\">&quot;not all items were found&quot;</span>);\n      }\n\n      expect(timesBetter / numberOfRuns &gt; <span class=\"hljs-number\">0.5</span>, isTrue,\n          reason:\n              <span class=\"hljs-string\">&quot;tree query was only better <span class=\"hljs-subst\">${timesBetter / numberOfRuns * <span class=\"hljs-number\">100</span>}</span>% of the time&quot;</span>);\n    });\n  });\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Jerold Albertson",
      "email": "jerold.albertson@gmail.com",
      "commits": 4
    }
  ],
  "explanationUrl": {}
}
