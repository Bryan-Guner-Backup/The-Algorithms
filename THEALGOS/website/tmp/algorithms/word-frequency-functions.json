{
  "slug": "word-frequency-functions",
  "name": "Word Frequency Functions",
  "categories": ["machinelearning"],
  "body": {},
  "implementations": {
    "python": {
      "dir": "machine_learning/word_frequency_functions.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/machine_learning/word_frequency_functions.py",
      "code": "<span class=\"hljs-keyword\">import</span> string\n<span class=\"hljs-keyword\">from</span> math <span class=\"hljs-keyword\">import</span> log10\n\n<span class=\"hljs-string\">&quot;&quot;&quot;\n    tf-idf Wikipedia: https://en.wikipedia.org/wiki/Tf%E2%80%93idf\n    tf-idf and other word frequency algorithms are often used\n    as a weighting factor in information retrieval and text\n    mining. 83% of text-based recommender systems use\n    tf-idf for term weighting. In Layman&#x27;s terms, tf-idf\n    is a statistic intended to reflect how important a word\n    is to a document in a corpus (a collection of documents)\n\n\n    Here I&#x27;ve implemented several word frequency algorithms\n    that are commonly used in information retrieval: Term Frequency,\n    Document Frequency, and TF-IDF (Term-Frequency*Inverse-Document-Frequency)\n    are included.\n\n    Term Frequency is a statistical function that\n    returns a number representing how frequently\n    an expression occurs in a document. This\n    indicates how significant a particular term is in\n    a given document.\n\n    Document Frequency is a statistical function that returns\n    an integer representing the number of documents in a\n    corpus that a term occurs in (where the max number returned\n    would be the number of documents in the corpus).\n\n    Inverse Document Frequency is mathematically written as\n    log10(N/df), where N is the number of documents in your\n    corpus and df is the Document Frequency. If df is 0, a\n    ZeroDivisionError will be thrown.\n\n    Term-Frequency*Inverse-Document-Frequency is a measure\n    of the originality of a term. It is mathematically written\n    as tf*log10(N/df). It compares the number of times\n    a term appears in a document with the number of documents\n    the term appears in. If df is 0, a ZeroDivisionError will be thrown.\n&quot;&quot;&quot;</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">term_frequency</span>(<span class=\"hljs-params\">term: <span class=\"hljs-built_in\">str</span>, document: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Return the number of times a term occurs within\n    a given document.\n    @params: term, the term to search a document for, and document,\n            the document to search within\n    @returns: an integer representing the number of times a term is\n            found within the document\n\n    @examples:\n    &gt;&gt;&gt; term_frequency(&quot;to&quot;, &quot;To be, or not to be&quot;)\n    2\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-comment\"># strip all punctuation and newlines and replace it with &#x27;&#x27;</span>\n    document_without_punctuation = document.translate(\n        <span class=\"hljs-built_in\">str</span>.maketrans(<span class=\"hljs-string\">&quot;&quot;</span>, <span class=\"hljs-string\">&quot;&quot;</span>, string.punctuation)\n    ).replace(<span class=\"hljs-string\">&quot;\\n&quot;</span>, <span class=\"hljs-string\">&quot;&quot;</span>)\n    tokenize_document = document_without_punctuation.split(<span class=\"hljs-string\">&quot; &quot;</span>)  <span class=\"hljs-comment\"># word tokenization</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>([word <span class=\"hljs-keyword\">for</span> word <span class=\"hljs-keyword\">in</span> tokenize_document <span class=\"hljs-keyword\">if</span> word.lower() == term.lower()])\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">document_frequency</span>(<span class=\"hljs-params\">term: <span class=\"hljs-built_in\">str</span>, corpus: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>]:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Calculate the number of documents in a corpus that contain a\n    given term\n    @params : term, the term to search each document for, and corpus, a collection of\n             documents. Each document should be separated by a newline.\n    @returns : the number of documents in the corpus that contain the term you are\n               searching for and the number of documents in the corpus\n    @examples :\n    &gt;&gt;&gt; document_frequency(&quot;first&quot;, &quot;This is the first document in the corpus.\\\\nThIs\\\nis the second document in the corpus.\\\\nTHIS is \\\nthe third document in the corpus.&quot;)\n    (1, 3)\n    &quot;&quot;&quot;</span>\n    corpus_without_punctuation = corpus.lower().translate(\n        <span class=\"hljs-built_in\">str</span>.maketrans(<span class=\"hljs-string\">&quot;&quot;</span>, <span class=\"hljs-string\">&quot;&quot;</span>, string.punctuation)\n    )  <span class=\"hljs-comment\"># strip all punctuation and replace it with &#x27;&#x27;</span>\n    docs = corpus_without_punctuation.split(<span class=\"hljs-string\">&quot;\\n&quot;</span>)\n    term = term.lower()\n    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-built_in\">len</span>([doc <span class=\"hljs-keyword\">for</span> doc <span class=\"hljs-keyword\">in</span> docs <span class=\"hljs-keyword\">if</span> term <span class=\"hljs-keyword\">in</span> doc]), <span class=\"hljs-built_in\">len</span>(docs))\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">inverse_document_frequency</span>(<span class=\"hljs-params\">df: <span class=\"hljs-built_in\">int</span>, N: <span class=\"hljs-built_in\">int</span>, smoothing=<span class=\"hljs-literal\">False</span></span>) -&gt; <span class=\"hljs-built_in\">float</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Return an integer denoting the importance\n    of a word. This measure of importance is\n    calculated by log10(N/df), where N is the\n    number of documents and df is\n    the Document Frequency.\n    @params : df, the Document Frequency, N,\n    the number of documents in the corpus and\n    smoothing, if True return the idf-smooth\n    @returns : log10(N/df) or 1+log10(N/1+df)\n    @examples :\n    &gt;&gt;&gt; inverse_document_frequency(3, 0)\n    Traceback (most recent call last):\n     ...\n    ValueError: log10(0) is undefined.\n    &gt;&gt;&gt; inverse_document_frequency(1, 3)\n    0.477\n    &gt;&gt;&gt; inverse_document_frequency(0, 3)\n    Traceback (most recent call last):\n     ...\n    ZeroDivisionError: df must be &gt; 0\n    &gt;&gt;&gt; inverse_document_frequency(0, 3,True)\n    1.477\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-keyword\">if</span> smoothing:\n        <span class=\"hljs-keyword\">if</span> N == <span class=\"hljs-number\">0</span>:\n            <span class=\"hljs-keyword\">raise</span> ValueError(<span class=\"hljs-string\">&quot;log10(0) is undefined.&quot;</span>)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">round</span>(<span class=\"hljs-number\">1</span> + log10(N / (<span class=\"hljs-number\">1</span> + df)), <span class=\"hljs-number\">3</span>)\n\n    <span class=\"hljs-keyword\">if</span> df == <span class=\"hljs-number\">0</span>:\n        <span class=\"hljs-keyword\">raise</span> ZeroDivisionError(<span class=\"hljs-string\">&quot;df must be &gt; 0&quot;</span>)\n    <span class=\"hljs-keyword\">elif</span> N == <span class=\"hljs-number\">0</span>:\n        <span class=\"hljs-keyword\">raise</span> ValueError(<span class=\"hljs-string\">&quot;log10(0) is undefined.&quot;</span>)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">round</span>(log10(N / df), <span class=\"hljs-number\">3</span>)\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">tf_idf</span>(<span class=\"hljs-params\">tf: <span class=\"hljs-built_in\">int</span>, idf: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">float</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Combine the term frequency\n    and inverse document frequency functions to\n    calculate the originality of a term. This\n    &#x27;originality&#x27; is calculated by multiplying\n    the term frequency and the inverse document\n    frequency : tf-idf = TF * IDF\n    @params : tf, the term frequency, and idf, the inverse document\n    frequency\n    @examples :\n    &gt;&gt;&gt; tf_idf(2, 0.477)\n    0.954\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">round</span>(tf * idf, <span class=\"hljs-number\">3</span>)\n"
    }
  },
  "contributors": [
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 1
    },
    {
      "name": "vinayak",
      "email": "itssvinayak@gmail.com",
      "commits": 1
    },
    {
      "name": "algobytewise",
      "email": "algobytewise@gmail.com",
      "commits": 1
    },
    {
      "name": "Shubham Shaswat",
      "email": "shaswat.cpp@gmail.com",
      "commits": 1
    },
    {
      "name": "Dan Murphy",
      "email": "danielmurph8@gmail.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}
