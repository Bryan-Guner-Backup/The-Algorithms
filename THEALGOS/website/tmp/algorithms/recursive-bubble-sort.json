{
  "slug": "recursive-bubble-sort",
  "name": "Recursive Bubble Sort",
  "categories": ["sorts"],
  "body": {
    "en": "<p>Bubble Sort is one of the simplest sorting algorithms that compares two elements at a time and swaps them if they are in the wrong order. This process is repeated until the entire sequence is in order.</p>\n<ul>\n<li>Time Complexity: <code>O(n ^ 2)</code> for average case; <code>O(n)</code> for best case.</li>\n<li>Space Complexity: <code>O(n)</code>; note that iterative bubble sort has space complexity as <code>O(1)</code>.</li>\n</ul>\n<h2>Steps</h2>\n<p>Base case: If the size of the array is 1, return.</p>\n<ul>\n<li>We need to fix the last element of the current sub-array. For this, iterate over the entire array using normal Bubble Sort, and perform swapping.</li>\n<li>Next, call the function on the entire array excluding the last element(which was fixed by the iteration in the above step)</li>\n<li>Repeat until Base Case is reached.</li>\n</ul>\n<h2>Example</h2>\n<p>Let the given array be: <code>{5, 3, 2, 1, 4}</code></p>\n<p><strong>First Iteration:</strong></p>\n<ul>\n<li>{<code>5</code>, <code>3</code>, 2, 1, 4} -> {<code>3</code>, <code>5</code>, 2, 1, 4} Swap since <code>5 > 3</code></li>\n<li>{3, <code>5</code>, <code>2</code>, 1, 4} -> {3, <code>2</code>, <code>5</code>, 1, 4} Swap since <code>5 > 2</code></li>\n<li>{3, 2, <code>5</code>, <code>1</code>, 4} -> {3, 2, <code>1</code>, <code>5</code>, 4} Swap since <code>5 > 1</code></li>\n<li>{3, 2, 1, <code>5</code>, <code>4</code>} -> {3, 2, 1, <code>4</code>, <code>5</code>} Swap since <code>5 > 4</code></li>\n</ul>\n<p>This iteration has fixed the position of 5. Now, we will consider the array up to index 3.</p>\n<p><strong>Second Iteration:</strong></p>\n<ul>\n<li>{<code>3</code>, <code>2</code>, 1, 4, 5} -> {<code>2</code>, <code>3</code>, 1, 4, 5} Swap since <code>3 > 2</code></li>\n<li>{2, <code>3</code>, <code>1</code>, 4, 5} -> {2, <code>1</code>, <code>3</code>, 4, 5} Swap since <code>3 > 1</code></li>\n<li>{2, 1, <code>3</code>, <code>4</code>, 5}; As <code>3 &#x3C; 4</code>, do not swap</li>\n</ul>\n<p>Note: As we check one less element with every iteration, we do not need elements at index 3 and 4 i.e., <code>4</code> and <code>5</code>, as 5 is already in order. Formally, for an array with <code>n</code> integers, we consider elements only up to index <code>n - i</code>, where <code>i</code> is the iteration number.</p>\n<p><strong>Third Iteration:</strong></p>\n<ul>\n<li>{<code>2</code>, <code>1</code>, 3, 4, 5} -> {<code>1</code>, <code>2</code>, 3, 4, 5} Swap since <code>1 > 2</code></li>\n<li>{1, <code>2</code>, <code>3</code>, 4, 5}; As <code>2 &#x3C; 3</code>, do not swap</li>\n</ul>\n<p><strong>Fourth Iteration:</strong></p>\n<ul>\n<li>{<code>1</code>, <code>2</code>, 3, 4, 5}; As <code>1 &#x3C; 2</code>, do not swap</li>\n</ul>\n<p><strong>Fifth Iteration:</strong></p>\n<ul>\n<li>{<code>1</code>, 2, 3, 4, 5}; As the size of the array is 1, return.</li>\n</ul>\n<p>Note: This is the base case.</p>\n<h2>Pseudo Code</h2>\n<pre><code class=\"hljs language-isbl\"><span class=\"hljs-variable\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">bubbleSort</span>(<span class=\"hljs-variable\">arr</span>[], <span class=\"hljs-variable\">n</span>)</span>\n    <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(<span class=\"hljs-variable\">n</span>==<span class=\"hljs-number\">1</span>)</span>\n        <span class=\"hljs-variable\">return</span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-title\">for</span>(<span class=\"hljs-variable\">i</span> = <span class=\"hljs-number\">0</span>; <span class=\"hljs-variable\">i</span>&#x3C;<span class=\"hljs-variable\">n</span>-<span class=\"hljs-number\">1</span>; <span class=\"hljs-variable\">i</span>++)</span>\n        <span class=\"hljs-function\"><span class=\"hljs-title\">if</span>(<span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">i</span>] > <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">i</span>+<span class=\"hljs-number\">1</span>])</span>\n            <span class=\"hljs-function\"><span class=\"hljs-title\">swap</span>(<span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">i</span>], <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">i</span>+<span class=\"hljs-number\">1</span>])</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-title\">bubbleSort</span>(<span class=\"hljs-variable\">arr</span>, <span class=\"hljs-variable\">n</span>-<span class=\"hljs-number\">1</span>)</span>\n</code></pre>\n<h2>Implementations</h2>\n<ul>\n<li><a href=\"https://github.com/TheAlgorithms/Java/blob/master/Sorts/BubbleSortRecursion.java\">Java</a></li>\n<li><a href=\"https://github.com/TheAlgorithms/C/blob/master/sorting/bubble_sort_recursion.c\">C</a></li>\n</ul>\n<h2>Video Explanation</h2>\n<p><a href=\"https://www.youtube.com/watch?v=gDMDVLBfCI0\">A video explaining iterative as well as recursive bubble sort</a></p>"
  },
  "implementations": {
    "python": {
      "dir": "sorts/recursive_bubble_sort.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/sorts/recursive_bubble_sort.py",
      "code": "<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">bubble_sort</span>(<span class=\"hljs-params\">list_data: <span class=\"hljs-built_in\">list</span>, length: <span class=\"hljs-built_in\">int</span> = <span class=\"hljs-number\">0</span></span>) -&gt; <span class=\"hljs-built_in\">list</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    It is similar is bubble sort but recursive.\r\n    :param list_data: mutable ordered sequence of elements\r\n    :param length: length of list data\r\n    :return: the same list in ascending order\r\n\r\n    &gt;&gt;&gt; bubble_sort([0, 5, 2, 3, 2], 5)\r\n    [0, 2, 2, 3, 5]\r\n\r\n    &gt;&gt;&gt; bubble_sort([], 0)\r\n    []\r\n\r\n    &gt;&gt;&gt; bubble_sort([-2, -45, -5], 3)\r\n    [-45, -5, -2]\r\n\r\n    &gt;&gt;&gt; bubble_sort([-23, 0, 6, -4, 34], 5)\r\n    [-23, -4, 0, 6, 34]\r\n\r\n    &gt;&gt;&gt; bubble_sort([-23, 0, 6, -4, 34], 5) == sorted([-23, 0, 6, -4, 34])\r\n    True\r\n\r\n    &gt;&gt;&gt; bubble_sort([&#x27;z&#x27;,&#x27;a&#x27;,&#x27;y&#x27;,&#x27;b&#x27;,&#x27;x&#x27;,&#x27;c&#x27;], 6)\r\n    [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;]\r\n\r\n    &gt;&gt;&gt; bubble_sort([1.1, 3.3, 5.5, 7.7, 2.2, 4.4, 6.6])\r\n    [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7]\r\n    &quot;&quot;&quot;</span>\r\n    length = length <span class=\"hljs-keyword\">or</span> <span class=\"hljs-built_in\">len</span>(list_data)\r\n    swapped = <span class=\"hljs-literal\">False</span>\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(length - <span class=\"hljs-number\">1</span>):\r\n        <span class=\"hljs-keyword\">if</span> list_data[i] &gt; list_data[i + <span class=\"hljs-number\">1</span>]:\r\n            list_data[i], list_data[i + <span class=\"hljs-number\">1</span>] = list_data[i + <span class=\"hljs-number\">1</span>], list_data[i]\r\n            swapped = <span class=\"hljs-literal\">True</span>\r\n\r\n    <span class=\"hljs-keyword\">return</span> list_data <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> swapped <span class=\"hljs-keyword\">else</span> bubble_sort(list_data, length - <span class=\"hljs-number\">1</span>)\r\n\r\n\r\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\r\n    <span class=\"hljs-keyword\">import</span> doctest\r\n\r\n    doctest.testmod()\r\n"
    },
    "c-plus-plus": {
      "dir": "sorting/recursive_bubble_sort.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/sorting/recursive_bubble_sort.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * @author [Aditya Prakash](https://adityaprakash.tech)\n * @brief This is an implementation of a recursive version of the [Bubble sort algorithm](https://www.geeksforgeeks.org/recursive-bubble-sort/)\n *\n * @details\n * The working principle of the Bubble sort algorithm.\n\n * Bubble sort is a simple sorting algorithm used to rearrange a set of ascending or descending order elements.\n * Bubble sort gets its name from the fact that data &quot;bubbles&quot; to the top of the dataset.\n \n * ### Algorithm\n\n * What is Swap?\n\n * Swapping two numbers means that we interchange their values.\n * Often, an additional variable is required for this operation. \n * This is further illustrated in the following:\n\n * void swap(int x, int y){\n *     int z = x;\n *     x = y;\n *     y = z;\n * }\n\n * The above process is a typical displacement process.\n * When we assign a value to x, the old value of x is lost.\n * That&#x27;s why we create a temporary variable z to store the initial value of x.\n * z is further used to assign the initial value of x to y, to complete swapping.\n\n * Recursion\n\n * While the recursive method does not necessarily have advantages over iterative\n * versions, but it is useful to enhance the understanding of the algorithm and\n * recursion itself. In Recursive Bubble sort algorithm, we firstly call the\n * function on the entire array, and for every subsequent function call, we exclude\n * the last element. This fixes the last element for that sub-array.Formally, for\n * `ith` iteration, we consider elements up to n-i, where n is the number of\n * elements in the array. Exit condition: n==1; i.e. the sub-array contains only\n * one element.\n\n * Complexity\n * Time complexity: O(n) best case; O(n²) average case; O(n²) worst case\n * Space complexity: O(n)\n\n * We need to traverse the array `n * (n-1)` times. However, if the entire array is\n * already sorted, then we need to traverse it only once. Hence, O(n) is the best case\n * complexity\n*/</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>   <span class=\"hljs-comment\">/// for assert</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>  <span class=\"hljs-comment\">/// for IO operations</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>    <span class=\"hljs-comment\">/// for std::vector</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;array&gt;</span>     <span class=\"hljs-comment\">/// for std::array</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span> <span class=\"hljs-comment\">/// for std::is_sorted</span></span>\n\n<span class=\"hljs-comment\">/**\n * @namespace sorting\n * @brief Sorting algorithms\n */</span>\n<span class=\"hljs-keyword\">namespace</span> sorting {\n\n<span class=\"hljs-comment\">/**\n * @brief This is an implementation of the recursive_bubble_sort. A vector is passed\n * to the function which is then dereferenced, so that the changes are\n * reflected in the original vector. It also accepts a second parameter of\n * type `int` and name `n`, which is the size of the array.\n * \n * @tparam T type of data variables in the array\n * @param nums our array of elements.\n * @param n size of the array\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">recursive_bubble_sort</span><span class=\"hljs-params\">(std::vector&lt;T&gt; *nums, <span class=\"hljs-type\">uint64_t</span> n)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (n == <span class=\"hljs-number\">1</span>) {  <span class=\"hljs-comment\">//!&lt; base case; when size of the array is 1</span>\n        <span class=\"hljs-keyword\">return</span>;\n    }\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint64_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; n - <span class=\"hljs-number\">1</span>; i++) {  <span class=\"hljs-comment\">//!&lt; iterating over the entire array</span>\n        <span class=\"hljs-comment\">//!&lt; if a larger number appears before the smaller one, swap them.</span>\n        <span class=\"hljs-keyword\">if</span> ((*nums)[i] &gt; (*nums)[i + <span class=\"hljs-number\">1</span>]) {\n            std::<span class=\"hljs-built_in\">swap</span>((*nums)[i], (*nums)[i + <span class=\"hljs-number\">1</span>]);\n        }\n    }\n\n    <span class=\"hljs-comment\">//!&lt; calling the function after we have fixed the last element</span>\n    <span class=\"hljs-built_in\">recursive_bubble_sort</span>(nums, n - <span class=\"hljs-number\">1</span>);\n}\n}  <span class=\"hljs-comment\">// namespace sorting</span>\n\n<span class=\"hljs-comment\">/**\n * @brief Self-test implementations\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// 1st example. Creating an array of type `int`.</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;1st test using `int`\\n&quot;</span>;\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">uint64_t</span> size = <span class=\"hljs-number\">6</span>;\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; arr;\n    <span class=\"hljs-comment\">// populating the array</span>\n    arr.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">22</span>);\n    arr.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">46</span>);\n    arr.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">94</span>);\n    arr.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">12</span>);\n    arr.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">37</span>);\n    arr.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">63</span>);\n    <span class=\"hljs-comment\">// array populating ends</span>\n\n    sorting::<span class=\"hljs-built_in\">recursive_bubble_sort</span>(&amp;arr, size);\n    <span class=\"hljs-built_in\">assert</span>(std::<span class=\"hljs-built_in\">is_sorted</span>(std::<span class=\"hljs-built_in\">begin</span>(arr), std::<span class=\"hljs-built_in\">end</span>(arr)));\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot; 1st test passed!\\n&quot;</span>;\n    <span class=\"hljs-comment\">// printing the array</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint64_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; i++) {\n        std::cout &lt;&lt; arr[i] &lt;&lt; <span class=\"hljs-string\">&quot;, &quot;</span>;\n    }\n    std::cout &lt;&lt; std::endl;\n\n    <span class=\"hljs-comment\">// 2nd example. Creating an array of type `double`.</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;2nd test using doubles\\n&quot;</span>;\n    std::vector&lt;<span class=\"hljs-type\">double</span>&gt; double_arr;\n\n    <span class=\"hljs-comment\">// populating the array</span>\n    double_arr.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">20.4</span>);\n    double_arr.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">62.7</span>);\n    double_arr.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">12.2</span>);\n    double_arr.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">43.6</span>);\n    double_arr.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">74.1</span>);\n    double_arr.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">57.9</span>);\n    <span class=\"hljs-comment\">// array populating ends</span>\n\n    sorting::<span class=\"hljs-built_in\">recursive_bubble_sort</span>(&amp;double_arr, size);\n    <span class=\"hljs-built_in\">assert</span>(std::<span class=\"hljs-built_in\">is_sorted</span>(std::<span class=\"hljs-built_in\">begin</span>(double_arr), std::<span class=\"hljs-built_in\">end</span>(double_arr)));\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot; 2nd test passed!\\n&quot;</span>;\n    <span class=\"hljs-comment\">// printing the array</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint64_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; i++) {\n        std::cout &lt;&lt; double_arr[i] &lt;&lt; <span class=\"hljs-string\">&quot;, &quot;</span>;\n    }\n    std::cout &lt;&lt; std::endl;\n\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Main function\n * @returns 0 on exit\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{ \n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">// run self-test implementations</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "shellhub",
      "email": "shellhub.me@gmail.com",
      "commits": 1
    },
    {
      "name": "Aditya Prakash",
      "email": "55011564+AdityaPrakash-26@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "harsh patel",
      "email": "hkp27299@gmail.com",
      "commits": 1
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 2
    }
  ],
  "explanationUrl": {
    "en": "https://github.com/TheAlgorithms/Algorithms-Explanation/tree/master/en/Sorting Algorithms/Recursive Versions/Recursive Bubble Sort.md"
  }
}
