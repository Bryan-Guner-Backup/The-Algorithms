{
  "slug": "adaline-learning",
  "name": "Adaline Learning",
  "categories": ["machinelearning"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "machine_learning/adaline_learning.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/machine_learning/adaline_learning.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * \\addtogroup machine_learning Machine Learning Algorithms\n * @{\n * \\file\n * \\brief [Adaptive Linear Neuron\n * (ADALINE)](https://en.wikipedia.org/wiki/ADALINE) implementation\n *\n * \\author [Krishna Vedala](https://github.com/kvedala)\n *\n * \\details\n * &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Adaline_flow_chart.gif&quot;&gt;&lt;img\n * src=&quot;https://upload.wikimedia.org/wikipedia/commons/b/be/Adaline_flow_chart.gif&quot;\n * alt=&quot;Structure of an ADALINE network. Source: Wikipedia&quot;\n * style=&quot;width:200px; float:right;&quot;&gt;&lt;/a&gt;\n *\n * ADALINE is one of the first and simplest single layer artificial neural\n * network. The algorithm essentially implements a linear function\n * \\f[ f\\left(x_0,x_1,x_2,\\ldots\\right) =\n * \\sum_j x_jw_j+\\theta\n * \\f]\n * where \\f$x_j\\f$ are the input features of a sample, \\f$w_j\\f$ are the\n * coefficients of the linear function and \\f$\\theta\\f$ is a constant. If we\n * know the \\f$w_j\\f$, then for any given set of features, \\f$y\\f$ can be\n * computed. Computing the \\f$w_j\\f$ is a supervised learning algorithm wherein\n * a set of features and their corresponding outputs are given and weights are\n * computed using stochastic gradient descent method.\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;array&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;climits&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdlib&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ctime&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;numeric&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\n\n<span class=\"hljs-comment\">/** Maximum number of iterations to learn */</span>\n<span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> MAX_ITER = <span class=\"hljs-number\">500</span>;  <span class=\"hljs-comment\">// INT_MAX</span>\n\n<span class=\"hljs-comment\">/** \\namespace machine_learning\n * \\brief Machine learning algorithms\n */</span>\n<span class=\"hljs-keyword\">namespace</span> machine_learning {\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">adaline</span> {\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-comment\">/**\n     * Default constructor\n     * \\param[in] num_features number of features present\n     * \\param[in] eta learning rate (optional, default=0.1)\n     * \\param[in] convergence accuracy (optional,\n     * default=\\f$1\\times10^{-5}\\f$)\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">adaline</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num_features, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">double</span> eta = <span class=\"hljs-number\">0.01f</span>,\n                     <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">double</span> accuracy = <span class=\"hljs-number\">1e-5</span>)</span>\n        : eta(eta), accuracy(accuracy) {</span>\n        <span class=\"hljs-keyword\">if</span> (eta &lt;= <span class=\"hljs-number\">0</span>) {\n            std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;learning rate should be positive and nonzero&quot;</span>\n                      &lt;&lt; std::endl;\n            std::<span class=\"hljs-built_in\">exit</span>(EXIT_FAILURE);\n        }\n\n        weights = std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;(\n            num_features +\n            <span class=\"hljs-number\">1</span>);  <span class=\"hljs-comment\">// additional weight is for the constant bias term</span>\n\n        <span class=\"hljs-comment\">// initialize with random weights in the range [-50, 49]</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">double</span> &amp;weight : weights) weight = <span class=\"hljs-number\">1.f</span>;\n        <span class=\"hljs-comment\">// weights[i] = (static_cast&lt;double&gt;(std::rand() % 100) - 50);</span>\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Operator to print the weights of the model\n     */</span>\n    <span class=\"hljs-keyword\">friend</span> std::ostream &amp;<span class=\"hljs-keyword\">operator</span>&lt;&lt;(std::ostream &amp;out, <span class=\"hljs-keyword\">const</span> adaline &amp;ada) {\n        out &lt;&lt; <span class=\"hljs-string\">&quot;&lt;&quot;</span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; ada.weights.<span class=\"hljs-built_in\">size</span>(); i++) {\n            out &lt;&lt; ada.weights[i];\n            <span class=\"hljs-keyword\">if</span> (i &lt; ada.weights.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>) {\n                out &lt;&lt; <span class=\"hljs-string\">&quot;, &quot;</span>;\n            }\n        }\n        out &lt;&lt; <span class=\"hljs-string\">&quot;&gt;&quot;</span>;\n        <span class=\"hljs-keyword\">return</span> out;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * predict the output of the model for given set of features\n     * \\param[in] x input vector\n     * \\param[out] out optional argument to return neuron output before\n     * applying activation function (optional, `nullptr` to ignore) \\returns\n     * model prediction output\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">predict</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::vector&lt;<span class=\"hljs-type\">double</span>&gt; &amp;x, <span class=\"hljs-type\">double</span> *out = <span class=\"hljs-literal\">nullptr</span>)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">check_size_match</span>(x)) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n        }\n\n        <span class=\"hljs-type\">double</span> y = weights.<span class=\"hljs-built_in\">back</span>();  <span class=\"hljs-comment\">// assign bias value</span>\n\n        <span class=\"hljs-comment\">// for (int i = 0; i &lt; x.size(); i++) y += x[i] * weights[i];</span>\n        y = std::<span class=\"hljs-built_in\">inner_product</span>(x.<span class=\"hljs-built_in\">begin</span>(), x.<span class=\"hljs-built_in\">end</span>(), weights.<span class=\"hljs-built_in\">begin</span>(), y);\n\n        <span class=\"hljs-keyword\">if</span> (out != <span class=\"hljs-literal\">nullptr</span>) {  <span class=\"hljs-comment\">// if out variable is provided</span>\n            *out = y;\n        }\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">activation</span>(y);  <span class=\"hljs-comment\">// quantizer: apply ADALINE threshold function</span>\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Update the weights of the model using supervised learning for one\n     * feature vector\n     * \\param[in] x feature vector\n     * \\param[in] y known output value\n     * \\returns correction factor\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">fit</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::vector&lt;<span class=\"hljs-type\">double</span>&gt; &amp;x, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> &amp;y)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">check_size_match</span>(x)) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n        }\n\n        <span class=\"hljs-comment\">/* output of the model with current weights */</span>\n        <span class=\"hljs-type\">int</span> p = <span class=\"hljs-built_in\">predict</span>(x);\n        <span class=\"hljs-type\">int</span> prediction_error = y - p;  <span class=\"hljs-comment\">// error in estimation</span>\n        <span class=\"hljs-type\">double</span> correction_factor = eta * prediction_error;\n\n        <span class=\"hljs-comment\">/* update each weight, the last weight is the bias term */</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; x.<span class=\"hljs-built_in\">size</span>(); i++) {\n            weights[i] += correction_factor * x[i];\n        }\n        weights[x.<span class=\"hljs-built_in\">size</span>()] += correction_factor;  <span class=\"hljs-comment\">// update bias</span>\n\n        <span class=\"hljs-keyword\">return</span> correction_factor;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Update the weights of the model using supervised learning for an\n     * array of vectors.\n     * \\param[in] X array of feature vector\n     * \\param[in] y known output value for each feature vector\n     */</span>\n    <span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-type\">size_t</span> N&gt;\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fit</span><span class=\"hljs-params\">(std::array&lt;std::vector&lt;<span class=\"hljs-type\">double</span>&gt;, N&gt; <span class=\"hljs-keyword\">const</span> &amp;X,\n             std::array&lt;<span class=\"hljs-type\">int</span>, N&gt; <span class=\"hljs-keyword\">const</span> &amp;Y)</span> </span>{\n        <span class=\"hljs-type\">double</span> avg_pred_error = <span class=\"hljs-number\">1.f</span>;\n\n        <span class=\"hljs-type\">int</span> iter = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-keyword\">for</span> (iter = <span class=\"hljs-number\">0</span>; (iter &lt; MAX_ITER) &amp;&amp; (avg_pred_error &gt; accuracy);\n             iter++) {\n            avg_pred_error = <span class=\"hljs-number\">0.f</span>;\n\n            <span class=\"hljs-comment\">// perform fit for each sample</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n                <span class=\"hljs-type\">double</span> err = <span class=\"hljs-built_in\">fit</span>(X[i], Y[i]);\n                avg_pred_error += std::<span class=\"hljs-built_in\">abs</span>(err);\n            }\n            avg_pred_error /= N;\n\n            <span class=\"hljs-comment\">// Print updates every 200th iteration</span>\n            <span class=\"hljs-comment\">// if (iter % 100 == 0)</span>\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\tIter &quot;</span> &lt;&lt; iter &lt;&lt; <span class=\"hljs-string\">&quot;: Training weights: &quot;</span> &lt;&lt; *<span class=\"hljs-keyword\">this</span>\n                      &lt;&lt; <span class=\"hljs-string\">&quot;\\tAvg error: &quot;</span> &lt;&lt; avg_pred_error &lt;&lt; std::endl;\n        }\n\n        <span class=\"hljs-keyword\">if</span> (iter &lt; MAX_ITER) {\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Converged after &quot;</span> &lt;&lt; iter &lt;&lt; <span class=\"hljs-string\">&quot; iterations.&quot;</span>\n                      &lt;&lt; std::endl;\n        } <span class=\"hljs-keyword\">else</span> {\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Did not converge after &quot;</span> &lt;&lt; iter &lt;&lt; <span class=\"hljs-string\">&quot; iterations.&quot;</span>\n                      &lt;&lt; std::endl;\n        }\n    }\n\n    <span class=\"hljs-comment\">/** Defines activation function as Heaviside&#x27;s step function.\n     * \\f[\n     * f(x) = \\begin{cases}\n     * -1 &amp; \\forall x \\le 0\\\\\n     *  1 &amp; \\forall x &gt; 0\n     * \\end{cases}\n     * \\f]\n     * @param x input value to apply activation on\n     * @return activation output\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">activation</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> x)</span> </span>{ <span class=\"hljs-keyword\">return</span> x &gt; <span class=\"hljs-number\">0</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">-1</span>; }\n\n <span class=\"hljs-keyword\">private</span>:\n    <span class=\"hljs-comment\">/**\n     * convenient function to check if input feature vector size matches the\n     * model weights size\n     * \\param[in] x fecture vector to check\n     * \\returns `true` size matches\n     * \\returns `false` size does not match\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">check_size_match</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::vector&lt;<span class=\"hljs-type\">double</span>&gt; &amp;x)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (x.<span class=\"hljs-built_in\">size</span>() != (weights.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>)) {\n            std::cerr &lt;&lt; __func__ &lt;&lt; <span class=\"hljs-string\">&quot;: &quot;</span>\n                      &lt;&lt; <span class=\"hljs-string\">&quot;Number of features in x does not match the feature &quot;</span>\n                         <span class=\"hljs-string\">&quot;dimension in model!&quot;</span>\n                      &lt;&lt; std::endl;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    }\n\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">double</span> eta;             <span class=\"hljs-comment\">///&lt; learning rate of the algorithm</span>\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">double</span> accuracy;        <span class=\"hljs-comment\">///&lt; model fit convergence accuracy</span>\n    std::vector&lt;<span class=\"hljs-type\">double</span>&gt; weights;  <span class=\"hljs-comment\">///&lt; weights of the neural network</span>\n};\n\n}  <span class=\"hljs-comment\">// namespace machine_learning</span>\n\n<span class=\"hljs-keyword\">using</span> machine_learning::adaline;\n\n<span class=\"hljs-comment\">/** @} */</span>\n\n<span class=\"hljs-comment\">/**\n * test function to predict points in a 2D coordinate system above the line\n * \\f$x=y\\f$ as +1 and others as -1.\n * Note that each point is defined by 2 values or 2 features.\n * \\param[in] eta learning rate (optional, default=0.01)\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test1</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> eta = <span class=\"hljs-number\">0.01</span>)</span> </span>{\n    <span class=\"hljs-function\">adaline <span class=\"hljs-title\">ada</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>, eta)</span></span>;  <span class=\"hljs-comment\">// 2 features</span>\n\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> N = <span class=\"hljs-number\">10</span>;  <span class=\"hljs-comment\">// number of sample points</span>\n\n    std::array&lt;std::vector&lt;<span class=\"hljs-type\">double</span>&gt;, N&gt; X = {\n        std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}),   std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-2</span>}),\n        std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}),   std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">-1</span>}),\n        std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>}),   std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">-5</span>}),\n        std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({<span class=\"hljs-number\">-7</span>, <span class=\"hljs-number\">-3</span>}), std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({<span class=\"hljs-number\">-8</span>, <span class=\"hljs-number\">5</span>}),\n        std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({<span class=\"hljs-number\">-9</span>, <span class=\"hljs-number\">2</span>}),  std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({<span class=\"hljs-number\">-10</span>, <span class=\"hljs-number\">-15</span>})};\n    std::array&lt;<span class=\"hljs-type\">int</span>, N&gt; y = {<span class=\"hljs-number\">1</span>,  <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>,\n                            <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>,  <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>,  <span class=\"hljs-number\">-1</span>};  <span class=\"hljs-comment\">// corresponding y-values</span>\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;------- Test 1 -------&quot;</span> &lt;&lt; std::endl;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Model before fit: &quot;</span> &lt;&lt; ada &lt;&lt; std::endl;\n\n    ada.<span class=\"hljs-built_in\">fit</span>&lt;N&gt;(X, y);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Model after fit: &quot;</span> &lt;&lt; ada &lt;&lt; std::endl;\n\n    <span class=\"hljs-type\">int</span> predict = ada.<span class=\"hljs-built_in\">predict</span>({<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">-3</span>});\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Predict for x=(5,-3): &quot;</span> &lt;&lt; predict;\n    <span class=\"hljs-built_in\">assert</span>(predict == <span class=\"hljs-number\">-1</span>);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot; ...passed&quot;</span> &lt;&lt; std::endl;\n\n    predict = ada.<span class=\"hljs-built_in\">predict</span>({<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>});\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Predict for x=(5,8): &quot;</span> &lt;&lt; predict;\n    <span class=\"hljs-built_in\">assert</span>(predict == <span class=\"hljs-number\">1</span>);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot; ...passed&quot;</span> &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-comment\">/**\n * test function to predict points in a 2D coordinate system above the line\n * \\f$x+3y=-1\\f$ as +1 and others as -1.\n * Note that each point is defined by 2 values or 2 features.\n * The function will create random sample points for training and test purposes.\n * \\param[in] eta learning rate (optional, default=0.01)\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> eta = <span class=\"hljs-number\">0.01</span>)</span> </span>{\n    <span class=\"hljs-function\">adaline <span class=\"hljs-title\">ada</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>, eta)</span></span>;  <span class=\"hljs-comment\">// 2 features</span>\n\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> N = <span class=\"hljs-number\">50</span>;  <span class=\"hljs-comment\">// number of sample points</span>\n\n    std::array&lt;std::vector&lt;<span class=\"hljs-type\">double</span>&gt;, N&gt; X;\n    std::array&lt;<span class=\"hljs-type\">int</span>, N&gt; Y{};  <span class=\"hljs-comment\">// corresponding y-values</span>\n\n    <span class=\"hljs-comment\">// generate sample points in the interval</span>\n    <span class=\"hljs-comment\">// [-range2/100 , (range2-1)/100]</span>\n    <span class=\"hljs-type\">int</span> range = <span class=\"hljs-number\">500</span>;          <span class=\"hljs-comment\">// sample points full-range</span>\n    <span class=\"hljs-type\">int</span> range2 = range &gt;&gt; <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">// sample points half-range</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n        <span class=\"hljs-type\">double</span> x0 = (<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\n        <span class=\"hljs-type\">double</span> x1 = (<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\n        X[i] = std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({x0, x1});\n        Y[i] = (x0 + <span class=\"hljs-number\">3.</span> * x1) &gt; <span class=\"hljs-number\">-1</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">-1</span>;\n    }\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;------- Test 2 -------&quot;</span> &lt;&lt; std::endl;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Model before fit: &quot;</span> &lt;&lt; ada &lt;&lt; std::endl;\n\n    ada.<span class=\"hljs-built_in\">fit</span>(X, Y);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Model after fit: &quot;</span> &lt;&lt; ada &lt;&lt; std::endl;\n\n    <span class=\"hljs-type\">int</span> N_test_cases = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N_test_cases; i++) {\n        <span class=\"hljs-type\">double</span> x0 = (<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\n        <span class=\"hljs-type\">double</span> x1 = (<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\n\n        <span class=\"hljs-type\">int</span> predict = ada.<span class=\"hljs-built_in\">predict</span>({x0, x1});\n\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Predict for x=(&quot;</span> &lt;&lt; x0 &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span> &lt;&lt; x1 &lt;&lt; <span class=\"hljs-string\">&quot;): &quot;</span> &lt;&lt; predict;\n\n        <span class=\"hljs-type\">int</span> expected_val = (x0 + <span class=\"hljs-number\">3.</span> * x1) &gt; <span class=\"hljs-number\">-1</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">-1</span>;\n        <span class=\"hljs-built_in\">assert</span>(predict == expected_val);\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot; ...passed&quot;</span> &lt;&lt; std::endl;\n    }\n}\n\n<span class=\"hljs-comment\">/**\n * test function to predict points in a 3D coordinate system lying within the\n * sphere of radius 1 and centre at origin as +1 and others as -1. Note that\n * each point is defined by 3 values but we use 6 features. The function will\n * create random sample points for training and test purposes.\n * The sphere centred at origin and radius 1 is defined as:\n * \\f$x^2+y^2+z^2=r^2=1\\f$ and if the \\f$r^2&lt;1\\f$, point lies within the sphere\n * else, outside.\n *\n * \\param[in] eta learning rate (optional, default=0.01)\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test3</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> eta = <span class=\"hljs-number\">0.01</span>)</span> </span>{\n    <span class=\"hljs-function\">adaline <span class=\"hljs-title\">ada</span><span class=\"hljs-params\">(<span class=\"hljs-number\">6</span>, eta)</span></span>;  <span class=\"hljs-comment\">// 2 features</span>\n\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> N = <span class=\"hljs-number\">100</span>;  <span class=\"hljs-comment\">// number of sample points</span>\n\n    std::array&lt;std::vector&lt;<span class=\"hljs-type\">double</span>&gt;, N&gt; X;\n    std::array&lt;<span class=\"hljs-type\">int</span>, N&gt; Y{};  <span class=\"hljs-comment\">// corresponding y-values</span>\n\n    <span class=\"hljs-comment\">// generate sample points in the interval</span>\n    <span class=\"hljs-comment\">// [-range2/100 , (range2-1)/100]</span>\n    <span class=\"hljs-type\">int</span> range = <span class=\"hljs-number\">200</span>;          <span class=\"hljs-comment\">// sample points full-range</span>\n    <span class=\"hljs-type\">int</span> range2 = range &gt;&gt; <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">// sample points half-range</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n        <span class=\"hljs-type\">double</span> x0 = (<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\n        <span class=\"hljs-type\">double</span> x1 = (<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\n        <span class=\"hljs-type\">double</span> x2 = (<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\n        X[i] = std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">double</span>&gt;({x0, x1, x2, x0 * x0, x1 * x1, x2 * x2});\n        Y[i] = ((x0 * x0) + (x1 * x1) + (x2 * x2)) &lt;= <span class=\"hljs-number\">1.f</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">-1</span>;\n    }\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;------- Test 3 -------&quot;</span> &lt;&lt; std::endl;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Model before fit: &quot;</span> &lt;&lt; ada &lt;&lt; std::endl;\n\n    ada.<span class=\"hljs-built_in\">fit</span>(X, Y);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Model after fit: &quot;</span> &lt;&lt; ada &lt;&lt; std::endl;\n\n    <span class=\"hljs-type\">int</span> N_test_cases = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N_test_cases; i++) {\n        <span class=\"hljs-type\">double</span> x0 = (<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\n        <span class=\"hljs-type\">double</span> x1 = (<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\n        <span class=\"hljs-type\">double</span> x2 = (<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\n\n        <span class=\"hljs-type\">int</span> predict = ada.<span class=\"hljs-built_in\">predict</span>({x0, x1, x2, x0 * x0, x1 * x1, x2 * x2});\n\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Predict for x=(&quot;</span> &lt;&lt; x0 &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span> &lt;&lt; x1 &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span> &lt;&lt; x2\n                  &lt;&lt; <span class=\"hljs-string\">&quot;): &quot;</span> &lt;&lt; predict;\n\n        <span class=\"hljs-type\">int</span> expected_val = ((x0 * x0) + (x1 * x1) + (x2 * x2)) &lt;= <span class=\"hljs-number\">1.f</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">-1</span>;\n        <span class=\"hljs-built_in\">assert</span>(predict == expected_val);\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot; ...passed&quot;</span> &lt;&lt; std::endl;\n    }\n}\n\n<span class=\"hljs-comment\">/** Main function */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span> </span>{\n    std::<span class=\"hljs-built_in\">srand</span>(std::<span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">nullptr</span>));  <span class=\"hljs-comment\">// initialize random number generator</span>\n\n    <span class=\"hljs-type\">double</span> eta = <span class=\"hljs-number\">0.1</span>;  <span class=\"hljs-comment\">// default value of eta</span>\n    <span class=\"hljs-keyword\">if</span> (argc == <span class=\"hljs-number\">2</span>) {   <span class=\"hljs-comment\">// read eta value from commandline argument if present</span>\n        eta = <span class=\"hljs-built_in\">strtof</span>(argv[<span class=\"hljs-number\">1</span>], <span class=\"hljs-literal\">nullptr</span>);\n    }\n\n    <span class=\"hljs-built_in\">test1</span>(eta);\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Press ENTER to continue...&quot;</span> &lt;&lt; std::endl;\n    std::cin.<span class=\"hljs-built_in\">get</span>();\n\n    <span class=\"hljs-built_in\">test2</span>(eta);\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Press ENTER to continue...&quot;</span> &lt;&lt; std::endl;\n    std::cin.<span class=\"hljs-built_in\">get</span>();\n\n    <span class=\"hljs-built_in\">test3</span>(eta);\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "c": {
      "dir": "machine_learning/adaline_learning.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/machine_learning/adaline_learning.c",
      "code": "<span class=\"hljs-comment\">/**\n * \\file\n * \\brief [Adaptive Linear Neuron\n * (ADALINE)](https://en.wikipedia.org/wiki/ADALINE) implementation\n * \\details\n * &lt;img\n * src=&quot;https://upload.wikimedia.org/wikipedia/commons/b/be/Adaline_flow_chart.gif&quot;\n * width=&quot;200px&quot;&gt;\n * [source](https://commons.wikimedia.org/wiki/File:Adaline_flow_chart.gif)\n * ADALINE is one of the first and simplest single layer artificial neural\n * network. The algorithm essentially implements a linear function\n * \\f[ f\\left(x_0,x_1,x_2,\\ldots\\right) =\n * \\sum_j x_jw_j+\\theta\n * \\f]\n * where \\f$x_j\\f$ are the input features of a sample, \\f$w_j\\f$ are the\n * coefficients of the linear function and \\f$\\theta\\f$ is a constant. If we\n * know the \\f$w_j\\f$, then for any given set of features, \\f$y\\f$ can be\n * computed. Computing the \\f$w_j\\f$ is a supervised learning algorithm wherein\n * a set of features and their corresponding outputs are given and weights are\n * computed using stochastic gradient descent method.\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;limits.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;math.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdbool.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;time.h&gt;</span></span>\n\n<span class=\"hljs-comment\">/**\n * @addtogroup machine_learning Machine learning algorithms\n * @{\n * @addtogroup adaline Adaline learning algorithm\n * @{\n */</span>\n\n<span class=\"hljs-comment\">/** Maximum number of iterations to learn */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> MAX_ADALINE_ITER 500  <span class=\"hljs-comment\">// INT_MAX</span></span>\n\n<span class=\"hljs-comment\">/** structure to hold adaline model parameters */</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">adaline</span>\n{</span>\n    <span class=\"hljs-type\">double</span> eta;      <span class=\"hljs-comment\">/**&lt; learning rate of the algorithm */</span>\n    <span class=\"hljs-type\">double</span> *weights; <span class=\"hljs-comment\">/**&lt; weights of the neural network */</span>\n    <span class=\"hljs-type\">int</span> num_weights; <span class=\"hljs-comment\">/**&lt; number of weights of the neural network */</span>\n};\n\n<span class=\"hljs-comment\">/** convergence accuracy \\f$=1\\times10^{-5}\\f$ */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ADALINE_ACCURACY 1e-5</span>\n\n<span class=\"hljs-comment\">/**\n * Default constructor\n * \\param[in] num_features number of features present\n * \\param[in] eta learning rate (optional, default=0.1)\n * \\returns new adaline model\n */</span>\n<span class=\"hljs-keyword\">struct</span> adaline <span class=\"hljs-title function_\">new_adaline</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> num_features, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">double</span> eta)</span>\n{\n    <span class=\"hljs-keyword\">if</span> (eta &lt;= <span class=\"hljs-number\">0.f</span> || eta &gt;= <span class=\"hljs-number\">1.f</span>)\n    {\n        <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;learning rate should be &gt; 0 and &lt; 1\\n&quot;</span>);\n        <span class=\"hljs-built_in\">exit</span>(EXIT_FAILURE);\n    }\n\n    <span class=\"hljs-comment\">// additional weight is for the constant bias term</span>\n    <span class=\"hljs-type\">int</span> num_weights = num_features + <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">adaline</span> <span class=\"hljs-title\">ada</span>;</span>\n    ada.eta = eta;\n    ada.num_weights = num_weights;\n    ada.weights = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(num_weights * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\n    <span class=\"hljs-keyword\">if</span> (!ada.weights)\n    {\n        perror(<span class=\"hljs-string\">&quot;Unable to allocate error for weights!&quot;</span>);\n        <span class=\"hljs-keyword\">return</span> ada;\n    }\n\n    <span class=\"hljs-comment\">// initialize with random weights in the range [-50, 49]</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; num_weights; i++) ada.weights[i] = <span class=\"hljs-number\">1.f</span>;\n    <span class=\"hljs-comment\">// ada.weights[i] = (double)(rand() % 100) - 50);</span>\n\n    <span class=\"hljs-keyword\">return</span> ada;\n}\n\n<span class=\"hljs-comment\">/** delete dynamically allocated memory\n * \\param[in] ada model from which the memory is to be freed.\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">delete_adaline</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> adaline *ada)</span>\n{\n    <span class=\"hljs-keyword\">if</span> (ada == <span class=\"hljs-literal\">NULL</span>)\n        <span class=\"hljs-keyword\">return</span>;\n\n    <span class=\"hljs-built_in\">free</span>(ada-&gt;weights);\n};\n\n<span class=\"hljs-comment\">/** [Heaviside activation\n * function](https://en.wikipedia.org/wiki/Heaviside_step_function) &lt;img\n * src=&quot;https://upload.wikimedia.org/wikipedia/commons/d/d9/Dirac_distribution_CDF.svg&quot;\n * width=&quot;200px&quot;/&gt;\n * @param x activation function input\n * @returns \\f$f(x)= \\begin{cases}1 &amp; \\forall\\; x &gt; 0\\\\ -1 &amp; \\forall\\; x \\le0\n * \\end{cases}\\f$\n */</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">adaline_activation</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> x)</span> { <span class=\"hljs-keyword\">return</span> x &gt; <span class=\"hljs-number\">0</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">-1</span>; }\n\n<span class=\"hljs-comment\">/**\n * Operator to print the weights of the model\n * @param ada model for which the values to print\n * @returns pointer to a NULL terminated string of formatted weights\n */</span>\n<span class=\"hljs-type\">char</span> *<span class=\"hljs-title function_\">adaline_get_weights_str</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">struct</span> adaline *ada)</span>\n{\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">char</span> out[<span class=\"hljs-number\">100</span>];  <span class=\"hljs-comment\">// static so the value is persistent</span>\n\n    <span class=\"hljs-built_in\">sprintf</span>(out, <span class=\"hljs-string\">&quot;&lt;&quot;</span>);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; ada-&gt;num_weights; i++)\n    {\n        <span class=\"hljs-built_in\">sprintf</span>(out, <span class=\"hljs-string\">&quot;%s%.4g&quot;</span>, out, ada-&gt;weights[i]);\n        <span class=\"hljs-keyword\">if</span> (i &lt; ada-&gt;num_weights - <span class=\"hljs-number\">1</span>)\n            <span class=\"hljs-built_in\">sprintf</span>(out, <span class=\"hljs-string\">&quot;%s, &quot;</span>, out);\n    }\n    <span class=\"hljs-built_in\">sprintf</span>(out, <span class=\"hljs-string\">&quot;%s&gt;&quot;</span>, out);\n    <span class=\"hljs-keyword\">return</span> out;\n}\n\n<span class=\"hljs-comment\">/**\n * predict the output of the model for given set of features\n *\n * \\param[in] ada adaline model to predict\n * \\param[in] x input vector\n * \\param[out] out optional argument to return neuron output before applying\n * activation function (`NULL` to ignore)\n * \\returns model prediction output\n */</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">adaline_predict</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> adaline *ada, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">double</span> *x, <span class=\"hljs-type\">double</span> *out)</span>\n{\n    <span class=\"hljs-type\">double</span> y = ada-&gt;weights[ada-&gt;num_weights - <span class=\"hljs-number\">1</span>];  <span class=\"hljs-comment\">// assign bias value</span>\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; ada-&gt;num_weights - <span class=\"hljs-number\">1</span>; i++) y += x[i] * ada-&gt;weights[i];\n\n    <span class=\"hljs-keyword\">if</span> (out)  <span class=\"hljs-comment\">// if out variable is not NULL</span>\n        *out = y;\n\n    <span class=\"hljs-comment\">// quantizer: apply ADALINE threshold function</span>\n    <span class=\"hljs-keyword\">return</span> adaline_activation(y);\n}\n\n<span class=\"hljs-comment\">/**\n * Update the weights of the model using supervised learning for one feature\n * vector\n *\n * \\param[in] ada adaline model to fit\n * \\param[in] x feature vector\n * \\param[in] y known output  value\n * \\returns correction factor\n */</span>\n<span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">adaline_fit_sample</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> adaline *ada, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">double</span> *x, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> y)</span>\n{\n    <span class=\"hljs-comment\">/* output of the model with current weights */</span>\n    <span class=\"hljs-type\">int</span> p = adaline_predict(ada, x, <span class=\"hljs-literal\">NULL</span>);\n    <span class=\"hljs-type\">int</span> prediction_error = y - p;  <span class=\"hljs-comment\">// error in estimation</span>\n    <span class=\"hljs-type\">double</span> correction_factor = ada-&gt;eta * prediction_error;\n\n    <span class=\"hljs-comment\">/* update each weight, the last weight is the bias term */</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; ada-&gt;num_weights - <span class=\"hljs-number\">1</span>; i++)\n    {\n        ada-&gt;weights[i] += correction_factor * x[i];\n    }\n    ada-&gt;weights[ada-&gt;num_weights - <span class=\"hljs-number\">1</span>] += correction_factor;  <span class=\"hljs-comment\">// update bias</span>\n\n    <span class=\"hljs-keyword\">return</span> correction_factor;\n}\n\n<span class=\"hljs-comment\">/**\n * Update the weights of the model using supervised learning for an array of\n * vectors.\n *\n * \\param[in] ada adaline model to train\n * \\param[in] X array of feature vector\n * \\param[in] y known output value for each feature vector\n * \\param[in] N number of training samples\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">adaline_fit</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> adaline *ada, <span class=\"hljs-type\">double</span> **X, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> *y, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> N)</span>\n{\n    <span class=\"hljs-type\">double</span> avg_pred_error = <span class=\"hljs-number\">1.f</span>;\n\n    <span class=\"hljs-type\">int</span> iter;\n    <span class=\"hljs-keyword\">for</span> (iter = <span class=\"hljs-number\">0</span>;\n         (iter &lt; MAX_ADALINE_ITER) &amp;&amp; (avg_pred_error &gt; ADALINE_ACCURACY);\n         iter++)\n    {\n        avg_pred_error = <span class=\"hljs-number\">0.f</span>;\n\n        <span class=\"hljs-comment\">// perform fit for each sample</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\n        {\n            <span class=\"hljs-type\">double</span> err = adaline_fit_sample(ada, X[i], y[i]);\n            avg_pred_error += <span class=\"hljs-built_in\">fabs</span>(err);\n        }\n        avg_pred_error /= N;\n\n        <span class=\"hljs-comment\">// Print updates every 200th iteration</span>\n        <span class=\"hljs-comment\">// if (iter % 100 == 0)</span>\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\tIter %3d: Training weights: %s\\tAvg error: %.4f\\n&quot;</span>, iter,\n               adaline_get_weights_str(ada), avg_pred_error);\n    }\n\n    <span class=\"hljs-keyword\">if</span> (iter &lt; MAX_ADALINE_ITER)\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Converged after %d iterations.\\n&quot;</span>, iter);\n    <span class=\"hljs-keyword\">else</span>\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Did not converged after %d iterations.\\n&quot;</span>, iter);\n}\n\n<span class=\"hljs-comment\">/** @}\n *  @}\n */</span>\n\n<span class=\"hljs-comment\">/**\n * test function to predict points in a 2D coordinate system above the line\n * \\f$x=y\\f$ as +1 and others as -1.\n * Note that each point is defined by 2 values or 2 features.\n * \\param[in] eta learning rate (optional, default=0.01)\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test1</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> eta)</span>\n{\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">adaline</span> <span class=\"hljs-title\">ada</span> =</span> new_adaline(<span class=\"hljs-number\">2</span>, eta);  <span class=\"hljs-comment\">// 2 features</span>\n\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> N = <span class=\"hljs-number\">10</span>;  <span class=\"hljs-comment\">// number of sample points</span>\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">double</span> saved_X[<span class=\"hljs-number\">10</span>][<span class=\"hljs-number\">2</span>] = {{<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>},  {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-2</span>},   {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>},   {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">-1</span>},\n                                   {<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>},  {<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">-5</span>},   {<span class=\"hljs-number\">-7</span>, <span class=\"hljs-number\">-3</span>}, {<span class=\"hljs-number\">-8</span>, <span class=\"hljs-number\">5</span>},\n                                   {<span class=\"hljs-number\">-9</span>, <span class=\"hljs-number\">2</span>}, {<span class=\"hljs-number\">-10</span>, <span class=\"hljs-number\">-15</span>}};\n\n    <span class=\"hljs-type\">double</span> **X = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> Y[<span class=\"hljs-number\">10</span>] = {<span class=\"hljs-number\">1</span>,  <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>,\n                       <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>,  <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>,  <span class=\"hljs-number\">-1</span>};  <span class=\"hljs-comment\">// corresponding y-values</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\n    {\n        X[i] = (<span class=\"hljs-type\">double</span> *)saved_X[i];\n    }\n\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;------- Test 1 -------\\n&quot;</span>);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Model before fit: %s&quot;</span>, adaline_get_weights_str(&amp;ada));\n\n    adaline_fit(&amp;ada, X, Y, N);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Model after fit: %s\\n&quot;</span>, adaline_get_weights_str(&amp;ada));\n\n    <span class=\"hljs-type\">double</span> test_x[] = {<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">-3</span>};\n    <span class=\"hljs-type\">int</span> pred = adaline_predict(&amp;ada, test_x, <span class=\"hljs-literal\">NULL</span>);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Predict for x=(5,-3): % d&quot;</span>, pred);\n    assert(pred == <span class=\"hljs-number\">-1</span>);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot; ...passed\\n&quot;</span>);\n\n    <span class=\"hljs-type\">double</span> test_x2[] = {<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>};\n    pred = adaline_predict(&amp;ada, test_x2, <span class=\"hljs-literal\">NULL</span>);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Predict for x=(5, 8): % d&quot;</span>, pred);\n    assert(pred == <span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot; ...passed\\n&quot;</span>);\n\n    <span class=\"hljs-comment\">// for (int i = 0; i &lt; N; i++)</span>\n    <span class=\"hljs-comment\">//     free(X[i]);</span>\n    <span class=\"hljs-built_in\">free</span>(X);\n    delete_adaline(&amp;ada);\n}\n\n<span class=\"hljs-comment\">/**\n * test function to predict points in a 2D coordinate system above the line\n * \\f$x+3y=-1\\f$ as +1 and others as -1.\n * Note that each point is defined by 2 values or 2 features.\n * The function will create random sample points for training and test purposes.\n * \\param[in] eta learning rate (optional, default=0.01)\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> eta)</span>\n{\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">adaline</span> <span class=\"hljs-title\">ada</span> =</span> new_adaline(<span class=\"hljs-number\">2</span>, eta);  <span class=\"hljs-comment\">// 2 features</span>\n\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> N = <span class=\"hljs-number\">50</span>;  <span class=\"hljs-comment\">// number of sample points</span>\n\n    <span class=\"hljs-type\">double</span> **X = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\n    <span class=\"hljs-type\">int</span> *Y = (<span class=\"hljs-type\">int</span> *)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">int</span>));  <span class=\"hljs-comment\">// corresponding y-values</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) X[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">2</span> * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\n\n    <span class=\"hljs-comment\">// generate sample points in the interval</span>\n    <span class=\"hljs-comment\">// [-range2/100 , (range2-1)/100]</span>\n    <span class=\"hljs-type\">int</span> range = <span class=\"hljs-number\">500</span>;          <span class=\"hljs-comment\">// sample points full-range</span>\n    <span class=\"hljs-type\">int</span> range2 = range &gt;&gt; <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">// sample points half-range</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\n    {\n        <span class=\"hljs-type\">double</span> x0 = ((rand() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\n        <span class=\"hljs-type\">double</span> x1 = ((rand() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\n        X[i][<span class=\"hljs-number\">0</span>] = x0;\n        X[i][<span class=\"hljs-number\">1</span>] = x1;\n        Y[i] = (x0 + <span class=\"hljs-number\">3.</span> * x1) &gt; <span class=\"hljs-number\">-1</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">-1</span>;\n    }\n\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;------- Test 2 -------\\n&quot;</span>);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Model before fit: %s&quot;</span>, adaline_get_weights_str(&amp;ada));\n\n    adaline_fit(&amp;ada, X, Y, N);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Model after fit: %s\\n&quot;</span>, adaline_get_weights_str(&amp;ada));\n\n    <span class=\"hljs-type\">int</span> N_test_cases = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-type\">double</span> test_x[<span class=\"hljs-number\">2</span>];\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N_test_cases; i++)\n    {\n        <span class=\"hljs-type\">double</span> x0 = ((rand() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\n        <span class=\"hljs-type\">double</span> x1 = ((rand() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\n\n        test_x[<span class=\"hljs-number\">0</span>] = x0;\n        test_x[<span class=\"hljs-number\">1</span>] = x1;\n        <span class=\"hljs-type\">int</span> pred = adaline_predict(&amp;ada, test_x, <span class=\"hljs-literal\">NULL</span>);\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Predict for x=(% 3.2f,% 3.2f): % d&quot;</span>, x0, x1, pred);\n\n        <span class=\"hljs-type\">int</span> expected_val = (x0 + <span class=\"hljs-number\">3.</span> * x1) &gt; <span class=\"hljs-number\">-1</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">-1</span>;\n        assert(pred == expected_val);\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot; ...passed\\n&quot;</span>);\n    }\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) <span class=\"hljs-built_in\">free</span>(X[i]);\n    <span class=\"hljs-built_in\">free</span>(X);\n    <span class=\"hljs-built_in\">free</span>(Y);\n    delete_adaline(&amp;ada);\n}\n\n<span class=\"hljs-comment\">/**\n * test function to predict points in a 3D coordinate system lying within the\n * sphere of radius 1 and centre at origin as +1 and others as -1. Note that\n * each point is defined by 3 values but we use 6 features. The function will\n * create random sample points for training and test purposes.\n * The sphere centred at origin and radius 1 is defined as:\n * \\f$x^2+y^2+z^2=r^2=1\\f$ and if the \\f$r^2&lt;1\\f$, point lies within the sphere\n * else, outside.\n *\n * \\param[in] eta learning rate (optional, default=0.01)\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test3</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> eta)</span>\n{\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">adaline</span> <span class=\"hljs-title\">ada</span> =</span> new_adaline(<span class=\"hljs-number\">6</span>, eta);  <span class=\"hljs-comment\">// 2 features</span>\n\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> N = <span class=\"hljs-number\">50</span>;  <span class=\"hljs-comment\">// number of sample points</span>\n\n    <span class=\"hljs-type\">double</span> **X = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\n    <span class=\"hljs-type\">int</span> *Y = (<span class=\"hljs-type\">int</span> *)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">int</span>));  <span class=\"hljs-comment\">// corresponding y-values</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) X[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">6</span> * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\n\n    <span class=\"hljs-comment\">// generate sample points in the interval</span>\n    <span class=\"hljs-comment\">// [-range2/100 , (range2-1)/100]</span>\n    <span class=\"hljs-type\">int</span> range = <span class=\"hljs-number\">200</span>;          <span class=\"hljs-comment\">// sample points full-range</span>\n    <span class=\"hljs-type\">int</span> range2 = range &gt;&gt; <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">// sample points half-range</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\n    {\n        <span class=\"hljs-type\">double</span> x0 = ((rand() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\n        <span class=\"hljs-type\">double</span> x1 = ((rand() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\n        <span class=\"hljs-type\">double</span> x2 = ((rand() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\n        X[i][<span class=\"hljs-number\">0</span>] = x0;\n        X[i][<span class=\"hljs-number\">1</span>] = x1;\n        X[i][<span class=\"hljs-number\">2</span>] = x2;\n        X[i][<span class=\"hljs-number\">3</span>] = x0 * x0;\n        X[i][<span class=\"hljs-number\">4</span>] = x1 * x1;\n        X[i][<span class=\"hljs-number\">5</span>] = x2 * x2;\n        Y[i] = (x0 * x0 + x1 * x1 + x2 * x2) &lt;= <span class=\"hljs-number\">1</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">-1</span>;\n    }\n\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;------- Test 3 -------\\n&quot;</span>);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Model before fit: %s&quot;</span>, adaline_get_weights_str(&amp;ada));\n\n    adaline_fit(&amp;ada, X, Y, N);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Model after fit: %s\\n&quot;</span>, adaline_get_weights_str(&amp;ada));\n\n    <span class=\"hljs-type\">int</span> N_test_cases = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-type\">double</span> test_x[<span class=\"hljs-number\">6</span>];\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N_test_cases; i++)\n    {\n        <span class=\"hljs-type\">double</span> x0 = ((rand() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\n        <span class=\"hljs-type\">double</span> x1 = ((rand() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\n        <span class=\"hljs-type\">double</span> x2 = ((rand() % range) - range2) / <span class=\"hljs-number\">100.f</span>;\n        test_x[<span class=\"hljs-number\">0</span>] = x0;\n        test_x[<span class=\"hljs-number\">1</span>] = x1;\n        test_x[<span class=\"hljs-number\">2</span>] = x2;\n        test_x[<span class=\"hljs-number\">3</span>] = x0 * x0;\n        test_x[<span class=\"hljs-number\">4</span>] = x1 * x1;\n        test_x[<span class=\"hljs-number\">5</span>] = x2 * x2;\n        <span class=\"hljs-type\">int</span> pred = adaline_predict(&amp;ada, test_x, <span class=\"hljs-literal\">NULL</span>);\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Predict for x=(% 3.2f,% 3.2f): % d&quot;</span>, x0, x1, pred);\n\n        <span class=\"hljs-type\">int</span> expected_val = (x0 * x0 + x1 * x1 + x2 * x2) &lt;= <span class=\"hljs-number\">1</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">-1</span>;\n        assert(pred == expected_val);\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot; ...passed\\n&quot;</span>);\n    }\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) <span class=\"hljs-built_in\">free</span>(X[i]);\n    <span class=\"hljs-built_in\">free</span>(X);\n    <span class=\"hljs-built_in\">free</span>(Y);\n    delete_adaline(&amp;ada);\n}\n\n<span class=\"hljs-comment\">/** Main function */</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span>\n{\n    srand(time(<span class=\"hljs-literal\">NULL</span>));  <span class=\"hljs-comment\">// initialize random number generator</span>\n\n    <span class=\"hljs-type\">double</span> eta = <span class=\"hljs-number\">0.1</span>;  <span class=\"hljs-comment\">// default value of eta</span>\n    <span class=\"hljs-keyword\">if</span> (argc == <span class=\"hljs-number\">2</span>)     <span class=\"hljs-comment\">// read eta value from commandline argument if present</span>\n        eta = strtof(argv[<span class=\"hljs-number\">1</span>], <span class=\"hljs-literal\">NULL</span>);\n\n    test1(eta);\n\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Press ENTER to continue...\\n&quot;</span>);\n    getchar();\n\n    test2(eta);\n\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Press ENTER to continue...\\n&quot;</span>);\n    getchar();\n\n    test3(eta);\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 11
    }
  ],
  "explanationUrl": {}
}
