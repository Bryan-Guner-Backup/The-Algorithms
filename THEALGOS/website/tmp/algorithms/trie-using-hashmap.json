{
  "slug": "trie-using-hashmap",
  "name": "Trie Using Hashmap",
  "categories": ["datastructures"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "data_structures/trie_using_hashmap.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/data_structures/trie_using_hashmap.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * @author [Venkata Bharath](https://github.com/bharath000)\n * @brief Implementation of [Trie](https://en.wikipedia.org/wiki/Trie) data\n * structure using HashMap for different characters and method for predicting\n * words based on prefix.\n * @details The Trie data structure is implemented using unordered map to use\n * memory optimally, predict_words method is developed to recommend words based\n * on a given prefix along with other methods insert, delete, search, startwith\n * in trie.\n * @see trie_modern.cpp for difference\n */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>        <span class=\"hljs-comment\">/// for assert</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>       <span class=\"hljs-comment\">/// for IO operations</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;memory&gt;</span>         <span class=\"hljs-comment\">/// for std::shared_ptr</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span>          <span class=\"hljs-comment\">/// for std::stack</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_map&gt;</span>  <span class=\"hljs-comment\">/// for std::unordered_map</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>         <span class=\"hljs-comment\">/// for std::vector</span></span>\n\n<span class=\"hljs-comment\">/**\n * @namespace data_structures\n * @brief Data structures algorithms\n */</span>\n<span class=\"hljs-keyword\">namespace</span> data_structures {\n\n<span class=\"hljs-comment\">/**\n * @namespace trie_using_hashmap\n * @brief Functions for [Trie](https://en.wikipedia.org/wiki/Trie) data\n * structure using hashmap implementation\n */</span>\n<span class=\"hljs-keyword\">namespace</span> trie_using_hashmap {\n\n<span class=\"hljs-comment\">/**\n * @brief Trie class, implementation of trie using hashmap in each trie node\n * for all the characters of char16_t(UTF-16)type with methods to insert,\n * delete, search, start with and to recommend words based on a given\n * prefix.\n */</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Trie</span> {\n <span class=\"hljs-keyword\">private</span>:\n    <span class=\"hljs-comment\">/**\n     * @brief struct representing a trie node.\n     */</span>\n    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> {\n        std::unordered_map&lt;<span class=\"hljs-type\">char16_t</span>, std::shared_ptr&lt;Node&gt;&gt;\n            children;  <span class=\"hljs-comment\">///&lt; unordered map with key type char16_t and value is a</span>\n                       <span class=\"hljs-comment\">///&lt; shared pointer type of Node</span>\n        <span class=\"hljs-type\">bool</span> word_end = <span class=\"hljs-literal\">false</span>;  <span class=\"hljs-comment\">///&lt; boolean variable to represent the node end</span>\n    };\n\n    std::shared_ptr&lt;Node&gt; root_node =\n        std::<span class=\"hljs-built_in\">make_shared</span>&lt;Node&gt;();  <span class=\"hljs-comment\">///&lt; declaring root node of trie</span>\n\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-comment\">///&lt; Constructor</span>\n    <span class=\"hljs-built_in\">Trie</span>() = <span class=\"hljs-keyword\">default</span>;\n\n    <span class=\"hljs-comment\">/**\n     * @brief insert the string into the trie\n     * @param word string to insert in the trie\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string&amp; word)</span> </span>{\n        std::shared_ptr&lt;Node&gt; curr = root_node;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">char</span> ch : word) {\n            <span class=\"hljs-keyword\">if</span> (curr-&gt;children.<span class=\"hljs-built_in\">find</span>(ch) == curr-&gt;children.<span class=\"hljs-built_in\">end</span>()) {\n                curr-&gt;children[ch] = std::<span class=\"hljs-built_in\">make_shared</span>&lt;Node&gt;();\n            }\n            curr = curr-&gt;children[ch];\n        }\n\n        <span class=\"hljs-keyword\">if</span> (!curr-&gt;word_end &amp;&amp; curr != root_node) {\n            curr-&gt;word_end = <span class=\"hljs-literal\">true</span>;\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief search a word/string inside the trie\n     * @param word string to search for\n     * @returns `true` if found\n     * @returns `false` if not found\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">search</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string&amp; word)</span> </span>{\n        std::shared_ptr&lt;Node&gt; curr = root_node;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">char</span> ch : word) {\n            <span class=\"hljs-keyword\">if</span> (curr-&gt;children.<span class=\"hljs-built_in\">find</span>(ch) == curr-&gt;children.<span class=\"hljs-built_in\">end</span>()) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n            }\n            curr = curr-&gt;children[ch];\n            <span class=\"hljs-keyword\">if</span> (!curr) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n            }\n        }\n\n        <span class=\"hljs-keyword\">if</span> (curr-&gt;word_end) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief search a word/string that starts with a given prefix\n     * @param prefix string to search for\n     * @returns `true` if found\n     * @returns `false` if not found\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">startwith</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string&amp; prefix)</span> </span>{\n        std::shared_ptr&lt;Node&gt; curr = root_node;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">char</span> ch : prefix) {\n            <span class=\"hljs-keyword\">if</span> (curr-&gt;children.<span class=\"hljs-built_in\">find</span>(ch) == curr-&gt;children.<span class=\"hljs-built_in\">end</span>()) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n            }\n            curr = curr-&gt;children[ch];\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief delete a word/string from a trie\n     * @param word string to delete from trie\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">delete_word</span><span class=\"hljs-params\">(std::string word)</span> </span>{\n        std::shared_ptr&lt;Node&gt; curr = root_node;\n        std::stack&lt;std::shared_ptr&lt;Node&gt;&gt; nodes;\n        <span class=\"hljs-type\">int</span> cnt = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">char</span> ch : word) {\n            <span class=\"hljs-keyword\">if</span> (curr-&gt;children.<span class=\"hljs-built_in\">find</span>(ch) == curr-&gt;children.<span class=\"hljs-built_in\">end</span>()) {\n                <span class=\"hljs-keyword\">return</span>;\n            }\n            <span class=\"hljs-keyword\">if</span> (curr-&gt;word_end) {\n                cnt++;\n            }\n\n            nodes.<span class=\"hljs-built_in\">push</span>(curr-&gt;children[ch]);\n            curr = curr-&gt;children[ch];\n        }\n        <span class=\"hljs-comment\">// Delete only when it&#x27;s a word, and it has children after</span>\n        <span class=\"hljs-comment\">// or prefix in the line</span>\n        <span class=\"hljs-keyword\">if</span> (nodes.<span class=\"hljs-built_in\">top</span>()-&gt;word_end) {\n            nodes.<span class=\"hljs-built_in\">top</span>()-&gt;word_end = <span class=\"hljs-literal\">false</span>;\n        }\n        <span class=\"hljs-comment\">// Delete only when it has no children after</span>\n        <span class=\"hljs-comment\">// and also no prefix in the line</span>\n        <span class=\"hljs-keyword\">while</span> (!(nodes.<span class=\"hljs-built_in\">top</span>()-&gt;word_end) &amp;&amp; nodes.<span class=\"hljs-built_in\">top</span>()-&gt;children.<span class=\"hljs-built_in\">empty</span>()) {\n            nodes.<span class=\"hljs-built_in\">pop</span>();\n            nodes.<span class=\"hljs-built_in\">top</span>()-&gt;children.<span class=\"hljs-built_in\">erase</span>(word.<span class=\"hljs-built_in\">back</span>());\n            word.<span class=\"hljs-built_in\">pop_back</span>();\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief helper function to predict/recommend words that starts with a\n     * given prefix from the end of prefix&#x27;s node iterate through all the child\n     * nodes by recursively appending all the possible words below the trie\n     * @param prefix string to recommend the words\n     * @param element node at the end of the given prefix\n     * @param results list to store the all possible words\n     * @returns list of recommended words\n     */</span>\n    <span class=\"hljs-function\">std::vector&lt;std::string&gt; <span class=\"hljs-title\">get_all_words</span><span class=\"hljs-params\">(std::vector&lt;std::string&gt; results,\n                                           <span class=\"hljs-keyword\">const</span> std::shared_ptr&lt;Node&gt;&amp; element,\n                                           std::string prefix)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (element-&gt;word_end) {\n            results.<span class=\"hljs-built_in\">push_back</span>(prefix);\n        }\n        <span class=\"hljs-keyword\">if</span> (element-&gt;children.<span class=\"hljs-built_in\">empty</span>()) {\n            <span class=\"hljs-keyword\">return</span> results;\n        }\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> <span class=\"hljs-keyword\">const</span>&amp; x : element-&gt;children) {\n            std::string key = <span class=\"hljs-string\">&quot;&quot;</span>;\n            key = x.first;\n            prefix += key;\n\n            results =\n                <span class=\"hljs-built_in\">get_all_words</span>(results, element-&gt;children[x.first], prefix);\n\n            prefix.<span class=\"hljs-built_in\">pop_back</span>();\n        }\n\n        <span class=\"hljs-keyword\">return</span> results;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief predict/recommend a word that starts with a given prefix\n     * @param prefix string to search for\n     * @returns list of recommended words\n     */</span>\n    <span class=\"hljs-function\">std::vector&lt;std::string&gt; <span class=\"hljs-title\">predict_words</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string&amp; prefix)</span> </span>{\n        std::vector&lt;std::string&gt; result;\n        std::shared_ptr&lt;Node&gt; curr = root_node;\n        <span class=\"hljs-comment\">// traversing until the end of the given prefix in trie</span>\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">char</span> ch : prefix) {\n            <span class=\"hljs-keyword\">if</span> (curr-&gt;children.<span class=\"hljs-built_in\">find</span>(ch) == curr-&gt;children.<span class=\"hljs-built_in\">end</span>()) {\n                <span class=\"hljs-keyword\">return</span> result;\n            }\n\n            curr = curr-&gt;children[ch];\n        }\n\n        <span class=\"hljs-comment\">// if the given prefix is the only word without children</span>\n        <span class=\"hljs-keyword\">if</span> (curr-&gt;word_end &amp;&amp; curr-&gt;children.<span class=\"hljs-built_in\">empty</span>()) {\n            result.<span class=\"hljs-built_in\">push_back</span>(prefix);\n            <span class=\"hljs-keyword\">return</span> result;\n        }\n\n        result = <span class=\"hljs-built_in\">get_all_words</span>(\n            result, curr,\n            prefix);  <span class=\"hljs-comment\">///&lt; iteratively and recursively get the recommended words</span>\n\n        <span class=\"hljs-keyword\">return</span> result;\n    }\n};\n}  <span class=\"hljs-comment\">// namespace trie_using_hashmap</span>\n}  <span class=\"hljs-comment\">// namespace data_structures</span>\n\n<span class=\"hljs-comment\">/**\n * @brief Self-test implementations\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\n    data_structures::trie_using_hashmap::Trie obj;\n    <span class=\"hljs-comment\">// Inserting data into trie using the insert</span>\n    <span class=\"hljs-comment\">// method and testing it with search method</span>\n    obj.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-string\">&quot;app&quot;</span>);\n    obj.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-string\">&quot;abscond&quot;</span>);\n    obj.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-string\">&quot;about&quot;</span>);\n    obj.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-string\">&quot;apps&quot;</span>);\n    obj.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-string\">&quot;apen&quot;</span>);\n    obj.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-string\">&quot;apples&quot;</span>);\n    obj.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-string\">&quot;apple&quot;</span>);\n    obj.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-string\">&quot;approach&quot;</span>);\n    obj.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-string\">&quot;bus&quot;</span>);\n    obj.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-string\">&quot;buses&quot;</span>);\n    obj.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-string\">&quot;Apple&quot;</span>);\n    obj.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-string\">&quot;Bounce&quot;</span>);\n\n    <span class=\"hljs-built_in\">assert</span>(!obj.<span class=\"hljs-built_in\">search</span>(<span class=\"hljs-string\">&quot;appy&quot;</span>));\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;appy is not a word in trie&quot;</span> &lt;&lt; std::endl;\n\n    <span class=\"hljs-built_in\">assert</span>(!obj.<span class=\"hljs-built_in\">search</span>(<span class=\"hljs-string\">&quot;car&quot;</span>));\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;car is not a word in trie&quot;</span> &lt;&lt; std::endl;\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">search</span>(<span class=\"hljs-string\">&quot;app&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">search</span>(<span class=\"hljs-string\">&quot;apple&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">search</span>(<span class=\"hljs-string\">&quot;apples&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">search</span>(<span class=\"hljs-string\">&quot;apps&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">search</span>(<span class=\"hljs-string\">&quot;apen&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">search</span>(<span class=\"hljs-string\">&quot;approach&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">search</span>(<span class=\"hljs-string\">&quot;about&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">search</span>(<span class=\"hljs-string\">&quot;abscond&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">search</span>(<span class=\"hljs-string\">&quot;bus&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">search</span>(<span class=\"hljs-string\">&quot;buses&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">search</span>(<span class=\"hljs-string\">&quot;Bounce&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">search</span>(<span class=\"hljs-string\">&quot;Apple&quot;</span>));\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;All the Inserted words are present in the trie&quot;</span> &lt;&lt; std::endl;\n\n    <span class=\"hljs-comment\">// test for startwith prefix method</span>\n    <span class=\"hljs-built_in\">assert</span>(!obj.<span class=\"hljs-built_in\">startwith</span>(<span class=\"hljs-string\">&quot;approachs&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">startwith</span>(<span class=\"hljs-string\">&quot;approach&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">startwith</span>(<span class=\"hljs-string\">&quot;about&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(!obj.<span class=\"hljs-built_in\">startwith</span>(<span class=\"hljs-string\">&quot;appy&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">startwith</span>(<span class=\"hljs-string\">&quot;abscond&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">startwith</span>(<span class=\"hljs-string\">&quot;bus&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">startwith</span>(<span class=\"hljs-string\">&quot;buses&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">startwith</span>(<span class=\"hljs-string\">&quot;Bounce&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">startwith</span>(<span class=\"hljs-string\">&quot;Apple&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">startwith</span>(<span class=\"hljs-string\">&quot;abs&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">startwith</span>(<span class=\"hljs-string\">&quot;b&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">startwith</span>(<span class=\"hljs-string\">&quot;bus&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">startwith</span>(<span class=\"hljs-string\">&quot;Bo&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">startwith</span>(<span class=\"hljs-string\">&quot;A&quot;</span>));\n    <span class=\"hljs-built_in\">assert</span>(!obj.<span class=\"hljs-built_in\">startwith</span>(<span class=\"hljs-string\">&quot;Ca&quot;</span>));\n\n    <span class=\"hljs-built_in\">assert</span>(!obj.<span class=\"hljs-built_in\">startwith</span>(<span class=\"hljs-string\">&quot;C&quot;</span>));\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;All the tests passed for startwith method&quot;</span> &lt;&lt; std::endl;\n\n    <span class=\"hljs-comment\">// test for predict_words/recommendation of words based on a given prefix</span>\n\n    std::vector&lt;std::string&gt; pred_words = obj.<span class=\"hljs-built_in\">predict_words</span>(<span class=\"hljs-string\">&quot;a&quot;</span>);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> std::string&amp; str : obj.<span class=\"hljs-built_in\">predict_words</span>(<span class=\"hljs-string\">&quot;a&quot;</span>)) {\n        std::cout &lt;&lt; str &lt;&lt; std::endl;\n    }\n    <span class=\"hljs-built_in\">assert</span>(pred_words.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">8</span>);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Returned all words that start with prefix a &quot;</span> &lt;&lt; std::endl;\n    pred_words = obj.<span class=\"hljs-built_in\">predict_words</span>(<span class=\"hljs-string\">&quot;app&quot;</span>);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> std::string&amp; str : pred_words) {\n        std::cout &lt;&lt; str &lt;&lt; std::endl;\n    }\n\n    <span class=\"hljs-built_in\">assert</span>(pred_words.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">5</span>);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Returned all words that start with prefix app &quot;</span> &lt;&lt; std::endl;\n    pred_words = obj.<span class=\"hljs-built_in\">predict_words</span>(<span class=\"hljs-string\">&quot;A&quot;</span>);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> std::string&amp; str : pred_words) {\n        std::cout &lt;&lt; str &lt;&lt; std::endl;\n    }\n\n    <span class=\"hljs-built_in\">assert</span>(pred_words.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">1</span>);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Returned all words that start with prefix A &quot;</span> &lt;&lt; std::endl;\n    pred_words = obj.<span class=\"hljs-built_in\">predict_words</span>(<span class=\"hljs-string\">&quot;bu&quot;</span>);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> std::string&amp; str : pred_words) {\n        std::cout &lt;&lt; str &lt;&lt; std::endl;\n    }\n\n    <span class=\"hljs-built_in\">assert</span>(pred_words.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">2</span>);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Returned all words that start with prefix bu &quot;</span> &lt;&lt; std::endl;\n\n    <span class=\"hljs-comment\">// tests for delete method</span>\n\n    obj.<span class=\"hljs-built_in\">delete_word</span>(<span class=\"hljs-string\">&quot;app&quot;</span>);\n    <span class=\"hljs-built_in\">assert</span>(!obj.<span class=\"hljs-built_in\">search</span>(<span class=\"hljs-string\">&quot;app&quot;</span>));\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;word app is deleted sucessful&quot;</span> &lt;&lt; std::endl;\n\n    pred_words = obj.<span class=\"hljs-built_in\">predict_words</span>(<span class=\"hljs-string\">&quot;app&quot;</span>);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> std::string&amp; str : pred_words) {\n        std::cout &lt;&lt; str &lt;&lt; std::endl;\n    }\n    <span class=\"hljs-built_in\">assert</span>(pred_words.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">4</span>);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;app is deleted sucessful&quot;</span> &lt;&lt; std::endl;\n\n    <span class=\"hljs-comment\">// test case for Chinese language</span>\n\n    obj.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-string\">&quot;苹果&quot;</span>);\n    <span class=\"hljs-built_in\">assert</span>(obj.<span class=\"hljs-built_in\">startwith</span>(<span class=\"hljs-string\">&quot;苹&quot;</span>));\n    pred_words = obj.<span class=\"hljs-built_in\">predict_words</span>(<span class=\"hljs-string\">&quot;h&quot;</span>);\n\n    <span class=\"hljs-built_in\">assert</span>(pred_words.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;No word starts with prefix h in trie&quot;</span> &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;All tests passed&quot;</span> &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Main function\n * @returns 0 on exit\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">// run self-test implementaions</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Venkata Bharath Malapati",
      "email": "9440110838bharath@gmail.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}
