{
  "slug": "kruskal",
  "name": "Kruskal",
  "categories": ["graphs"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "graph/kruskal.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph/kruskal.cpp",
      "code": "<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;array&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\n<span class=\"hljs-comment\">//#include &lt;boost/multiprecision/cpp_int.hpp&gt;</span>\n<span class=\"hljs-comment\">// using namespace boost::multiprecision;</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> mx = <span class=\"hljs-number\">1e6</span> + <span class=\"hljs-number\">5</span>;\n<span class=\"hljs-keyword\">using</span> ll = <span class=\"hljs-type\">int64_t</span>;\n\nstd::array&lt;ll, mx&gt; parent;\nll node, edge;\nstd::vector&lt;std::pair&lt;ll, std::pair&lt;ll, ll&gt;&gt;&gt; edges;\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">initial</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; node + edge; ++i) {\n        parent[i] = i;\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">root</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> </span>{\n    <span class=\"hljs-keyword\">while</span> (parent[i] != i) {\n        parent[i] = parent[parent[i]];\n        i = parent[i];\n    }\n    <span class=\"hljs-keyword\">return</span> i;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">join</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y)</span> </span>{\n    <span class=\"hljs-type\">int</span> root_x = <span class=\"hljs-built_in\">root</span>(x);  <span class=\"hljs-comment\">// Disjoint set union by rank</span>\n    <span class=\"hljs-type\">int</span> root_y = <span class=\"hljs-built_in\">root</span>(y);\n    parent[root_x] = root_y;\n}\n\n<span class=\"hljs-function\">ll <span class=\"hljs-title\">kruskal</span><span class=\"hljs-params\">()</span> </span>{\n    ll mincost = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; edge; ++i) {\n        ll x = edges[i].second.first;\n        ll y = edges[i].second.second;\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">root</span>(x) != <span class=\"hljs-built_in\">root</span>(y)) {\n            mincost += edges[i].first;\n            <span class=\"hljs-built_in\">join</span>(x, y);\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> mincost;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\n        <span class=\"hljs-type\">int</span> from = <span class=\"hljs-number\">0</span>, to = <span class=\"hljs-number\">0</span>, cost = <span class=\"hljs-number\">0</span>, totalcost = <span class=\"hljs-number\">0</span>;\n        std::cin &gt;&gt; node &gt;&gt; edge;  <span class=\"hljs-comment\">// Enter the nodes and edges</span>\n        <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-number\">0</span> &amp;&amp; edge == <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">break</span>;  <span class=\"hljs-comment\">// Enter 0 0 to break out</span>\n        }\n        <span class=\"hljs-built_in\">initial</span>();  <span class=\"hljs-comment\">// Initialise the parent array</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; edge; ++i) {\n            std::cin &gt;&gt; from &gt;&gt; to &gt;&gt; cost;\n            edges.<span class=\"hljs-built_in\">emplace_back</span>(<span class=\"hljs-built_in\">make_pair</span>(cost, std::<span class=\"hljs-built_in\">make_pair</span>(from, to)));\n            totalcost += cost;\n        }\n        <span class=\"hljs-built_in\">sort</span>(edges.<span class=\"hljs-built_in\">begin</span>(), edges.<span class=\"hljs-built_in\">end</span>());\n        std::cout &lt;&lt; <span class=\"hljs-built_in\">kruskal</span>() &lt;&lt; std::endl;\n        edges.<span class=\"hljs-built_in\">clear</span>();\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "java": {
      "dir": "DataStructures/Graphs/Kruskal.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/DataStructures/Graphs/Kruskal.java",
      "code": "<span class=\"hljs-comment\">// Problem -&gt; Connect all the edges with the minimum cost.</span>\n<span class=\"hljs-comment\">// Possible Solution -&gt; Kruskal Algorithm (KA), KA finds the minimum-spanning-tree, which means, the</span>\n<span class=\"hljs-comment\">// group of edges with the minimum sum of their weights that connect the whole graph.</span>\n<span class=\"hljs-comment\">// The graph needs to be connected, because if there are nodes impossible to reach, there are no</span>\n<span class=\"hljs-comment\">// edges that could connect every node in the graph.</span>\n<span class=\"hljs-comment\">// KA is a Greedy Algorithm, because edges are analysed based on their weights, that is why a</span>\n<span class=\"hljs-comment\">// Priority Queue is used, to take first those less weighted.</span>\n<span class=\"hljs-comment\">// This implementations below has some changes compared to conventional ones, but they are explained</span>\n<span class=\"hljs-comment\">// all along the code.</span>\n\n<span class=\"hljs-keyword\">import</span> java.util.Comparator;\n<span class=\"hljs-keyword\">import</span> java.util.HashSet;\n<span class=\"hljs-keyword\">import</span> java.util.PriorityQueue;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Kruskal</span> {\n\n  <span class=\"hljs-comment\">// Complexity: O(E log V) time, where E is the number of edges in the graph and V is the number of</span>\n  <span class=\"hljs-comment\">// vertices</span>\n\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Edge</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> from;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> to;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> weight;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Edge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> from, <span class=\"hljs-type\">int</span> to, <span class=\"hljs-type\">int</span> weight)</span> {\n      <span class=\"hljs-built_in\">this</span>.from = from;\n      <span class=\"hljs-built_in\">this</span>.to = to;\n      <span class=\"hljs-built_in\">this</span>.weight = weight;\n    }\n  }\n\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">addEdge</span><span class=\"hljs-params\">(HashSet&lt;Edge&gt;[] graph, <span class=\"hljs-type\">int</span> from, <span class=\"hljs-type\">int</span> to, <span class=\"hljs-type\">int</span> weight)</span> {\n    graph[from].add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Edge</span>(from, to, weight));\n  }\n\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    HashSet&lt;Edge&gt;[] graph = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashSet</span>[<span class=\"hljs-number\">7</span>];\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; graph.length; i++) {\n      graph[i] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashSet</span>&lt;&gt;();\n    }\n    addEdge(graph, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n    addEdge(graph, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\n    addEdge(graph, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>);\n    addEdge(graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>);\n    addEdge(graph, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>);\n    addEdge(graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>);\n    addEdge(graph, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>);\n    addEdge(graph, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>);\n    addEdge(graph, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>);\n    addEdge(graph, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">9</span>);\n\n    System.out.println(<span class=\"hljs-string\">&quot;Initial Graph: &quot;</span>);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; graph.length; i++) {\n      <span class=\"hljs-keyword\">for</span> (Edge edge : graph[i]) {\n        System.out.println(i + <span class=\"hljs-string\">&quot; &lt;-- weight &quot;</span> + edge.weight + <span class=\"hljs-string\">&quot; --&gt; &quot;</span> + edge.to);\n      }\n    }\n\n    <span class=\"hljs-type\">Kruskal</span> <span class=\"hljs-variable\">k</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Kruskal</span>();\n    HashSet&lt;Edge&gt;[] solGraph = k.kruskal(graph);\n\n    System.out.println(<span class=\"hljs-string\">&quot;\\nMinimal Graph: &quot;</span>);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; solGraph.length; i++) {\n      <span class=\"hljs-keyword\">for</span> (Edge edge : solGraph[i]) {\n        System.out.println(i + <span class=\"hljs-string\">&quot; &lt;-- weight &quot;</span> + edge.weight + <span class=\"hljs-string\">&quot; --&gt; &quot;</span> + edge.to);\n      }\n    }\n  }\n\n  <span class=\"hljs-keyword\">public</span> HashSet&lt;Edge&gt;[] kruskal(HashSet&lt;Edge&gt;[] graph) {\n    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">nodes</span> <span class=\"hljs-operator\">=</span> graph.length;\n    <span class=\"hljs-type\">int</span>[] captain = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[nodes];\n    <span class=\"hljs-comment\">// captain of i, stores the set with all the connected nodes to i</span>\n    HashSet&lt;Integer&gt;[] connectedGroups = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashSet</span>[nodes];\n    HashSet&lt;Edge&gt;[] minGraph = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashSet</span>[nodes];\n    PriorityQueue&lt;Edge&gt; edges = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PriorityQueue</span>&lt;&gt;((Comparator.comparingInt(edge -&gt; edge.weight)));\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; nodes; i++) {\n      minGraph[i] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashSet</span>&lt;&gt;();\n      connectedGroups[i] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashSet</span>&lt;&gt;();\n      connectedGroups[i].add(i);\n      captain[i] = i;\n      edges.addAll(graph[i]);\n    }\n    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">connectedElements</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-comment\">// as soon as two sets merge all the elements, the algorithm must stop</span>\n    <span class=\"hljs-keyword\">while</span> (connectedElements != nodes &amp;&amp; !edges.isEmpty()) {\n      <span class=\"hljs-type\">Edge</span> <span class=\"hljs-variable\">edge</span> <span class=\"hljs-operator\">=</span> edges.poll();\n      <span class=\"hljs-comment\">// This if avoids cycles</span>\n      <span class=\"hljs-keyword\">if</span> (!connectedGroups[captain[edge.from]].contains(edge.to)\n          &amp;&amp; !connectedGroups[captain[edge.to]].contains(edge.from)) {\n        <span class=\"hljs-comment\">// merge sets of the captains of each point connected by the edge</span>\n        connectedGroups[captain[edge.from]].addAll(connectedGroups[captain[edge.to]]);\n        <span class=\"hljs-comment\">// update captains of the elements merged</span>\n        connectedGroups[captain[edge.from]].forEach(i -&gt; captain[i] = captain[edge.from]);\n        <span class=\"hljs-comment\">// add Edge to minimal graph</span>\n        addEdge(minGraph, edge.from, edge.to, edge.weight);\n        <span class=\"hljs-comment\">// count how many elements have been merged</span>\n        connectedElements = connectedGroups[captain[edge.from]].size();\n      }\n    }\n    <span class=\"hljs-keyword\">return</span> minGraph;\n  }\n}\n"
    },
    "c": {
      "dir": "data_structures/graphs/kruskal.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/data_structures/graphs/kruskal.c",
      "code": "<span class=\"hljs-comment\">// C program for Kruskal&#x27;s algorithm to find Minimum Spanning Tree</span>\n<span class=\"hljs-comment\">// of a given connected, undirected and weighted graph</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string.h&gt;</span></span>\n\n<span class=\"hljs-comment\">// a structure to represent a weighted edge in graph</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span>\n{</span>\n    <span class=\"hljs-type\">int</span> src, dest, weight;\n};\n\n<span class=\"hljs-comment\">// a structure to represent a connected, undirected</span>\n<span class=\"hljs-comment\">// and weighted graph</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Graph</span>\n{</span>\n    <span class=\"hljs-comment\">// V-&gt; Number of vertices, E-&gt; Number of edges</span>\n    <span class=\"hljs-type\">int</span> V, E;\n\n    <span class=\"hljs-comment\">// graph is represented as an array of edges.</span>\n    <span class=\"hljs-comment\">// Since the graph is undirected, the edge</span>\n    <span class=\"hljs-comment\">// from src to dest is also edge from dest</span>\n    <span class=\"hljs-comment\">// to src. Both are counted as 1 edge here.</span>\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span> *<span class=\"hljs-title\">edge</span>;</span>\n};\n\n<span class=\"hljs-comment\">// Creates a graph with V vertices and E edges</span>\n<span class=\"hljs-keyword\">struct</span> Graph *<span class=\"hljs-title function_\">createGraph</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> V, <span class=\"hljs-type\">int</span> E)</span>\n{\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Graph</span> *<span class=\"hljs-title\">graph</span> =</span> new Graph();\n    graph-&gt;V = V;\n    graph-&gt;E = E;\n\n    graph-&gt;edge = new Edge[E];\n\n    <span class=\"hljs-keyword\">return</span> graph;\n}\n\n<span class=\"hljs-comment\">// A structure to represent a subset for union-find</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">subset</span>\n{</span>\n    <span class=\"hljs-type\">int</span> parent;\n    <span class=\"hljs-type\">int</span> rank;\n};\n\n<span class=\"hljs-comment\">// A utility function to find set of an element i</span>\n<span class=\"hljs-comment\">// (uses path compression technique)</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">find</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> subset subsets[], <span class=\"hljs-type\">int</span> i)</span>\n{\n    <span class=\"hljs-comment\">// find root and make root as parent of i</span>\n    <span class=\"hljs-comment\">// (path compression)</span>\n    <span class=\"hljs-keyword\">if</span> (subsets[i].parent != i)\n        subsets[i].parent = find(subsets, subsets[i].parent);\n\n    <span class=\"hljs-keyword\">return</span> subsets[i].parent;\n}\n\n<span class=\"hljs-comment\">// A function that does union of two sets of x and y</span>\n<span class=\"hljs-comment\">// (uses union by rank)</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">Union</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> subset subsets[], <span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y)</span>\n{\n    <span class=\"hljs-type\">int</span> xroot = find(subsets, x);\n    <span class=\"hljs-type\">int</span> yroot = find(subsets, y);\n\n    <span class=\"hljs-comment\">// Attach smaller rank tree under root of high</span>\n    <span class=\"hljs-comment\">// rank tree (Union by Rank)</span>\n    <span class=\"hljs-keyword\">if</span> (subsets[xroot].rank &lt; subsets[yroot].rank)\n        subsets[xroot].parent = yroot;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (subsets[xroot].rank &gt; subsets[yroot].rank)\n        subsets[yroot].parent = xroot;\n\n    <span class=\"hljs-comment\">// If ranks are same, then make one as root and</span>\n    <span class=\"hljs-comment\">// increment its rank by one</span>\n    <span class=\"hljs-keyword\">else</span>\n    {\n        subsets[yroot].parent = xroot;\n        subsets[xroot].rank++;\n    }\n}\n\n<span class=\"hljs-comment\">// Compare two edges according to their weights.</span>\n<span class=\"hljs-comment\">// Used in qsort() for sorting an array of edges</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">myComp</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">void</span> *a, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">void</span> *b)</span>\n{\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span> *<span class=\"hljs-title\">a1</span> =</span> (<span class=\"hljs-keyword\">struct</span> Edge *)a;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span> *<span class=\"hljs-title\">b1</span> =</span> (<span class=\"hljs-keyword\">struct</span> Edge *)b;\n    <span class=\"hljs-keyword\">return</span> a1-&gt;weight &gt; b1-&gt;weight;\n}\n\n<span class=\"hljs-comment\">// The main function to construct MST using Kruskal&#x27;s algorithm</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">KruskalMST</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Graph *graph)</span>\n{\n    <span class=\"hljs-type\">int</span> V = graph-&gt;V;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span> <span class=\"hljs-title\">result</span>[<span class=\"hljs-title\">V</span>];</span>  <span class=\"hljs-comment\">// Tnis will store the resultant MST</span>\n    <span class=\"hljs-type\">int</span> e = <span class=\"hljs-number\">0</span>;              <span class=\"hljs-comment\">// An index variable, used for result[]</span>\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;              <span class=\"hljs-comment\">// An index variable, used for sorted edges</span>\n\n    <span class=\"hljs-comment\">// Step 1: Sort all the edges in non-decreasing</span>\n    <span class=\"hljs-comment\">// order of their weight. If we are not allowed to</span>\n    <span class=\"hljs-comment\">// change the given graph, we can create a copy of</span>\n    <span class=\"hljs-comment\">// array of edges</span>\n    qsort(graph-&gt;edge, graph-&gt;E, <span class=\"hljs-keyword\">sizeof</span>(graph-&gt;edge[<span class=\"hljs-number\">0</span>]), myComp);\n\n    <span class=\"hljs-comment\">// Allocate memory for creating V ssubsets</span>\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">subset</span> *<span class=\"hljs-title\">subsets</span> =</span> (<span class=\"hljs-keyword\">struct</span> subset *)<span class=\"hljs-built_in\">malloc</span>(V * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> subset));\n\n    <span class=\"hljs-comment\">// Create V subsets with single elements</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v = <span class=\"hljs-number\">0</span>; v &lt; V; ++v)\n    {\n        subsets[v].parent = v;\n        subsets[v].rank = <span class=\"hljs-number\">0</span>;\n    }\n\n    <span class=\"hljs-comment\">// Number of edges to be taken is equal to V-1</span>\n    <span class=\"hljs-keyword\">while</span> (e &lt; V - <span class=\"hljs-number\">1</span> &amp;&amp; i &lt; graph-&gt;E)\n    {\n        <span class=\"hljs-comment\">// Step 2: Pick the smallest edge. And increment</span>\n        <span class=\"hljs-comment\">// the index for next iteration</span>\n        <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span> <span class=\"hljs-title\">next_edge</span> =</span> graph-&gt;edge[i++];\n\n        <span class=\"hljs-type\">int</span> x = find(subsets, next_edge.src);\n        <span class=\"hljs-type\">int</span> y = find(subsets, next_edge.dest);\n\n        <span class=\"hljs-comment\">// If including this edge does&#x27;t cause cycle,</span>\n        <span class=\"hljs-comment\">// include it in result and increment the index</span>\n        <span class=\"hljs-comment\">// of result for next edge</span>\n        <span class=\"hljs-keyword\">if</span> (x != y)\n        {\n            result[e++] = next_edge;\n            Union(subsets, x, y);\n        }\n        <span class=\"hljs-comment\">// Else discard the next_edge</span>\n    }\n\n    <span class=\"hljs-comment\">// print the contents of result[] to display the</span>\n    <span class=\"hljs-comment\">// built MST</span>\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Following are the edges in the constructed MST\\n&quot;</span>);\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; e; ++i)\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d -- %d == %d\\n&quot;</span>, result[i].src, result[i].dest,\n               result[i].weight);\n    <span class=\"hljs-keyword\">return</span>;\n}\n\n<span class=\"hljs-comment\">// Driver program to test above functions</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span>\n{\n    <span class=\"hljs-comment\">/* Let us create following weighted graph\n            10\n        0--------1\n        | \\\t |\n    6| 5\\ |15\n        |\t \\ |\n        2--------3\n            4\t */</span>\n    <span class=\"hljs-type\">int</span> V = <span class=\"hljs-number\">4</span>;  <span class=\"hljs-comment\">// Number of vertices in graph</span>\n    <span class=\"hljs-type\">int</span> E = <span class=\"hljs-number\">5</span>;  <span class=\"hljs-comment\">// Number of edges in graph</span>\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Graph</span> *<span class=\"hljs-title\">graph</span> =</span> createGraph(V, E);\n\n    <span class=\"hljs-comment\">// add edge 0-1</span>\n    graph-&gt;edge[<span class=\"hljs-number\">0</span>].src = <span class=\"hljs-number\">0</span>;\n    graph-&gt;edge[<span class=\"hljs-number\">0</span>].dest = <span class=\"hljs-number\">1</span>;\n    graph-&gt;edge[<span class=\"hljs-number\">0</span>].weight = <span class=\"hljs-number\">10</span>;\n\n    <span class=\"hljs-comment\">// add edge 0-2</span>\n    graph-&gt;edge[<span class=\"hljs-number\">1</span>].src = <span class=\"hljs-number\">0</span>;\n    graph-&gt;edge[<span class=\"hljs-number\">1</span>].dest = <span class=\"hljs-number\">2</span>;\n    graph-&gt;edge[<span class=\"hljs-number\">1</span>].weight = <span class=\"hljs-number\">6</span>;\n\n    <span class=\"hljs-comment\">// add edge 0-3</span>\n    graph-&gt;edge[<span class=\"hljs-number\">2</span>].src = <span class=\"hljs-number\">0</span>;\n    graph-&gt;edge[<span class=\"hljs-number\">2</span>].dest = <span class=\"hljs-number\">3</span>;\n    graph-&gt;edge[<span class=\"hljs-number\">2</span>].weight = <span class=\"hljs-number\">5</span>;\n\n    <span class=\"hljs-comment\">// add edge 1-3</span>\n    graph-&gt;edge[<span class=\"hljs-number\">3</span>].src = <span class=\"hljs-number\">1</span>;\n    graph-&gt;edge[<span class=\"hljs-number\">3</span>].dest = <span class=\"hljs-number\">3</span>;\n    graph-&gt;edge[<span class=\"hljs-number\">3</span>].weight = <span class=\"hljs-number\">15</span>;\n\n    <span class=\"hljs-comment\">// add edge 2-3</span>\n    graph-&gt;edge[<span class=\"hljs-number\">4</span>].src = <span class=\"hljs-number\">2</span>;\n    graph-&gt;edge[<span class=\"hljs-number\">4</span>].dest = <span class=\"hljs-number\">3</span>;\n    graph-&gt;edge[<span class=\"hljs-number\">4</span>].weight = <span class=\"hljs-number\">4</span>;\n\n    KruskalMST(graph);\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "swift": {
      "dir": "graph/spanning_tree/kruskal.swift",
      "url": "https://github.com/TheAlgorithms/swift/tree/master/graph/spanning_tree/kruskal.swift",
      "code": "<span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Kruskal</span> {\n    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Vertex</span> {\n        <span class=\"hljs-keyword\">let</span> name: <span class=\"hljs-type\">String</span>\n        <span class=\"hljs-keyword\">let</span> node <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">UnionFindNode</span>()\n\n        <span class=\"hljs-keyword\">init</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">name</span>: <span class=\"hljs-type\">String</span>) {\n            <span class=\"hljs-keyword\">self</span>.name <span class=\"hljs-operator\">=</span> name\n        }\n    }\n\n    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Edge</span> {\n        <span class=\"hljs-keyword\">let</span> from: <span class=\"hljs-type\">Vertex</span>\n        <span class=\"hljs-keyword\">let</span> to: <span class=\"hljs-type\">Vertex</span>\n        <span class=\"hljs-keyword\">let</span> weight: <span class=\"hljs-type\">Int</span>\n    }\n\n    <span class=\"hljs-keyword\">typealias</span> <span class=\"hljs-type\">Graph</span> <span class=\"hljs-operator\">=</span> [<span class=\"hljs-type\">Edge</span>]\n\n\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">kruskal</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">graph</span>: <span class=\"hljs-type\">Graph</span>) -&gt; <span class=\"hljs-type\">Graph</span> {\n        <span class=\"hljs-keyword\">var</span> edges <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Heap</span>(graph) { <span class=\"hljs-variable\">$0</span>.weight <span class=\"hljs-operator\">&lt;</span> <span class=\"hljs-variable\">$1</span>.weight }\n\n        <span class=\"hljs-keyword\">var</span> result: <span class=\"hljs-type\">Graph</span> <span class=\"hljs-operator\">=</span> []\n        result.reserveCapacity(edges.count)\n\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">let</span> edge <span class=\"hljs-operator\">=</span> edges.extractMin() {\n            <span class=\"hljs-keyword\">guard</span> <span class=\"hljs-operator\">!</span><span class=\"hljs-type\">UnionFindNode</span>.inSameSet(edge.from.node, edge.to.node) <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-keyword\">continue</span>\n            }\n            <span class=\"hljs-type\">UnionFindNode</span>.union(edge.from.node, edge.to.node)\n            result.append(edge)\n        }\n\n        <span class=\"hljs-keyword\">return</span> result\n    }\n}\n\n<span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">Kruskal</span>.<span class=\"hljs-title class_\">Vertex</span>: <span class=\"hljs-title class_\">CustomStringConvertible</span> {\n    <span class=\"hljs-keyword\">var</span> description: <span class=\"hljs-type\">String</span> { name }\n}\n\n<span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">Kruskal</span>.<span class=\"hljs-title class_\">Edge</span>: <span class=\"hljs-title class_\">CustomStringConvertible</span> {\n    <span class=\"hljs-keyword\">var</span> description: <span class=\"hljs-type\">String</span> { <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">\\(from)</span> --(<span class=\"hljs-subst\">\\(weight)</span>)-- <span class=\"hljs-subst\">\\(to)</span>&quot;</span> }\n}\n\n<span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">testKruskal</span>() {\n    <span class=\"hljs-keyword\">typealias</span> <span class=\"hljs-type\">Vertex</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Kruskal</span>.<span class=\"hljs-type\">Vertex</span>\n    <span class=\"hljs-keyword\">typealias</span> <span class=\"hljs-type\">Edge</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Kruskal</span>.<span class=\"hljs-type\">Edge</span>\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-type\">A</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Vertex</span>(<span class=\"hljs-string\">&quot;A&quot;</span>)\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-type\">B</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Vertex</span>(<span class=\"hljs-string\">&quot;B&quot;</span>)\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-type\">C</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Vertex</span>(<span class=\"hljs-string\">&quot;C&quot;</span>)\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-type\">D</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Vertex</span>(<span class=\"hljs-string\">&quot;D&quot;</span>)\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-type\">E</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Vertex</span>(<span class=\"hljs-string\">&quot;E&quot;</span>)\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-type\">F</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Vertex</span>(<span class=\"hljs-string\">&quot;F&quot;</span>)\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-type\">G</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Vertex</span>(<span class=\"hljs-string\">&quot;G&quot;</span>)\n\n    <span class=\"hljs-keyword\">let</span> graph <span class=\"hljs-operator\">=</span> [\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">A</span>, to: <span class=\"hljs-type\">B</span>, weight: <span class=\"hljs-number\">7</span>),\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">A</span>, to: <span class=\"hljs-type\">D</span>, weight: <span class=\"hljs-number\">5</span>),\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">B</span>, to: <span class=\"hljs-type\">C</span>, weight: <span class=\"hljs-number\">8</span>),\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">B</span>, to: <span class=\"hljs-type\">D</span>, weight: <span class=\"hljs-number\">9</span>),\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">B</span>, to: <span class=\"hljs-type\">E</span>, weight: <span class=\"hljs-number\">7</span>),\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">C</span>, to: <span class=\"hljs-type\">E</span>, weight: <span class=\"hljs-number\">5</span>),\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">D</span>, to: <span class=\"hljs-type\">E</span>, weight: <span class=\"hljs-number\">15</span>),\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">D</span>, to: <span class=\"hljs-type\">F</span>, weight: <span class=\"hljs-number\">6</span>),\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">E</span>, to: <span class=\"hljs-type\">F</span>, weight: <span class=\"hljs-number\">8</span>),\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">E</span>, to: <span class=\"hljs-type\">G</span>, weight: <span class=\"hljs-number\">9</span>),\n        <span class=\"hljs-type\">Edge</span>(from: <span class=\"hljs-type\">F</span>, to: <span class=\"hljs-type\">G</span>, weight: <span class=\"hljs-number\">11</span>),\n    ]\n\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-type\">Kruskal</span>.kruskal(graph).map { <span class=\"hljs-type\">String</span>(describing: <span class=\"hljs-variable\">$0</span>) }.joined(separator: <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">\\n</span>&quot;</span>) )\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Sven Weidauer",
      "email": "sven@5sw.de",
      "commits": 1
    },
    {
      "name": "stepfencurryxiao",
      "email": "stepfencurryxiao@gmail.com",
      "commits": 1
    },
    {
      "name": "Libin Yang",
      "email": "szuyanglb@outlook.com",
      "commits": 1
    },
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "ttuanho",
      "email": "hhoanhtuann@gmail.com",
      "commits": 1
    },
    {
      "name": "SangeetaNB",
      "email": "43605580+SangeetaNB@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Ayaan Khan",
      "email": "ayaankhan98@gmail.com",
      "commits": 1
    },
    {
      "name": "Madhav",
      "email": "madhavgaba2@gmail.com",
      "commits": 1
    },
    {
      "name": "MarcosVillacanas",
      "email": "marcosvillacanas@icloud.com",
      "commits": 3
    },
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 5
    }
  ],
  "explanationUrl": {}
}
