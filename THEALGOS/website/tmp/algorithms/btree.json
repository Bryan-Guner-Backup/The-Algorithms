{
  "slug": "btree",
  "name": "Btree",
  "categories": ["datastructures", "binarytree"],
  "body": {},
  "implementations": {
    "go": {
      "dir": "datastructures/binary-tree/btree.go",
      "url": "https://github.com/TheAlgorithms/go/tree/master/datastructures/binary-tree/btree.go",
      "code": "<span class=\"hljs-keyword\">package</span> binarytree\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span>\n\n<span class=\"hljs-comment\">// BTree Returns a binary tree structure which contains only a root Node</span>\n<span class=\"hljs-keyword\">type</span> BTree <span class=\"hljs-keyword\">struct</span> {\n\tRoot *Node\n}\n\n<span class=\"hljs-comment\">// calculateDepth helper function for BTree&#x27;s depth()</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">calculateDepth</span><span class=\"hljs-params\">(n *Node, depth <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">int</span></span> {\n\t<span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> depth\n\t}\n\t<span class=\"hljs-keyword\">return</span> Max(calculateDepth(n.left, depth+<span class=\"hljs-number\">1</span>), calculateDepth(n.right, depth+<span class=\"hljs-number\">1</span>))\n}\n\n<span class=\"hljs-comment\">// Insert a value in the BTree</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Insert</span><span class=\"hljs-params\">(root *Node, val <span class=\"hljs-keyword\">int</span>)</span> *<span class=\"hljs-title\">Node</span></span> {\n\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> NewNode(val)\n\t}\n\t<span class=\"hljs-keyword\">if</span> val &lt; root.val {\n\t\troot.left = Insert(root.left, val)\n\t} <span class=\"hljs-keyword\">else</span> {\n\t\troot.right = Insert(root.right, val)\n\t}\n\t<span class=\"hljs-keyword\">return</span> root\n}\n\n<span class=\"hljs-comment\">// Depth returns the calculated depth of a binary tree</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(t *BTree)</span> <span class=\"hljs-title\">Depth</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">int</span></span> {\n\t<span class=\"hljs-keyword\">return</span> calculateDepth(t.Root, <span class=\"hljs-number\">0</span>)\n}\n\n<span class=\"hljs-comment\">// InOrder add&#x27;s children to a node in order left first then right recursively</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">InOrder</span><span class=\"hljs-params\">(n *Node)</span></span> {\n\t<span class=\"hljs-keyword\">if</span> n != <span class=\"hljs-literal\">nil</span> {\n\t\tInOrder(n.left)\n\t\tfmt.Print(n.val, <span class=\"hljs-string\">&quot; &quot;</span>)\n\t\tInOrder(n.right)\n\t}\n}\n\n<span class=\"hljs-comment\">// InOrderSuccessor Goes to the left</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">InOrderSuccessor</span><span class=\"hljs-params\">(root *Node)</span> *<span class=\"hljs-title\">Node</span></span> {\n\tcur := root\n\t<span class=\"hljs-keyword\">for</span> cur.left != <span class=\"hljs-literal\">nil</span> {\n\t\tcur = cur.left\n\t}\n\t<span class=\"hljs-keyword\">return</span> cur\n}\n\n<span class=\"hljs-comment\">// BstDelete removes the node</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">BstDelete</span><span class=\"hljs-params\">(root *Node, val <span class=\"hljs-keyword\">int</span>)</span> *<span class=\"hljs-title\">Node</span></span> {\n\t<span class=\"hljs-keyword\">if</span> root == <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n\t}\n\t<span class=\"hljs-keyword\">if</span> val &lt; root.val {\n\t\troot.left = BstDelete(root.left, val)\n\t} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> val &gt; root.val {\n\t\troot.right = BstDelete(root.right, val)\n\t} <span class=\"hljs-keyword\">else</span> {\n\t\t<span class=\"hljs-comment\">// this is the node to delete</span>\n\t\t<span class=\"hljs-comment\">// node with one child</span>\n\t\t<span class=\"hljs-keyword\">if</span> root.left == <span class=\"hljs-literal\">nil</span> {\n\t\t\t<span class=\"hljs-keyword\">return</span> root.right\n\t\t} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> root.right == <span class=\"hljs-literal\">nil</span> {\n\t\t\t<span class=\"hljs-keyword\">return</span> root.left\n\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\tn := root.right\n\t\t\td := InOrderSuccessor(n)\n\t\t\td.left = root.left\n\t\t\t<span class=\"hljs-keyword\">return</span> root.right\n\t\t}\n\t}\n\t<span class=\"hljs-keyword\">return</span> root\n}\n\n<span class=\"hljs-comment\">// PreOrder Preorder</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">PreOrder</span><span class=\"hljs-params\">(n *Node)</span></span> {\n\t<span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span>\n\t}\n\tfmt.Print(n.val, <span class=\"hljs-string\">&quot; &quot;</span>)\n\tPreOrder(n.left)\n\tPreOrder(n.right)\n}\n\n<span class=\"hljs-comment\">// PostOrder PostOrder</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">PostOrder</span><span class=\"hljs-params\">(n *Node)</span></span> {\n\t<span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span>\n\t}\n\tPostOrder(n.left)\n\tPostOrder(n.right)\n\tfmt.Print(n.val, <span class=\"hljs-string\">&quot; &quot;</span>)\n}\n\n<span class=\"hljs-comment\">// LevelOrder LevelOrder</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">LevelOrder</span><span class=\"hljs-params\">(root *Node)</span></span> {\n\t<span class=\"hljs-keyword\">var</span> q []*Node <span class=\"hljs-comment\">// queue</span>\n\t<span class=\"hljs-keyword\">var</span> n *Node   <span class=\"hljs-comment\">// temporary node</span>\n\n\tq = <span class=\"hljs-built_in\">append</span>(q, root)\n\n\t<span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">len</span>(q) != <span class=\"hljs-number\">0</span> {\n\t\tn, q = q[<span class=\"hljs-number\">0</span>], q[<span class=\"hljs-number\">1</span>:]\n\t\tfmt.Print(n.val, <span class=\"hljs-string\">&quot; &quot;</span>)\n\t\t<span class=\"hljs-keyword\">if</span> n.left != <span class=\"hljs-literal\">nil</span> {\n\t\t\tq = <span class=\"hljs-built_in\">append</span>(q, n.left)\n\t\t}\n\t\t<span class=\"hljs-keyword\">if</span> n.right != <span class=\"hljs-literal\">nil</span> {\n\t\t\tq = <span class=\"hljs-built_in\">append</span>(q, n.right)\n\t\t}\n\t}\n}\n"
    },
    "rust": {
      "dir": "src/data_structures/b_tree.rs",
      "url": "https://github.com/TheAlgorithms/rust/tree/master/src/data_structures/b_tree.rs",
      "code": "<span class=\"hljs-keyword\">use</span> std::convert::TryFrom;\n<span class=\"hljs-keyword\">use</span> std::fmt::<span class=\"hljs-built_in\">Debug</span>;\n<span class=\"hljs-keyword\">use</span> std::mem;\n\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span>&lt;T&gt; {\n    keys: <span class=\"hljs-type\">Vec</span>&lt;T&gt;,\n    children: <span class=\"hljs-type\">Vec</span>&lt;Node&lt;T&gt;&gt;,\n}\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">BTree</span>&lt;T&gt; {\n    root: Node&lt;T&gt;,\n    props: BTreeProps,\n}\n\n<span class=\"hljs-comment\">// Why to need a different Struct for props...</span>\n<span class=\"hljs-comment\">// Check - http://smallcultfollowing.com/babysteps/blog/2018/11/01/after-nll-interprocedural-conflicts/#fnref:improvement</span>\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">BTreeProps</span> {\n    degree: <span class=\"hljs-type\">usize</span>,\n    max_keys: <span class=\"hljs-type\">usize</span>,\n    mid_key_index: <span class=\"hljs-type\">usize</span>,\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; Node&lt;T&gt;\n<span class=\"hljs-keyword\">where</span>\n    T: <span class=\"hljs-built_in\">Ord</span>,\n{\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">new</span>(degree: <span class=\"hljs-type\">usize</span>, _keys: <span class=\"hljs-type\">Option</span>&lt;<span class=\"hljs-type\">Vec</span>&lt;T&gt;&gt;, _children: <span class=\"hljs-type\">Option</span>&lt;<span class=\"hljs-type\">Vec</span>&lt;Node&lt;T&gt;&gt;&gt;) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-keyword\">Self</span> {\n        Node {\n            keys: <span class=\"hljs-keyword\">match</span> _keys {\n                <span class=\"hljs-title function_ invoke__\">Some</span>(_keys) =&gt; _keys,\n                <span class=\"hljs-literal\">None</span> =&gt; Vec::<span class=\"hljs-title function_ invoke__\">with_capacity</span>(degree - <span class=\"hljs-number\">1</span>),\n            },\n            children: <span class=\"hljs-keyword\">match</span> _children {\n                <span class=\"hljs-title function_ invoke__\">Some</span>(_children) =&gt; _children,\n                <span class=\"hljs-literal\">None</span> =&gt; Vec::<span class=\"hljs-title function_ invoke__\">with_capacity</span>(degree),\n            },\n        }\n    }\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">is_leaf</span>(&amp;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">bool</span> {\n        <span class=\"hljs-keyword\">self</span>.children.<span class=\"hljs-title function_ invoke__\">is_empty</span>()\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">BTreeProps</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">new</span>(degree: <span class=\"hljs-type\">usize</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-keyword\">Self</span> {\n        BTreeProps {\n            degree,\n            max_keys: degree - <span class=\"hljs-number\">1</span>,\n            mid_key_index: (degree - <span class=\"hljs-number\">1</span>) / <span class=\"hljs-number\">2</span>,\n        }\n    }\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">is_maxed_out</span>&lt;T: <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Copy</span>&gt;(&amp;<span class=\"hljs-keyword\">self</span>, node: &amp;Node&lt;T&gt;) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">bool</span> {\n        node.keys.<span class=\"hljs-title function_ invoke__\">len</span>() == <span class=\"hljs-keyword\">self</span>.max_keys\n    }\n\n    <span class=\"hljs-comment\">// Split Child expects the Child Node to be full</span>\n    <span class=\"hljs-comment\">/// Move the middle_key to parent node and split the child_node&#x27;s</span>\n    <span class=\"hljs-comment\">/// keys/chilren_nodes into half</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">split_child</span>&lt;T: <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Copy</span> + <span class=\"hljs-built_in\">Default</span>&gt;(&amp;<span class=\"hljs-keyword\">self</span>, parent: &amp;<span class=\"hljs-keyword\">mut</span> Node&lt;T&gt;, child_index: <span class=\"hljs-type\">usize</span>) {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">child</span> = &amp;<span class=\"hljs-keyword\">mut</span> parent.children[child_index];\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">middle_key</span> = child.keys[<span class=\"hljs-keyword\">self</span>.mid_key_index];\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">right_keys</span> = <span class=\"hljs-keyword\">match</span> child.keys.<span class=\"hljs-title function_ invoke__\">split_off</span>(<span class=\"hljs-keyword\">self</span>.mid_key_index).<span class=\"hljs-title function_ invoke__\">split_first</span>() {\n            <span class=\"hljs-title function_ invoke__\">Some</span>((_first, _others)) =&gt; {\n                <span class=\"hljs-comment\">// We don&#x27;t need _first, as it will move to parent node.</span>\n                _others.<span class=\"hljs-title function_ invoke__\">to_vec</span>()\n            }\n            <span class=\"hljs-literal\">None</span> =&gt; Vec::<span class=\"hljs-title function_ invoke__\">with_capacity</span>(<span class=\"hljs-keyword\">self</span>.max_keys),\n        };\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">right_children</span> = <span class=\"hljs-keyword\">if</span> !child.<span class=\"hljs-title function_ invoke__\">is_leaf</span>() {\n            <span class=\"hljs-title function_ invoke__\">Some</span>(child.children.<span class=\"hljs-title function_ invoke__\">split_off</span>(<span class=\"hljs-keyword\">self</span>.mid_key_index + <span class=\"hljs-number\">1</span>))\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-literal\">None</span>\n        };\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">new_child_node</span>: Node&lt;T&gt; = Node::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-keyword\">self</span>.degree, <span class=\"hljs-title function_ invoke__\">Some</span>(right_keys), right_children);\n\n        parent.keys.<span class=\"hljs-title function_ invoke__\">insert</span>(child_index, middle_key);\n        parent.children.<span class=\"hljs-title function_ invoke__\">insert</span>(child_index + <span class=\"hljs-number\">1</span>, new_child_node);\n    }\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">insert_non_full</span>&lt;T: <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Copy</span> + <span class=\"hljs-built_in\">Default</span>&gt;(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, node: &amp;<span class=\"hljs-keyword\">mut</span> Node&lt;T&gt;, key: T) {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">index</span>: <span class=\"hljs-type\">isize</span> = isize::<span class=\"hljs-title function_ invoke__\">try_from</span>(node.keys.<span class=\"hljs-title function_ invoke__\">len</span>()).<span class=\"hljs-title function_ invoke__\">ok</span>().<span class=\"hljs-title function_ invoke__\">unwrap</span>() - <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">while</span> index &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; node.keys[index <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">usize</span>] &gt;= key {\n            index -= <span class=\"hljs-number\">1</span>;\n        }\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">u_index</span>: <span class=\"hljs-type\">usize</span> = usize::<span class=\"hljs-title function_ invoke__\">try_from</span>(index + <span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_ invoke__\">ok</span>().<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n        <span class=\"hljs-keyword\">if</span> node.<span class=\"hljs-title function_ invoke__\">is_leaf</span>() {\n            <span class=\"hljs-comment\">// Just insert it, as we know this method will be called only when node is not full</span>\n            node.keys.<span class=\"hljs-title function_ invoke__\">insert</span>(u_index, key);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">is_maxed_out</span>(&amp;node.children[u_index]) {\n                <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">split_child</span>(node, u_index);\n                <span class=\"hljs-keyword\">if</span> node.keys[u_index] &lt; key {\n                    u_index += <span class=\"hljs-number\">1</span>;\n                }\n            }\n\n            <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">insert_non_full</span>(&amp;<span class=\"hljs-keyword\">mut</span> node.children[u_index], key);\n        }\n    }\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">traverse_node</span>&lt;T: <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Debug</span>&gt;(&amp;<span class=\"hljs-keyword\">self</span>, node: &amp;Node&lt;T&gt;, depth: <span class=\"hljs-type\">usize</span>) {\n        <span class=\"hljs-keyword\">if</span> node.<span class=\"hljs-title function_ invoke__\">is_leaf</span>() {\n            <span class=\"hljs-built_in\">print!</span>(<span class=\"hljs-string\">&quot; {0:{&lt;1$}{2:?}{0:}&lt;1$} &quot;</span>, <span class=\"hljs-string\">&quot;&quot;</span>, depth, node.keys);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">_depth</span> = depth + <span class=\"hljs-number\">1</span>;\n            <span class=\"hljs-title function_ invoke__\">for</span> (index, key) <span class=\"hljs-keyword\">in</span> node.keys.<span class=\"hljs-title function_ invoke__\">iter</span>().<span class=\"hljs-title function_ invoke__\">enumerate</span>() {\n                <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">traverse_node</span>(&amp;node.children[index], _depth);\n                <span class=\"hljs-comment\">// Check https://doc.rust-lang.org/std/fmt/index.html</span>\n                <span class=\"hljs-comment\">// And https://stackoverflow.com/a/35280799/2849127</span>\n                <span class=\"hljs-built_in\">print!</span>(<span class=\"hljs-string\">&quot;{0:{&lt;1$}{2:?}{0:}&lt;1$}&quot;</span>, <span class=\"hljs-string\">&quot;&quot;</span>, depth, key);\n            }\n            <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">traverse_node</span>(&amp;node.children.<span class=\"hljs-title function_ invoke__\">last</span>().<span class=\"hljs-title function_ invoke__\">unwrap</span>(), _depth);\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T&gt; BTree&lt;T&gt;\n<span class=\"hljs-keyword\">where</span>\n    T: <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Copy</span> + <span class=\"hljs-built_in\">Debug</span> + <span class=\"hljs-built_in\">Default</span>,\n{\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">new</span>(branch_factor: <span class=\"hljs-type\">usize</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-keyword\">Self</span> {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">degree</span> = <span class=\"hljs-number\">2</span> * branch_factor;\n        BTree {\n            root: Node::<span class=\"hljs-title function_ invoke__\">new</span>(degree, <span class=\"hljs-literal\">None</span>, <span class=\"hljs-literal\">None</span>),\n            props: BTreeProps::<span class=\"hljs-title function_ invoke__\">new</span>(degree),\n        }\n    }\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">insert</span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, key: T) {\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.props.<span class=\"hljs-title function_ invoke__\">is_maxed_out</span>(&amp;<span class=\"hljs-keyword\">self</span>.root) {\n            <span class=\"hljs-comment\">// Create an empty root and split the old root...</span>\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">new_root</span> = Node::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-keyword\">self</span>.props.degree, <span class=\"hljs-literal\">None</span>, <span class=\"hljs-literal\">None</span>);\n            mem::<span class=\"hljs-title function_ invoke__\">swap</span>(&amp;<span class=\"hljs-keyword\">mut</span> new_root, &amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>.root);\n            <span class=\"hljs-keyword\">self</span>.root.children.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">0</span>, new_root);\n            <span class=\"hljs-keyword\">self</span>.props.<span class=\"hljs-title function_ invoke__\">split_child</span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>.root, <span class=\"hljs-number\">0</span>);\n        }\n        <span class=\"hljs-keyword\">self</span>.props.<span class=\"hljs-title function_ invoke__\">insert_non_full</span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>.root, key);\n    }\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">traverse</span>(&amp;<span class=\"hljs-keyword\">self</span>) {\n        <span class=\"hljs-keyword\">self</span>.props.<span class=\"hljs-title function_ invoke__\">traverse_node</span>(&amp;<span class=\"hljs-keyword\">self</span>.root, <span class=\"hljs-number\">0</span>);\n        <span class=\"hljs-built_in\">println!</span>();\n    }\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">search</span>(&amp;<span class=\"hljs-keyword\">self</span>, key: T) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">bool</span> {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">current_node</span> = &amp;<span class=\"hljs-keyword\">self</span>.root;\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">index</span>: <span class=\"hljs-type\">isize</span>;\n        <span class=\"hljs-keyword\">loop</span> {\n            index = isize::<span class=\"hljs-title function_ invoke__\">try_from</span>(current_node.keys.<span class=\"hljs-title function_ invoke__\">len</span>()).<span class=\"hljs-title function_ invoke__\">ok</span>().<span class=\"hljs-title function_ invoke__\">unwrap</span>() - <span class=\"hljs-number\">1</span>;\n            <span class=\"hljs-keyword\">while</span> index &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; current_node.keys[index <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">usize</span>] &gt; key {\n                index -= <span class=\"hljs-number\">1</span>;\n            }\n\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">u_index</span>: <span class=\"hljs-type\">usize</span> = usize::<span class=\"hljs-title function_ invoke__\">try_from</span>(index + <span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_ invoke__\">ok</span>().<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n            <span class=\"hljs-keyword\">if</span> index &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; current_node.keys[u_index - <span class=\"hljs-number\">1</span>] == key {\n                <span class=\"hljs-keyword\">break</span> <span class=\"hljs-literal\">true</span>;\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> current_node.<span class=\"hljs-title function_ invoke__\">is_leaf</span>() {\n                <span class=\"hljs-keyword\">break</span> <span class=\"hljs-literal\">false</span>;\n            } <span class=\"hljs-keyword\">else</span> {\n                current_node = &amp;current_node.children[u_index];\n            }\n        }\n    }\n}\n\n<span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> test {\n    <span class=\"hljs-keyword\">use</span> super::BTree;\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">test_search</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">tree</span> = BTree::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-number\">2</span>);\n        tree.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">10</span>);\n        tree.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">20</span>);\n        tree.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">30</span>);\n        tree.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">5</span>);\n        tree.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">6</span>);\n        tree.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">7</span>);\n        tree.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">11</span>);\n        tree.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">12</span>);\n        tree.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">15</span>);\n        <span class=\"hljs-built_in\">assert!</span>(tree.<span class=\"hljs-title function_ invoke__\">search</span>(<span class=\"hljs-number\">15</span>));\n        <span class=\"hljs-built_in\">assert_eq!</span>(tree.<span class=\"hljs-title function_ invoke__\">search</span>(<span class=\"hljs-number\">16</span>), <span class=\"hljs-literal\">false</span>);\n    }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Boyd Johnson",
      "email": "boydjohnson@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Subroto",
      "email": "shub1493biswas@gmail.com",
      "commits": 1
    },
    {
      "name": "Matthias Gilch",
      "email": "matthias.gilch.mg@gmail.com",
      "commits": 1
    },
    {
      "name": "Taj",
      "email": "tjgurwara99@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}
