{
  "slug": "ordinary-least-squares-regressor",
  "name": "Ordinary Least Squares Regressor",
  "categories": ["machinelearning"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "machine_learning/ordinary_least_squares_regressor.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/machine_learning/ordinary_least_squares_regressor.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * \\brief Linear regression example using [Ordinary least\n * squares](https://en.wikipedia.org/wiki/Ordinary_least_squares)\n *\n * Program that gets the number of data samples and number of features per\n * sample along with output per sample. It applies OLS regression to compute\n * the regression output for additional test data samples.\n *\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span>    <span class=\"hljs-comment\">// for std::abs</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iomanip&gt;</span>  <span class=\"hljs-comment\">// for print formatting</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\n\n<span class=\"hljs-comment\">/**\n * operator to print a matrix\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::ostream &amp;<span class=\"hljs-keyword\">operator</span>&lt;&lt;(std::ostream &amp;out,\n                         std::vector&lt;std::vector&lt;T&gt;&gt; <span class=\"hljs-keyword\">const</span> &amp;v) {\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> width = <span class=\"hljs-number\">10</span>;\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> separator = <span class=\"hljs-string\">&#x27; &#x27;</span>;\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row = <span class=\"hljs-number\">0</span>; row &lt; v.<span class=\"hljs-built_in\">size</span>(); row++) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> col = <span class=\"hljs-number\">0</span>; col &lt; v[row].<span class=\"hljs-built_in\">size</span>(); col++) {\n            out &lt;&lt; std::left &lt;&lt; std::<span class=\"hljs-built_in\">setw</span>(width) &lt;&lt; std::<span class=\"hljs-built_in\">setfill</span>(separator)\n                &lt;&lt; v[row][col];\n        }\n        out &lt;&lt; std::endl;\n    }\n\n    <span class=\"hljs-keyword\">return</span> out;\n}\n\n<span class=\"hljs-comment\">/**\n * operator to print a vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::ostream &amp;<span class=\"hljs-keyword\">operator</span>&lt;&lt;(std::ostream &amp;out, std::vector&lt;T&gt; <span class=\"hljs-keyword\">const</span> &amp;v) {\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> width = <span class=\"hljs-number\">15</span>;\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> separator = <span class=\"hljs-string\">&#x27; &#x27;</span>;\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row = <span class=\"hljs-number\">0</span>; row &lt; v.<span class=\"hljs-built_in\">size</span>(); row++) {\n        out &lt;&lt; std::left &lt;&lt; std::<span class=\"hljs-built_in\">setw</span>(width) &lt;&lt; std::<span class=\"hljs-built_in\">setfill</span>(separator)\n            &lt;&lt; v[row];\n    }\n\n    <span class=\"hljs-keyword\">return</span> out;\n}\n\n<span class=\"hljs-comment\">/**\n * function to check if given matrix is a square matrix\n * \\returns 1 if true, 0 if false\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">is_square</span><span class=\"hljs-params\">(std::vector&lt;std::vector&lt;T&gt;&gt; <span class=\"hljs-keyword\">const</span> &amp;A)</span> </span>{\n    <span class=\"hljs-comment\">// Assuming A is square matrix</span>\n    <span class=\"hljs-type\">size_t</span> N = A.<span class=\"hljs-built_in\">size</span>();\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n        <span class=\"hljs-keyword\">if</span> (A[i].<span class=\"hljs-built_in\">size</span>() != N) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * Matrix multiplication such that if A is size (mxn) and\n * B is of size (pxq) then the multiplication is defined\n * only when n = p and the resultant matrix is of size (mxq)\n *\n * \\returns resultant matrix\n **/</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::vector&lt;std::vector&lt;T&gt;&gt; <span class=\"hljs-keyword\">operator</span>*(std::vector&lt;std::vector&lt;T&gt;&gt; <span class=\"hljs-keyword\">const</span> &amp;A,\n                                      std::vector&lt;std::vector&lt;T&gt;&gt; <span class=\"hljs-keyword\">const</span> &amp;B) {\n    <span class=\"hljs-comment\">// Number of rows in A</span>\n    <span class=\"hljs-type\">size_t</span> N_A = A.<span class=\"hljs-built_in\">size</span>();\n    <span class=\"hljs-comment\">// Number of columns in B</span>\n    <span class=\"hljs-type\">size_t</span> N_B = B[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>();\n\n    std::vector&lt;std::vector&lt;T&gt;&gt; <span class=\"hljs-built_in\">result</span>(N_A);\n\n    <span class=\"hljs-keyword\">if</span> (A[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>() != B.<span class=\"hljs-built_in\">size</span>()) {\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;Number of columns in A != Number of rows in B (&quot;</span>\n                  &lt;&lt; A[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>() &lt;&lt; <span class=\"hljs-string\">&quot;, &quot;</span> &lt;&lt; B.<span class=\"hljs-built_in\">size</span>() &lt;&lt; <span class=\"hljs-string\">&quot;)&quot;</span> &lt;&lt; std::endl;\n        <span class=\"hljs-keyword\">return</span> result;\n    }\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row = <span class=\"hljs-number\">0</span>; row &lt; N_A; row++) {\n        <span class=\"hljs-function\">std::vector&lt;T&gt; <span class=\"hljs-title\">v</span><span class=\"hljs-params\">(N_B)</span></span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> col = <span class=\"hljs-number\">0</span>; col &lt; N_B; col++) {\n            v[col] = <span class=\"hljs-built_in\">static_cast</span>&lt;T&gt;(<span class=\"hljs-number\">0</span>);\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; B.<span class=\"hljs-built_in\">size</span>(); j++) {\n                v[col] += A[row][j] * B[j][col];\n            }\n        }\n        result[row] = v;\n    }\n\n    <span class=\"hljs-keyword\">return</span> result;\n}\n\n<span class=\"hljs-comment\">/**\n * multiplication of a matrix with a column vector\n * \\returns resultant vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::vector&lt;T&gt; <span class=\"hljs-keyword\">operator</span>*(std::vector&lt;std::vector&lt;T&gt;&gt; <span class=\"hljs-keyword\">const</span> &amp;A,\n                         std::vector&lt;T&gt; <span class=\"hljs-keyword\">const</span> &amp;B) {\n    <span class=\"hljs-comment\">// Number of rows in A</span>\n    <span class=\"hljs-type\">size_t</span> N_A = A.<span class=\"hljs-built_in\">size</span>();\n\n    <span class=\"hljs-function\">std::vector&lt;T&gt; <span class=\"hljs-title\">result</span><span class=\"hljs-params\">(N_A)</span></span>;\n\n    <span class=\"hljs-keyword\">if</span> (A[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>() != B.<span class=\"hljs-built_in\">size</span>()) {\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;Number of columns in A != Number of rows in B (&quot;</span>\n                  &lt;&lt; A[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>() &lt;&lt; <span class=\"hljs-string\">&quot;, &quot;</span> &lt;&lt; B.<span class=\"hljs-built_in\">size</span>() &lt;&lt; <span class=\"hljs-string\">&quot;)&quot;</span> &lt;&lt; std::endl;\n        <span class=\"hljs-keyword\">return</span> result;\n    }\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row = <span class=\"hljs-number\">0</span>; row &lt; N_A; row++) {\n        result[row] = <span class=\"hljs-built_in\">static_cast</span>&lt;T&gt;(<span class=\"hljs-number\">0</span>);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; B.<span class=\"hljs-built_in\">size</span>(); j++) result[row] += A[row][j] * B[j];\n    }\n\n    <span class=\"hljs-keyword\">return</span> result;\n}\n\n<span class=\"hljs-comment\">/**\n * pre-multiplication of a vector by a scalar\n * \\returns resultant vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::vector&lt;<span class=\"hljs-type\">float</span>&gt; <span class=\"hljs-keyword\">operator</span>*(<span class=\"hljs-type\">float</span> <span class=\"hljs-keyword\">const</span> scalar, std::vector&lt;T&gt; <span class=\"hljs-keyword\">const</span> &amp;A) {\n    <span class=\"hljs-comment\">// Number of rows in A</span>\n    <span class=\"hljs-type\">size_t</span> N_A = A.<span class=\"hljs-built_in\">size</span>();\n\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">float</span>&gt; <span class=\"hljs-title\">result</span><span class=\"hljs-params\">(N_A)</span></span>;\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row = <span class=\"hljs-number\">0</span>; row &lt; N_A; row++) {\n        result[row] += A[row] * <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">float</span>&gt;(scalar);\n    }\n\n    <span class=\"hljs-keyword\">return</span> result;\n}\n\n<span class=\"hljs-comment\">/**\n * post-multiplication of a vector by a scalar\n * \\returns resultant vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::vector&lt;<span class=\"hljs-type\">float</span>&gt; <span class=\"hljs-keyword\">operator</span>*(std::vector&lt;T&gt; <span class=\"hljs-keyword\">const</span> &amp;A, <span class=\"hljs-type\">float</span> <span class=\"hljs-keyword\">const</span> scalar) {\n    <span class=\"hljs-comment\">// Number of rows in A</span>\n    <span class=\"hljs-type\">size_t</span> N_A = A.<span class=\"hljs-built_in\">size</span>();\n\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">float</span>&gt; <span class=\"hljs-title\">result</span><span class=\"hljs-params\">(N_A)</span></span>;\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row = <span class=\"hljs-number\">0</span>; row &lt; N_A; row++) {\n        result[row] = A[row] * <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">float</span>&gt;(scalar);\n    }\n\n    <span class=\"hljs-keyword\">return</span> result;\n}\n\n<span class=\"hljs-comment\">/**\n * division of a vector by a scalar\n * \\returns resultant vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::vector&lt;<span class=\"hljs-type\">float</span>&gt; <span class=\"hljs-keyword\">operator</span>/(std::vector&lt;T&gt; <span class=\"hljs-keyword\">const</span> &amp;A, <span class=\"hljs-type\">float</span> <span class=\"hljs-keyword\">const</span> scalar) {\n    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">1.f</span> / scalar) * A;\n}\n\n<span class=\"hljs-comment\">/**\n * subtraction of two vectors of identical lengths\n * \\returns resultant vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::vector&lt;T&gt; <span class=\"hljs-keyword\">operator</span>-(std::vector&lt;T&gt; <span class=\"hljs-keyword\">const</span> &amp;A, std::vector&lt;T&gt; <span class=\"hljs-keyword\">const</span> &amp;B) {\n    <span class=\"hljs-comment\">// Number of rows in A</span>\n    <span class=\"hljs-type\">size_t</span> N = A.<span class=\"hljs-built_in\">size</span>();\n\n    <span class=\"hljs-function\">std::vector&lt;T&gt; <span class=\"hljs-title\">result</span><span class=\"hljs-params\">(N)</span></span>;\n\n    <span class=\"hljs-keyword\">if</span> (B.<span class=\"hljs-built_in\">size</span>() != N) {\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;Vector dimensions shouldbe identical!&quot;</span> &lt;&lt; std::endl;\n        <span class=\"hljs-keyword\">return</span> A;\n    }\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row = <span class=\"hljs-number\">0</span>; row &lt; N; row++) result[row] = A[row] - B[row];\n\n    <span class=\"hljs-keyword\">return</span> result;\n}\n\n<span class=\"hljs-comment\">/**\n * addition of two vectors of identical lengths\n * \\returns resultant vector\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::vector&lt;T&gt; <span class=\"hljs-keyword\">operator</span>+(std::vector&lt;T&gt; <span class=\"hljs-keyword\">const</span> &amp;A, std::vector&lt;T&gt; <span class=\"hljs-keyword\">const</span> &amp;B) {\n    <span class=\"hljs-comment\">// Number of rows in A</span>\n    <span class=\"hljs-type\">size_t</span> N = A.<span class=\"hljs-built_in\">size</span>();\n\n    <span class=\"hljs-function\">std::vector&lt;T&gt; <span class=\"hljs-title\">result</span><span class=\"hljs-params\">(N)</span></span>;\n\n    <span class=\"hljs-keyword\">if</span> (B.<span class=\"hljs-built_in\">size</span>() != N) {\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;Vector dimensions shouldbe identical!&quot;</span> &lt;&lt; std::endl;\n        <span class=\"hljs-keyword\">return</span> A;\n    }\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row = <span class=\"hljs-number\">0</span>; row &lt; N; row++) result[row] = A[row] + B[row];\n\n    <span class=\"hljs-keyword\">return</span> result;\n}\n\n<span class=\"hljs-comment\">/**\n * Get matrix inverse using Row-trasnformations. Given matrix must\n * be a square and non-singular.\n * \\returns inverse matrix\n **/</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::vector&lt;std::vector&lt;<span class=\"hljs-type\">float</span>&gt;&gt; <span class=\"hljs-built_in\">get_inverse</span>(\n    std::vector&lt;std::vector&lt;T&gt;&gt; <span class=\"hljs-keyword\">const</span> &amp;A) {\n    <span class=\"hljs-comment\">// Assuming A is square matrix</span>\n    <span class=\"hljs-type\">size_t</span> N = A.<span class=\"hljs-built_in\">size</span>();\n\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">float</span>&gt;&gt; <span class=\"hljs-built_in\">inverse</span>(N);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row = <span class=\"hljs-number\">0</span>; row &lt; N; row++) {\n        <span class=\"hljs-comment\">// preallocatae a resultant identity matrix</span>\n        inverse[row] = std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">float</span>&gt;(N);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> col = <span class=\"hljs-number\">0</span>; col &lt; N; col++) {\n            inverse[row][col] = (row == col) ? <span class=\"hljs-number\">1.f</span> : <span class=\"hljs-number\">0.f</span>;\n        }\n    }\n\n    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">is_square</span>(A)) {\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;A must be a square matrix!&quot;</span> &lt;&lt; std::endl;\n        <span class=\"hljs-keyword\">return</span> inverse;\n    }\n\n    <span class=\"hljs-comment\">// preallocatae a temporary matrix identical to A</span>\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">float</span>&gt;&gt; <span class=\"hljs-built_in\">temp</span>(N);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row = <span class=\"hljs-number\">0</span>; row &lt; N; row++) {\n        <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">float</span>&gt; <span class=\"hljs-title\">v</span><span class=\"hljs-params\">(N)</span></span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> col = <span class=\"hljs-number\">0</span>; col &lt; N; col++) {\n            v[col] = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">float</span>&gt;(A[row][col]);\n        }\n        temp[row] = v;\n    }\n\n    <span class=\"hljs-comment\">// start transformations</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row = <span class=\"hljs-number\">0</span>; row &lt; N; row++) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row2 = row; row2 &lt; N &amp;&amp; temp[row][row] == <span class=\"hljs-number\">0</span>; row2++) {\n            <span class=\"hljs-comment\">// this to ensure diagonal elements are not 0</span>\n            temp[row] = temp[row] + temp[row2];\n            inverse[row] = inverse[row] + inverse[row2];\n        }\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> col2 = row; col2 &lt; N &amp;&amp; temp[row][row] == <span class=\"hljs-number\">0</span>; col2++) {\n            <span class=\"hljs-comment\">// this to further ensure diagonal elements are not 0</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row2 = <span class=\"hljs-number\">0</span>; row2 &lt; N; row2++) {\n                temp[row2][row] = temp[row2][row] + temp[row2][col2];\n                inverse[row2][row] = inverse[row2][row] + inverse[row2][col2];\n            }\n        }\n\n        <span class=\"hljs-keyword\">if</span> (temp[row][row] == <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-comment\">// Probably a low-rank matrix and hence singular</span>\n            std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;Low-rank matrix, no inverse!&quot;</span> &lt;&lt; std::endl;\n            <span class=\"hljs-keyword\">return</span> inverse;\n        }\n\n        <span class=\"hljs-comment\">// set diagonal to 1</span>\n        <span class=\"hljs-keyword\">auto</span> divisor = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">float</span>&gt;(temp[row][row]);\n        temp[row] = temp[row] / divisor;\n        inverse[row] = inverse[row] / divisor;\n        <span class=\"hljs-comment\">// Row transformations</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row2 = <span class=\"hljs-number\">0</span>; row2 &lt; N; row2++) {\n            <span class=\"hljs-keyword\">if</span> (row2 == row) {\n                <span class=\"hljs-keyword\">continue</span>;\n            }\n            <span class=\"hljs-type\">float</span> factor = temp[row2][row];\n            temp[row2] = temp[row2] - factor * temp[row];\n            inverse[row2] = inverse[row2] - factor * inverse[row];\n        }\n    }\n\n    <span class=\"hljs-keyword\">return</span> inverse;\n}\n\n<span class=\"hljs-comment\">/**\n * matrix transpose\n * \\returns resultant matrix\n **/</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\nstd::vector&lt;std::vector&lt;T&gt;&gt; <span class=\"hljs-built_in\">get_transpose</span>(\n    std::vector&lt;std::vector&lt;T&gt;&gt; <span class=\"hljs-keyword\">const</span> &amp;A) {\n    std::vector&lt;std::vector&lt;T&gt;&gt; <span class=\"hljs-built_in\">result</span>(A[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>());\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row = <span class=\"hljs-number\">0</span>; row &lt; A[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>(); row++) {\n        <span class=\"hljs-function\">std::vector&lt;T&gt; <span class=\"hljs-title\">v</span><span class=\"hljs-params\">(A.size())</span></span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> col = <span class=\"hljs-number\">0</span>; col &lt; A.<span class=\"hljs-built_in\">size</span>(); col++) v[col] = A[col][row];\n\n        result[row] = v;\n    }\n    <span class=\"hljs-keyword\">return</span> result;\n}\n\n<span class=\"hljs-comment\">/**\n * Perform Ordinary Least Squares curve fit. This operation is defined as\n * \\f[\\beta = \\left(X^TXX^T\\right)Y\\f]\n * \\param X feature matrix with rows representing sample vector of features\n * \\param Y known regression value for each sample\n * \\returns fitted regression model polynomial coefficients\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n<span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">float</span>&gt; <span class=\"hljs-title\">fit_OLS_regressor</span><span class=\"hljs-params\">(std::vector&lt;std::vector&lt;T&gt;&gt; <span class=\"hljs-keyword\">const</span> &amp;X,\n                                     std::vector&lt;T&gt; <span class=\"hljs-keyword\">const</span> &amp;Y)</span> </span>{\n    <span class=\"hljs-comment\">// NxF</span>\n    std::vector&lt;std::vector&lt;T&gt;&gt; X2 = X;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; X2.<span class=\"hljs-built_in\">size</span>(); i++) {\n        <span class=\"hljs-comment\">// add Y-intercept -&gt; Nx(F+1)</span>\n        X2[i].<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">1</span>);\n    }\n    <span class=\"hljs-comment\">// (F+1)xN</span>\n    std::vector&lt;std::vector&lt;T&gt;&gt; Xt = <span class=\"hljs-built_in\">get_transpose</span>(X2);\n    <span class=\"hljs-comment\">// (F+1)x(F+1)</span>\n    std::vector&lt;std::vector&lt;T&gt;&gt; tmp = <span class=\"hljs-built_in\">get_inverse</span>(Xt * X2);\n    <span class=\"hljs-comment\">// (F+1)xN</span>\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">float</span>&gt;&gt; out = tmp * Xt;\n    <span class=\"hljs-comment\">// cout &lt;&lt; endl</span>\n    <span class=\"hljs-comment\">//      &lt;&lt; &quot;Projection matrix: &quot; &lt;&lt; X2 * out &lt;&lt; endl;</span>\n\n    <span class=\"hljs-comment\">// Fx1,1    -&gt; (F+1)^th element is the independent constant</span>\n    <span class=\"hljs-keyword\">return</span> out * Y;\n}\n\n<span class=\"hljs-comment\">/**\n * Given data and OLS model coeffficients, predict\n * regression estimates. This operation is defined as\n * \\f[y_{\\text{row}=i} = \\sum_{j=\\text{columns}}\\beta_j\\cdot X_{i,j}\\f]\n *\n * \\param X feature matrix with rows representing sample vector of features\n * \\param beta fitted regression model\n * \\return vector with regression values for each sample\n **/</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n<span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">float</span>&gt; <span class=\"hljs-title\">predict_OLS_regressor</span><span class=\"hljs-params\">(std::vector&lt;std::vector&lt;T&gt;&gt; <span class=\"hljs-keyword\">const</span> &amp;X,\n                                         std::vector&lt;<span class=\"hljs-type\">float</span>&gt; <span class=\"hljs-keyword\">const</span> &amp;beta <span class=\"hljs-comment\">/**&lt; */</span>\n)</span> </span>{\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">float</span>&gt; <span class=\"hljs-title\">result</span><span class=\"hljs-params\">(X.size())</span></span>;\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> rows = <span class=\"hljs-number\">0</span>; rows &lt; X.<span class=\"hljs-built_in\">size</span>(); rows++) {\n        <span class=\"hljs-comment\">// -&gt; start with constant term</span>\n        result[rows] = beta[X[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>()];\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> cols = <span class=\"hljs-number\">0</span>; cols &lt; X[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>(); cols++) {\n            result[rows] += beta[cols] * X[rows][cols];\n        }\n    }\n    <span class=\"hljs-comment\">// Nx1</span>\n    <span class=\"hljs-keyword\">return</span> result;\n}\n\n<span class=\"hljs-comment\">/** Self test checks */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ols_test</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-type\">int</span> F = <span class=\"hljs-number\">3</span>, N = <span class=\"hljs-number\">5</span>;\n\n    <span class=\"hljs-comment\">/* test function = x^2 -5 */</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 1 (quadratic function)....&quot;</span>;\n    <span class=\"hljs-comment\">// create training data set with features = x, x^2, x^3</span>\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">float</span>&gt;&gt; <span class=\"hljs-built_in\">data1</span>(\n        {{<span class=\"hljs-number\">-5</span>, <span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">-125</span>}, {<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>}, {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>}, {<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">36</span>, <span class=\"hljs-number\">216</span>}});\n    <span class=\"hljs-comment\">// create corresponding outputs</span>\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">float</span>&gt; <span class=\"hljs-title\">Y1</span><span class=\"hljs-params\">({<span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">-4</span>, <span class=\"hljs-number\">-5</span>, <span class=\"hljs-number\">-4</span>, <span class=\"hljs-number\">31</span>})</span></span>;\n    <span class=\"hljs-comment\">// perform regression modelling</span>\n    std::vector&lt;<span class=\"hljs-type\">float</span>&gt; beta1 = <span class=\"hljs-built_in\">fit_OLS_regressor</span>(data1, Y1);\n    <span class=\"hljs-comment\">// create test data set with same features = x, x^2, x^3</span>\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">float</span>&gt;&gt; <span class=\"hljs-built_in\">test_data1</span>(\n        {{<span class=\"hljs-number\">-2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">-8</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">8</span>}, {<span class=\"hljs-number\">-10</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">-1000</span>}, {<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">1000</span>}});\n    <span class=\"hljs-comment\">// expected regression outputs</span>\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">float</span>&gt; <span class=\"hljs-title\">expected1</span><span class=\"hljs-params\">({<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">95</span>, <span class=\"hljs-number\">95</span>})</span></span>;\n    <span class=\"hljs-comment\">// predicted regression outputs</span>\n    std::vector&lt;<span class=\"hljs-type\">float</span>&gt; out1 = <span class=\"hljs-built_in\">predict_OLS_regressor</span>(test_data1, beta1);\n    <span class=\"hljs-comment\">// compare predicted results are within +-0.01 limit of expected</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> rows = <span class=\"hljs-number\">0</span>; rows &lt; out1.<span class=\"hljs-built_in\">size</span>(); rows++) {\n        <span class=\"hljs-built_in\">assert</span>(std::<span class=\"hljs-built_in\">abs</span>(out1[rows] - expected1[rows]) &lt; <span class=\"hljs-number\">0.01</span>);\n    }\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;passed\\n&quot;</span>;\n\n    <span class=\"hljs-comment\">/* test function = x^3 + x^2 - 100 */</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 2 (cubic function)....&quot;</span>;\n    <span class=\"hljs-comment\">// create training data set with features = x, x^2, x^3</span>\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">float</span>&gt;&gt; <span class=\"hljs-built_in\">data2</span>(\n        {{<span class=\"hljs-number\">-5</span>, <span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">-125</span>}, {<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>}, {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>}, {<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">36</span>, <span class=\"hljs-number\">216</span>}});\n    <span class=\"hljs-comment\">// create corresponding outputs</span>\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">float</span>&gt; <span class=\"hljs-title\">Y2</span><span class=\"hljs-params\">({<span class=\"hljs-number\">-200</span>, <span class=\"hljs-number\">-100</span>, <span class=\"hljs-number\">-100</span>, <span class=\"hljs-number\">98</span>, <span class=\"hljs-number\">152</span>})</span></span>;\n    <span class=\"hljs-comment\">// perform regression modelling</span>\n    std::vector&lt;<span class=\"hljs-type\">float</span>&gt; beta2 = <span class=\"hljs-built_in\">fit_OLS_regressor</span>(data2, Y2);\n    <span class=\"hljs-comment\">// create test data set with same features = x, x^2, x^3</span>\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">float</span>&gt;&gt; <span class=\"hljs-built_in\">test_data2</span>(\n        {{<span class=\"hljs-number\">-2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">-8</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">8</span>}, {<span class=\"hljs-number\">-10</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">-1000</span>}, {<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">1000</span>}});\n    <span class=\"hljs-comment\">// expected regression outputs</span>\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">float</span>&gt; <span class=\"hljs-title\">expected2</span><span class=\"hljs-params\">({<span class=\"hljs-number\">-104</span>, <span class=\"hljs-number\">-88</span>, <span class=\"hljs-number\">-1000</span>, <span class=\"hljs-number\">1000</span>})</span></span>;\n    <span class=\"hljs-comment\">// predicted regression outputs</span>\n    std::vector&lt;<span class=\"hljs-type\">float</span>&gt; out2 = <span class=\"hljs-built_in\">predict_OLS_regressor</span>(test_data2, beta2);\n    <span class=\"hljs-comment\">// compare predicted results are within +-0.01 limit of expected</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> rows = <span class=\"hljs-number\">0</span>; rows &lt; out2.<span class=\"hljs-built_in\">size</span>(); rows++) {\n        <span class=\"hljs-built_in\">assert</span>(std::<span class=\"hljs-built_in\">abs</span>(out2[rows] - expected2[rows]) &lt; <span class=\"hljs-number\">0.01</span>);\n    }\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;passed\\n&quot;</span>;\n\n    std::cout &lt;&lt; std::endl;  <span class=\"hljs-comment\">// ensure test results are displayed on screen</span>\n                             <span class=\"hljs-comment\">// (flush stdout)</span>\n}\n\n<span class=\"hljs-comment\">/**\n * main function\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">ols_test</span>();\n\n    <span class=\"hljs-type\">size_t</span> N = <span class=\"hljs-number\">0</span>, F = <span class=\"hljs-number\">0</span>;\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter number of features: &quot;</span>;\n    <span class=\"hljs-comment\">// number of features = columns</span>\n    std::cin &gt;&gt; F;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter number of samples: &quot;</span>;\n    <span class=\"hljs-comment\">// number of samples = rows</span>\n    std::cin &gt;&gt; N;\n\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">float</span>&gt;&gt; <span class=\"hljs-built_in\">data</span>(N);\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">float</span>&gt; <span class=\"hljs-title\">Y</span><span class=\"hljs-params\">(N)</span></span>;\n\n    std::cout\n        &lt;&lt; <span class=\"hljs-string\">&quot;Enter training data. Per sample, provide features and one output.&quot;</span>\n        &lt;&lt; std::endl;\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> rows = <span class=\"hljs-number\">0</span>; rows &lt; N; rows++) {\n        <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">float</span>&gt; <span class=\"hljs-title\">v</span><span class=\"hljs-params\">(F)</span></span>;\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Sample# &quot;</span> &lt;&lt; rows + <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-string\">&quot;: &quot;</span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> cols = <span class=\"hljs-number\">0</span>; cols &lt; F; cols++) {\n            <span class=\"hljs-comment\">// get the F features</span>\n            std::cin &gt;&gt; v[cols];\n        }\n        data[rows] = v;\n        <span class=\"hljs-comment\">// get the corresponding output</span>\n        std::cin &gt;&gt; Y[rows];\n    }\n\n    std::vector&lt;<span class=\"hljs-type\">float</span>&gt; beta = <span class=\"hljs-built_in\">fit_OLS_regressor</span>(data, Y);\n    std::cout &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; <span class=\"hljs-string\">&quot;beta:&quot;</span> &lt;&lt; beta &lt;&lt; std::endl;\n\n    <span class=\"hljs-type\">size_t</span> T = <span class=\"hljs-number\">0</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter number of test samples: &quot;</span>;\n    <span class=\"hljs-comment\">// number of test sample inputs</span>\n    std::cin &gt;&gt; T;\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">float</span>&gt;&gt; <span class=\"hljs-built_in\">data2</span>(T);\n    <span class=\"hljs-comment\">// vector&lt;float&gt; Y2(T);</span>\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> rows = <span class=\"hljs-number\">0</span>; rows &lt; T; rows++) {\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Sample# &quot;</span> &lt;&lt; rows + <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-string\">&quot;: &quot;</span>;\n        <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">float</span>&gt; <span class=\"hljs-title\">v</span><span class=\"hljs-params\">(F)</span></span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> cols = <span class=\"hljs-number\">0</span>; cols &lt; F; cols++) std::cin &gt;&gt; v[cols];\n        data2[rows] = v;\n    }\n\n    std::vector&lt;<span class=\"hljs-type\">float</span>&gt; out = <span class=\"hljs-built_in\">predict_OLS_regressor</span>(data2, beta);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> rows = <span class=\"hljs-number\">0</span>; rows &lt; T; rows++) std::cout &lt;&lt; out[rows] &lt;&lt; std::endl;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "David Leal",
      "email": "halfpacho@gmail.com",
      "commits": 1
    },
    {
      "name": "Krishna Vedala",
      "email": "krishna.vedala@ieee.org",
      "commits": 2
    },
    {
      "name": "Ayaan Khan",
      "email": "ayaankhan98@gmail.com",
      "commits": 3
    },
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 10
    }
  ],
  "explanationUrl": {}
}
