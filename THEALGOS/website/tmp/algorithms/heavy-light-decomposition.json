{
  "slug": "heavy-light-decomposition",
  "name": "Heavy Light Decomposition",
  "categories": ["rangequeries"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "range_queries/heavy_light_decomposition.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/range_queries/heavy_light_decomposition.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * @brief [Heavy Light\n * Decomposition](https://en.wikipedia.org/wiki/Heavy_path_decomposition)\n * implementation\n * @author [Aniruthan R](https://github.com/aneee004)\n *\n * @details\n * Heavy-Light Decomposition is a technique on trees, that supports the\n * following:\n * 1. Update node s, with a value v\n * 2. Return the (sum) of all node values on the simple path from a to b\n * (sum) can also be replced with XOR, OR, AND, min, or max\n *\n * The update is done in O(log n) time, and\n * the query is done in O(log^2 n) time with HLD\n * where, n is the number of nodes\n *\n * The template type is the data type of the value stored in the nodes.\n * If a non-primitive data-type is used as a template,\n * the coressponding operators must be overloaded.\n *\n * An HLD object can only be created with a constant number of nodes, and\n * it cannot be changed later. Creaty an empty instance is not supported.\n *\n * To start answering updates and queries,\n * 1. Create an instance of HLD&lt;X&gt; object (obj), with the required data type.\n * 2. Read in the edge/parent information and update it with obj.add_edge().\n * Note: The edges addes must be 0 indexed.\n * 3. Create a vector with initial node values, and call set_node_val() with it.\n * 4. Call obj.init() to populate the required information for supporting\n * operations.\n * 5. Call obj.update(node, new_val), to update the value at index &#x27;node&#x27; to the\n * new value. Note: node must be 0 indexed\n * 6. Call obj.query(a, b) to get the (sum) of node values in the simple path\n * from a to b. Note: a and b, must be 0 indexed.\n *\n * Sample I/O at the bottom.\n * @todo Support edge weight queries, by storing the edge weight value in it&#x27;s\n * child algorithm verified by testing in CSES path queries:\n * https://cses.fi/problemset/task/1138\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstring&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;list&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;numeric&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\n\n<span class=\"hljs-comment\">/**\n * @namespace range_queries\n * @brief Algorithms and Data Structures that support range queries and updates.\n */</span>\n<span class=\"hljs-keyword\">namespace</span> range_queries {\n<span class=\"hljs-comment\">/**\n * @namespace heavy_light_decomposition\n * @brief Heavy light decomposition algorithm\n */</span>\n<span class=\"hljs-keyword\">namespace</span> heavy_light_decomposition {\n<span class=\"hljs-comment\">/**\n * @brief A Basic Tree, which supports binary lifting\n * @tparam the data type of the values stored in the tree nodes\n * @details Deleting the default constructor\n * An instance can only be created with the number of nodes\n * Defaults:\n * t_node indexing are zero based\n * t_root is 0\n * depth of root_node is 0\n * Supports:\n * lift :- lift a node k units up the tree\n * kth_ancestor :- returns the kth ancestor\n * lca :- returns the least common ancestor\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> X&gt; <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Tree</span> {\n  <span class=\"hljs-comment\">//</span>\n\n<span class=\"hljs-keyword\">private</span>:\n  std::vector&lt;std::list&lt;<span class=\"hljs-type\">int</span>&gt;&gt;\n      t_adj;         <span class=\"hljs-comment\">///&lt; an adjacency list to stores the tree edges</span>\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> t_nodes, <span class=\"hljs-comment\">///&lt; number of nodes</span>\n      t_maxlift;     <span class=\"hljs-comment\">///&lt; maximum possible height of the tree</span>\n  std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt;\n      t_par;                <span class=\"hljs-comment\">///&lt; a matrix to store every node&#x27;s 2^kth parent</span>\n  std::vector&lt;<span class=\"hljs-type\">int</span>&gt; t_depth, <span class=\"hljs-comment\">///&lt; a vector to store the depth of a node,</span>\n      t_size; <span class=\"hljs-comment\">///&lt; a vector to store the subtree size rooted at node</span>\n\n  <span class=\"hljs-type\">int</span> t_root;           <span class=\"hljs-comment\">///&lt; the root of the tree</span>\n  std::vector&lt;X&gt; t_val; <span class=\"hljs-comment\">///&lt; values of nodes</span>\n  <span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt; <span class=\"hljs-keyword\">friend</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HLD</span>;\n\n  <span class=\"hljs-comment\">/**\n   * @brief Utility function to compute sub-tree sizes\n   * @param u current dfs node\n   * @param p the parent of node @param u\n   * @returns void\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs_size</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u, <span class=\"hljs-type\">int</span> p = <span class=\"hljs-number\">-1</span>)</span> </span>{\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> &amp;v : t_adj[u]) {\n      <span class=\"hljs-keyword\">if</span> (v ^ p) {\n        <span class=\"hljs-built_in\">dfs_size</span>(v, u);\n        t_size[u] += t_size[v];\n      }\n    }\n  }\n\n  <span class=\"hljs-comment\">/**\n   * @brief Utility function to populate the t_par vector\n   * @param u current dfs node\n   * @param p the parent of node u\n   * @returns void\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs_lca</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u, <span class=\"hljs-type\">int</span> p = <span class=\"hljs-number\">-1</span>)</span> </span>{\n    t_par[u][<span class=\"hljs-number\">0</span>] = p;\n    <span class=\"hljs-keyword\">if</span> (p != <span class=\"hljs-number\">-1</span>) {\n      t_depth[u] = <span class=\"hljs-number\">1</span> + t_depth[p];\n    }\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">1</span>; k &lt; t_maxlift; k++) {\n      <span class=\"hljs-keyword\">if</span> (t_par[u][k - <span class=\"hljs-number\">1</span>] != <span class=\"hljs-number\">-1</span>) {\n        t_par[u][k] = t_par[t_par[u][k - <span class=\"hljs-number\">1</span>]][k - <span class=\"hljs-number\">1</span>];\n      }\n    }\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> &amp;v : t_adj[u]) {\n      <span class=\"hljs-keyword\">if</span> (v ^ p) {\n        <span class=\"hljs-built_in\">dfs_lca</span>(v, u);\n      }\n    }\n  }\n\n<span class=\"hljs-keyword\">public</span>:\n  <span class=\"hljs-comment\">/**\n   * @brief Class parameterized constructor, resizes the and initializes the\n   * data members\n   * @param nodes the total number of nodes in the tree\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">Tree</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> nodes)</span>\n      : t_nodes(nodes), t_maxlift(static_cast&lt;int&gt;(floor(log2(nodes))) + <span class=\"hljs-number\">1</span>) {</span>\n    <span class=\"hljs-comment\">/* Initialize and resize all the vectors */</span>\n    t_root = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">/* Default */</span>\n    t_adj.<span class=\"hljs-built_in\">resize</span>(t_nodes);\n    t_par.<span class=\"hljs-built_in\">assign</span>(t_nodes, std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(t_maxlift, <span class=\"hljs-number\">-1</span>));\n    t_depth.<span class=\"hljs-built_in\">assign</span>(t_nodes, <span class=\"hljs-number\">0</span>);\n    t_size.<span class=\"hljs-built_in\">assign</span>(t_nodes, <span class=\"hljs-number\">1</span>);\n    t_val.<span class=\"hljs-built_in\">resize</span>(t_nodes);\n  }\n\n  <span class=\"hljs-comment\">/**\n   * @brief Adds an undirected edge from node u to node v in the tree\n   * @param u the node where the edge is from\n   * @param v the node where the edge is to\n   * @returns void\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">add_edge</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> u, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> v)</span> </span>{\n    t_adj[u].<span class=\"hljs-built_in\">push_back</span>(v);\n    t_adj[v].<span class=\"hljs-built_in\">push_back</span>(u);\n  }\n\n  <span class=\"hljs-comment\">/**\n   * @brief Set the root for the tree\n   * @param new_root the new root\n   * @returns void\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">change_root</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> new_root)</span> </span>{ t_root = new_root; }\n\n  <span class=\"hljs-comment\">/**\n   * @brief Set the values for all the nodes\n   * @param node_val a vector of size n, with all the node values where, n is\n   * the number of nodes\n   * @returns void\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_node_val</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::vector&lt;X&gt; &amp;node_val)</span> </span>{\n    <span class=\"hljs-built_in\">assert</span>(<span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(node_val.<span class=\"hljs-built_in\">size</span>()) == t_nodes);\n    t_val = node_val;\n  }\n\n  <span class=\"hljs-comment\">/**\n   * @brief This function must be called after the tree adjacency list and node\n   * values are populated The function initializes the required parameters, and\n   * populates the segment tree\n   * @returns void\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">assert</span>(t_nodes &gt; <span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-built_in\">dfs_size</span>(t_root);\n    <span class=\"hljs-built_in\">dfs_lca</span>(t_root);\n  }\n\n  <span class=\"hljs-comment\">/**\n   * @brief The function lifts a node, k units up the tree.\n   * The lifting is done in place, and the result is stored in the address\n   * pointed by p.\n   * @param p a pointer to the variable that stores the node id\n   * @param dist the distance to move up the tree\n   * @returns void\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">lift</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> *<span class=\"hljs-keyword\">const</span> p, <span class=\"hljs-type\">int</span> dist)</span> </span>{\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; t_maxlift; k++) {\n      <span class=\"hljs-keyword\">if</span> (*p == <span class=\"hljs-number\">-1</span>) {\n        <span class=\"hljs-keyword\">return</span>;\n      }\n      <span class=\"hljs-keyword\">if</span> (dist &amp; <span class=\"hljs-number\">1</span>) {\n        *p = t_par[*p][k];\n      }\n      dist &gt;&gt;= <span class=\"hljs-number\">1</span>;\n    }\n  }\n\n  <span class=\"hljs-comment\">/**\n   * @brief The function returns the kth ancestor of a node\n   * @param p the node id whose kth ancestor is to be found\n   * @param dist the distance to move up the tree\n   * @returns the kth ancestor of node\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">kth_ancestor</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> p, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> &amp;dist)</span> </span>{\n    <span class=\"hljs-built_in\">lift</span>(&amp;p, dist);\n    <span class=\"hljs-keyword\">return</span> p;\n  }\n\n  <span class=\"hljs-comment\">/**\n   * @brief The function returns the least common ancestor of two nodes\n   * @param a node id_1\n   * @param b node id_2\n   * @returns the least common ancestor of node a, and node b\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">lca</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>{\n    <span class=\"hljs-built_in\">assert</span>(a &gt;= <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> b &gt;= <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> a &lt; t_nodes <span class=\"hljs-keyword\">and</span> b &lt; t_nodes);\n    <span class=\"hljs-keyword\">if</span> (t_depth[a] &gt; t_depth[b]) {\n      <span class=\"hljs-built_in\">lift</span>(&amp;a, t_depth[a] - t_depth[b]);\n    }\n    <span class=\"hljs-keyword\">if</span> (t_depth[b] &gt; t_depth[a]) {\n      <span class=\"hljs-built_in\">lift</span>(&amp;b, t_depth[b] - t_depth[a]);\n    }\n    <span class=\"hljs-keyword\">if</span> (a == b) {\n      <span class=\"hljs-keyword\">return</span> a;\n    }\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = t_maxlift - <span class=\"hljs-number\">1</span>; k &gt;= <span class=\"hljs-number\">0</span>; k--) {\n      <span class=\"hljs-keyword\">if</span> (t_par[a][k] != t_par[b][k]) {\n        a = t_par[a][k];\n        b = t_par[b][k];\n      }\n    }\n    <span class=\"hljs-keyword\">return</span> t_par[a][<span class=\"hljs-number\">0</span>];\n  }\n};\n\n<span class=\"hljs-comment\">/**\n * @brief Segment Tree, to store heavy chains\n * @tparam the data type of the values stored in the tree nodes\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> X&gt; <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SG</span> {\n<span class=\"hljs-keyword\">private</span>:\n  <span class=\"hljs-comment\">/**\n   * @brief Everything here is private,\n   * and can only be accessed through the methods,\n   * in the derived class (HLD)\n   */</span>\n\n  std::vector&lt;X&gt; s_tree; <span class=\"hljs-comment\">///&lt; the segment tree, stored as a vector</span>\n  <span class=\"hljs-type\">int</span> s_size;            <span class=\"hljs-comment\">///&lt; number of leaves in the segment tree</span>\n  X sret_init = <span class=\"hljs-number\">0</span>;       <span class=\"hljs-comment\">///&lt; inital query return value</span>\n  <span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt; <span class=\"hljs-keyword\">friend</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HLD</span>;\n\n  <span class=\"hljs-comment\">/**\n   * @brief Function that specifies the type of operation involved when segments\n   * are combined\n   * @param lhs the left segment\n   * @param rhs the right segment\n   * @returns the combined result\n   */</span>\n  <span class=\"hljs-function\">X <span class=\"hljs-title\">combine</span><span class=\"hljs-params\">(X lhs, X rhs)</span> </span>{ <span class=\"hljs-keyword\">return</span> lhs + rhs; }\n\n  <span class=\"hljs-comment\">/**\n   * @brief Class parameterized constructor. Resizes the and initilizes the data\n   * members.\n   * @param nodes the total number of nodes in the tree\n   * @returns void\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">SG</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> size)</span> </span>{\n    s_size = size;\n    s_tree.<span class=\"hljs-built_in\">assign</span>(<span class=\"hljs-number\">2</span> * s_size, <span class=\"hljs-number\">0ll</span>);\n  }\n\n  <span class=\"hljs-comment\">/**\n   * @brief Update the value at a node\n   * @param p the node to be udpated\n   * @param v the update value\n   * @returns void\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">update</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> p, X v)</span> </span>{\n    <span class=\"hljs-keyword\">for</span> (p += s_size; p &gt; <span class=\"hljs-number\">0</span>; p &gt;&gt;= <span class=\"hljs-number\">1</span>) {\n      s_tree[p] += v;\n    }\n  }\n\n  <span class=\"hljs-comment\">/**\n   * @brief Make a range query from node label l to node label r\n   * @param l node label where the path starts\n   * @param r node label where the path ends\n   * @returns void\n   */</span>\n  <span class=\"hljs-function\">X <span class=\"hljs-title\">query</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> l, <span class=\"hljs-type\">int</span> r)</span> </span>{\n    X lhs = sret_init, rhs = sret_init;\n    <span class=\"hljs-keyword\">for</span> (l += s_size, r += s_size + <span class=\"hljs-number\">1</span>; l &lt; r; l &gt;&gt;= <span class=\"hljs-number\">1</span>, r &gt;&gt;= <span class=\"hljs-number\">1</span>) {\n      <span class=\"hljs-keyword\">if</span> (l &amp; <span class=\"hljs-number\">1</span>) {\n        lhs = <span class=\"hljs-built_in\">combine</span>(lhs, s_tree[l++]);\n      }\n      <span class=\"hljs-keyword\">if</span> (r &amp; <span class=\"hljs-number\">1</span>) {\n        rhs = <span class=\"hljs-built_in\">combine</span>(s_tree[--r], rhs);\n      }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">combine</span>(lhs, rhs);\n  }\n\n  <span class=\"hljs-comment\">/**\n   * @brief Set the initialization for the query data type, based on requirement\n   *\n   * @details\n   * Change the sret_init, based on requirement:\n   * * Sum Query: 0 (Default)\n   * * XOR Query: 0 (Default)\n   * * Min Query: Infinity\n   * * Max Query: -Infinity\n   * @param new_sret_init the new init\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_sret_init</span><span class=\"hljs-params\">(X new_sret_init)</span> </span>{ sret_init = new_sret_init; }\n};\n\n<span class=\"hljs-comment\">/**\n * @brief The Heavy-Light Decomposition class\n * @tparam the data type of the values stored in the tree nodes\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> X&gt; <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HLD</span> : <span class=\"hljs-keyword\">public</span> Tree&lt;X&gt;, <span class=\"hljs-keyword\">public</span> SG&lt;X&gt; {\n<span class=\"hljs-keyword\">private</span>:\n  <span class=\"hljs-type\">int</span> label;                <span class=\"hljs-comment\">///&lt; utility member to assign labels in dfs_labels()</span>\n  std::vector&lt;<span class=\"hljs-type\">int</span>&gt; h_label, <span class=\"hljs-comment\">///&lt; stores the label of a node</span>\n      h_heavychlid,         <span class=\"hljs-comment\">///&lt; stores the heavy child of a node</span>\n      h_parent;             <span class=\"hljs-comment\">///&lt; stores the top of the heavy chain from a node</span>\n\n  <span class=\"hljs-comment\">/**\n   * @brief Utility function to assign heavy child to each node (-1 for a leaf\n   * node)\n   * @param u current dfs node\n   * @param p the parent of node u\n   * @returns void\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs_hc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u, <span class=\"hljs-type\">int</span> p = <span class=\"hljs-number\">-1</span>)</span> </span>{\n    <span class=\"hljs-type\">int</span> hc_size = <span class=\"hljs-number\">-1</span>, hc_id = <span class=\"hljs-number\">-1</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> &amp;v : Tree&lt;X&gt;::t_adj[u]) {\n      <span class=\"hljs-keyword\">if</span> (v ^ p) {\n        <span class=\"hljs-built_in\">dfs_hc</span>(v, u);\n        <span class=\"hljs-keyword\">if</span> (Tree&lt;X&gt;::t_size[v] &gt; hc_size) {\n          hc_size = Tree&lt;X&gt;::t_size[v];\n          hc_id = v;\n        }\n      }\n    }\n    h_heavychlid[u] = hc_id;\n  }\n\n  <span class=\"hljs-comment\">/**\n   * @brief Utility function to assign highest parent that can be reached though\n   * heavy chains\n   * @param u current dfs node\n   * @param p the parent of node u\n   * @returns void\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs_par</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u, <span class=\"hljs-type\">int</span> p = <span class=\"hljs-number\">-1</span>)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (h_heavychlid[u] != <span class=\"hljs-number\">-1</span>) {\n      h_parent[h_heavychlid[u]] = h_parent[u];\n      <span class=\"hljs-built_in\">dfs_par</span>(h_heavychlid[u], u);\n    }\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> &amp;v : Tree&lt;X&gt;::t_adj[u]) {\n      <span class=\"hljs-keyword\">if</span> (v ^ p <span class=\"hljs-keyword\">and</span> v ^ h_heavychlid[u]) {\n        <span class=\"hljs-built_in\">dfs_par</span>(v, u);\n      }\n    }\n  }\n\n  <span class=\"hljs-comment\">/**\n   * @brief Utility function to lable the nodes so that heavy chains have a\n   * contigous lable\n   * @param u current dfs node\n   * @param p the parent of node u\n   * @returns void\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs_labels</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u, <span class=\"hljs-type\">int</span> p = <span class=\"hljs-number\">-1</span>)</span> </span>{\n    h_label[u] = label++;\n    <span class=\"hljs-keyword\">if</span> (h_heavychlid[u] != <span class=\"hljs-number\">-1</span>) {\n      <span class=\"hljs-built_in\">dfs_labels</span>(h_heavychlid[u], u);\n    }\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> &amp;v : Tree&lt;X&gt;::t_adj[u]) {\n      <span class=\"hljs-keyword\">if</span> (v ^ p <span class=\"hljs-keyword\">and</span> v ^ h_heavychlid[u]) {\n        <span class=\"hljs-built_in\">dfs_labels</span>(v, u);\n      }\n    }\n  }\n\n  <span class=\"hljs-comment\">/**\n   * @brief Utility function to break down a path query into two chain queries\n   * @param a node where the path starts\n   * @param b node where the path ends\n   * a and b must belong to a single root to leaf chain\n   * @returns the sum of ndoe values in the simple path from a to b\n   */</span>\n  <span class=\"hljs-function\">X <span class=\"hljs-title\">chain_query</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>{\n    X ret = SG&lt;X&gt;::sret_init;\n    <span class=\"hljs-keyword\">if</span> (Tree&lt;X&gt;::t_depth[a] &lt; Tree&lt;X&gt;::t_depth[b]) {\n      std::<span class=\"hljs-built_in\">swap</span>(a, b);\n    }\n    <span class=\"hljs-keyword\">while</span> (Tree&lt;X&gt;::t_depth[a] &gt;= Tree&lt;X&gt;::t_depth[b]) {\n      <span class=\"hljs-type\">int</span> l = h_label[h_parent[a]];\n      <span class=\"hljs-type\">int</span> r = h_label[a];\n      <span class=\"hljs-keyword\">if</span> (Tree&lt;X&gt;::t_depth[h_parent[a]] &lt; Tree&lt;X&gt;::t_depth[b]) {\n        l += Tree&lt;X&gt;::t_depth[b] - Tree&lt;X&gt;::t_depth[h_parent[a]];\n      }\n      ret = SG&lt;X&gt;::<span class=\"hljs-built_in\">combine</span>(ret, SG&lt;X&gt;::<span class=\"hljs-built_in\">query</span>(l, r));\n      a = Tree&lt;X&gt;::t_par[h_parent[a]][<span class=\"hljs-number\">0</span>];\n      <span class=\"hljs-keyword\">if</span> (a == <span class=\"hljs-number\">-1</span>) {\n        <span class=\"hljs-keyword\">break</span>;\n      }\n    }\n    <span class=\"hljs-keyword\">return</span> ret;\n  }\n\n<span class=\"hljs-keyword\">public</span>:\n  <span class=\"hljs-comment\">/**\n   * @brief Class parameterized constructor. Resizes the and initilizes the data\n   * members.\n   * @param nodes the total number of nodes in the tree\n   */</span>\n  <span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-built_in\">HLD</span>&lt;X&gt;(<span class=\"hljs-type\">int</span> nodes) : <span class=\"hljs-built_in\">Tree</span>&lt;X&gt;(nodes), <span class=\"hljs-built_in\">SG</span>&lt;X&gt;(nodes) {\n    <span class=\"hljs-comment\">/* Initialization and resize vectors */</span>\n    label = <span class=\"hljs-number\">0</span>;\n    h_label.<span class=\"hljs-built_in\">assign</span>(Tree&lt;X&gt;::t_nodes, <span class=\"hljs-number\">-1</span>);\n    h_heavychlid.<span class=\"hljs-built_in\">assign</span>(Tree&lt;X&gt;::t_nodes, <span class=\"hljs-number\">-1</span>);\n    h_parent.<span class=\"hljs-built_in\">resize</span>(Tree&lt;X&gt;::t_nodes);\n    <span class=\"hljs-built_in\">iota</span>(h_parent.<span class=\"hljs-built_in\">begin</span>(), h_parent.<span class=\"hljs-built_in\">end</span>(), <span class=\"hljs-number\">0</span>);\n  }\n\n  <span class=\"hljs-comment\">/**\n   * @brief This function must be called after the tree adjacency list and node\n   * values are populated The function initializes the required parametes, and\n   * populates the segment tree\n   * @returns void\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">()</span> </span>{\n    Tree&lt;X&gt;::<span class=\"hljs-built_in\">init</span>();\n\n    <span class=\"hljs-comment\">// Fill the heavy child, greatest parent, and labels</span>\n    label = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-built_in\">dfs_hc</span>(Tree&lt;X&gt;::t_root);\n    <span class=\"hljs-built_in\">dfs_par</span>(Tree&lt;X&gt;::t_root);\n    <span class=\"hljs-built_in\">dfs_labels</span>(Tree&lt;X&gt;::t_root);\n\n    <span class=\"hljs-comment\">// Segment Tree Initialization</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; Tree&lt;X&gt;::t_nodes; i++) {\n      SG&lt;X&gt;::s_tree[h_label[i] + Tree&lt;X&gt;::t_nodes] = Tree&lt;X&gt;::t_val[i];\n    }\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = Tree&lt;X&gt;::t_nodes - <span class=\"hljs-number\">1</span>; i &gt; <span class=\"hljs-number\">0</span>; i--) {\n      SG&lt;X&gt;::s_tree[i] =\n          SG&lt;X&gt;::<span class=\"hljs-built_in\">combine</span>(SG&lt;X&gt;::s_tree[i &lt;&lt; <span class=\"hljs-number\">1</span>], SG&lt;X&gt;::s_tree[i &lt;&lt; <span class=\"hljs-number\">1</span> | <span class=\"hljs-number\">1</span>]);\n    }\n  }\n\n  <span class=\"hljs-comment\">/**\n   * @brief This function updates the value at node with val\n   * @param node the node where the update is done\n   * @param val the value that is being updated\n   * @returns void\n   */</span>\n  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">update</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> node, X val)</span> </span>{\n    X diff = val - Tree&lt;X&gt;::t_val[node];\n    SG&lt;X&gt;::<span class=\"hljs-built_in\">update</span>(h_label[node], diff);\n    Tree&lt;X&gt;::t_val[node] = val;\n  }\n\n  <span class=\"hljs-comment\">/**\n   * @brief This function returns the sum of node values in the simple path from\n   * from node_1 to node_2\n   * @param a the node where the simple path starts\n   * @param b the node where the simple path ends\n   * (parameters are interchangeable, i.e., the function is commutative)\n   * @returns the sum of node values in the simple path from a to b\n   */</span>\n  <span class=\"hljs-function\">X <span class=\"hljs-title\">query</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>{\n    <span class=\"hljs-type\">int</span> lc = Tree&lt;X&gt;::<span class=\"hljs-built_in\">lca</span>(a, b);\n    X ret = SG&lt;X&gt;::sret_init;\n    <span class=\"hljs-built_in\">assert</span>(lc != <span class=\"hljs-number\">-1</span>);\n    ret += <span class=\"hljs-built_in\">chain_query</span>(a, lc);\n    ret += <span class=\"hljs-built_in\">chain_query</span>(b, lc);\n    <span class=\"hljs-keyword\">return</span> ret - Tree&lt;X&gt;::t_val[lc];\n  }\n};\n} <span class=\"hljs-comment\">// namespace heavy_light_decomposition</span>\n} <span class=\"hljs-comment\">// namespace range_queries</span>\n\n<span class=\"hljs-comment\">/**\n * Test implementations\n * @returns none\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_1</span><span class=\"hljs-params\">()</span> </span>{\n  std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 1:\\n&quot;</span>;\n\n  <span class=\"hljs-comment\">// Test details</span>\n  <span class=\"hljs-type\">int</span> n = <span class=\"hljs-number\">5</span>;\n  std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; node_values = {<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>};\n  std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; edges = {{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>}, {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>}, {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>}};\n  std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; queries = {\n      {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>},\n      {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>},\n      {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>},\n  };\n  std::vector&lt;<span class=\"hljs-type\">int</span>&gt; expected_result = {<span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">8</span>};\n  std::vector&lt;<span class=\"hljs-type\">int</span>&gt; code_result;\n\n  range_queries::<span class=\"hljs-function\">heavy_light_decomposition::HLD&lt;<span class=\"hljs-type\">int64_t</span>&gt; <span class=\"hljs-title\">hld</span><span class=\"hljs-params\">(n)</span></span>;\n  hld.<span class=\"hljs-built_in\">set_node_val</span>(node_values);\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n - <span class=\"hljs-number\">1</span>; i++) {\n    <span class=\"hljs-type\">int</span> u = edges[i][<span class=\"hljs-number\">0</span>], v = edges[i][<span class=\"hljs-number\">1</span>];\n    hld.<span class=\"hljs-built_in\">add_edge</span>(u - <span class=\"hljs-number\">1</span>, v - <span class=\"hljs-number\">1</span>);\n  }\n  hld.<span class=\"hljs-built_in\">init</span>();\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;q : queries) {\n    <span class=\"hljs-type\">int</span> type = q[<span class=\"hljs-number\">0</span>];\n    <span class=\"hljs-keyword\">if</span> (type == <span class=\"hljs-number\">1</span>) {\n      <span class=\"hljs-type\">int</span> p = q[<span class=\"hljs-number\">1</span>], x = q[<span class=\"hljs-number\">2</span>];\n      hld.<span class=\"hljs-built_in\">update</span>(p - <span class=\"hljs-number\">1</span>, x);\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (type == <span class=\"hljs-number\">2</span>) {\n      <span class=\"hljs-type\">int</span> a = q[<span class=\"hljs-number\">1</span>], b = q[<span class=\"hljs-number\">2</span>];\n      code_result.<span class=\"hljs-built_in\">push_back</span>(hld.<span class=\"hljs-built_in\">query</span>(a - <span class=\"hljs-number\">1</span>, b - <span class=\"hljs-number\">1</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">continue</span>;\n    }\n  }\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(expected_result.<span class=\"hljs-built_in\">size</span>()); i++) {\n    <span class=\"hljs-built_in\">assert</span>(expected_result[i] == code_result[i]);\n  }\n  std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nTest 1 passed!\\n&quot;</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * Second test implementations\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_2</span><span class=\"hljs-params\">()</span> </span>{\n  std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 2:\\n&quot;</span>;\n\n  <span class=\"hljs-comment\">// Test details (Bamboo)</span>\n  <span class=\"hljs-type\">int</span> n = <span class=\"hljs-number\">10</span>;\n  std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; node_values = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>};\n  std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; edges = {\n      {<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">5</span>}, {<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>}, {<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">7</span>}, {<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>}, {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">9</span>}, {<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">3</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>}, {<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">4</span>}, {<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">7</span>}};\n  std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; queries = {\n      {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">10</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">6</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">9</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">3</span>},\n      {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>},  {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">8</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">7</span>}};\n  std::vector&lt;<span class=\"hljs-type\">int</span>&gt; expected_result = {<span class=\"hljs-number\">27</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">45</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">34</span>};\n  std::vector&lt;<span class=\"hljs-type\">int</span>&gt; code_result;\n\n  range_queries::<span class=\"hljs-function\">heavy_light_decomposition::HLD&lt;<span class=\"hljs-type\">int64_t</span>&gt; <span class=\"hljs-title\">hld</span><span class=\"hljs-params\">(n)</span></span>;\n  hld.<span class=\"hljs-built_in\">set_node_val</span>(node_values);\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n - <span class=\"hljs-number\">1</span>; i++) {\n    <span class=\"hljs-type\">int</span> u = edges[i][<span class=\"hljs-number\">0</span>], v = edges[i][<span class=\"hljs-number\">1</span>];\n    hld.<span class=\"hljs-built_in\">add_edge</span>(u - <span class=\"hljs-number\">1</span>, v - <span class=\"hljs-number\">1</span>);\n  }\n  hld.<span class=\"hljs-built_in\">init</span>();\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;q : queries) {\n    <span class=\"hljs-type\">int</span> type = q[<span class=\"hljs-number\">0</span>];\n    <span class=\"hljs-keyword\">if</span> (type == <span class=\"hljs-number\">1</span>) {\n      <span class=\"hljs-type\">int</span> p = q[<span class=\"hljs-number\">1</span>], x = q[<span class=\"hljs-number\">2</span>];\n      hld.<span class=\"hljs-built_in\">update</span>(p - <span class=\"hljs-number\">1</span>, x);\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (type == <span class=\"hljs-number\">2</span>) {\n      <span class=\"hljs-type\">int</span> a = q[<span class=\"hljs-number\">1</span>], b = q[<span class=\"hljs-number\">2</span>];\n      code_result.<span class=\"hljs-built_in\">push_back</span>(hld.<span class=\"hljs-built_in\">query</span>(a - <span class=\"hljs-number\">1</span>, b - <span class=\"hljs-number\">1</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">continue</span>;\n    }\n  }\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(expected_result.<span class=\"hljs-built_in\">size</span>()); i++) {\n    <span class=\"hljs-built_in\">assert</span>(expected_result[i] == code_result[i]);\n  }\n  std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nTest2 passed!\\n&quot;</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * Third test implementations\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_3</span><span class=\"hljs-params\">()</span> </span>{\n  std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 3:\\n&quot;</span>;\n\n  <span class=\"hljs-comment\">// Test details</span>\n  <span class=\"hljs-type\">int</span> n = <span class=\"hljs-number\">8</span>;\n  std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; node_values = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">2</span>};\n  std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; edges = {{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}, {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>},\n                                         {<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">3</span>}, {<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">5</span>}, {<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">7</span>}};\n  std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; queries = {\n      {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">1</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">3</span>},\n      {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">4</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">7</span>}};\n  std::vector&lt;<span class=\"hljs-type\">int</span>&gt; expected_result = {<span class=\"hljs-number\">34</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">14</span>, <span class=\"hljs-number\">10</span>};\n  std::vector&lt;<span class=\"hljs-type\">int</span>&gt; code_result;\n\n  range_queries::<span class=\"hljs-function\">heavy_light_decomposition::HLD&lt;<span class=\"hljs-type\">int64_t</span>&gt; <span class=\"hljs-title\">hld</span><span class=\"hljs-params\">(n)</span></span>;\n  hld.<span class=\"hljs-built_in\">set_node_val</span>(node_values);\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n - <span class=\"hljs-number\">1</span>; i++) {\n    <span class=\"hljs-type\">int</span> u = edges[i][<span class=\"hljs-number\">0</span>], v = edges[i][<span class=\"hljs-number\">1</span>];\n    hld.<span class=\"hljs-built_in\">add_edge</span>(u - <span class=\"hljs-number\">1</span>, v - <span class=\"hljs-number\">1</span>);\n  }\n  hld.<span class=\"hljs-built_in\">init</span>();\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;q : queries) {\n    <span class=\"hljs-type\">int</span> type = q[<span class=\"hljs-number\">0</span>];\n    <span class=\"hljs-keyword\">if</span> (type == <span class=\"hljs-number\">1</span>) {\n      <span class=\"hljs-type\">int</span> p = q[<span class=\"hljs-number\">1</span>], x = q[<span class=\"hljs-number\">2</span>];\n      hld.<span class=\"hljs-built_in\">update</span>(p - <span class=\"hljs-number\">1</span>, x);\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (type == <span class=\"hljs-number\">2</span>) {\n      <span class=\"hljs-type\">int</span> a = q[<span class=\"hljs-number\">1</span>], b = q[<span class=\"hljs-number\">2</span>];\n      code_result.<span class=\"hljs-built_in\">push_back</span>(hld.<span class=\"hljs-built_in\">query</span>(a - <span class=\"hljs-number\">1</span>, b - <span class=\"hljs-number\">1</span>));\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">continue</span>;\n    }\n  }\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(expected_result.<span class=\"hljs-built_in\">size</span>()); i++) {\n    <span class=\"hljs-built_in\">assert</span>(expected_result[i] == code_result[i]);\n  }\n  std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nTest3 passed!\\n&quot;</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * Main function\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-built_in\">test_1</span>();\n  <span class=\"hljs-built_in\">test_2</span>();\n  <span class=\"hljs-built_in\">test_3</span>();\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Aniruthan R",
      "email": "67466816+aneee004@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}
