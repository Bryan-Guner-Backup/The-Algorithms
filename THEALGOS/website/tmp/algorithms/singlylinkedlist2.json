{
  "slug": "singlylinkedlist2",
  "name": "Singlylinkedlist2",
  "categories": ["datastructures", "linkedlist", "singlylinkedlist"],
  "body": {},
  "implementations": {
    "go": {
      "dir": "datastructures/linkedlist/singlylinkedlist/singlylinkedlist2.go",
      "url": "https://github.com/TheAlgorithms/go/tree/master/datastructures/linkedlist/singlylinkedlist/singlylinkedlist2.go",
      "code": "<span class=\"hljs-keyword\">package</span> singlylinkedlist\n\n<span class=\"hljs-comment\">// TODO not needed because there is already an implementation of SingleLinkedList</span>\n\n<span class=\"hljs-comment\">// import &quot;fmt&quot;</span>\n\n<span class=\"hljs-comment\">// /* v is the value of node; next is the pointer to next node */</span>\n<span class=\"hljs-comment\">// type node struct {</span>\n<span class=\"hljs-comment\">// \tv    int</span>\n<span class=\"hljs-comment\">// \tnext *node</span>\n<span class=\"hljs-comment\">// }</span>\n\n<span class=\"hljs-comment\">// /* first node, called head. It points from first node to last node */</span>\n<span class=\"hljs-comment\">// var head *node = nil</span>\n\n<span class=\"hljs-comment\">// func (l *node) pushFront(val int) *node {</span>\n<span class=\"hljs-comment\">// \t/* if there&#x27;s no nodes, head points to l (first node) */</span>\n<span class=\"hljs-comment\">// \tif head == nil {</span>\n<span class=\"hljs-comment\">// \t\tl.v = val</span>\n<span class=\"hljs-comment\">// \t\tl.next = nil</span>\n<span class=\"hljs-comment\">// \t\thead = l</span>\n<span class=\"hljs-comment\">// \t\treturn l</span>\n<span class=\"hljs-comment\">// \t} else {</span>\n<span class=\"hljs-comment\">// \t\t/* create a new node equals to head */</span>\n<span class=\"hljs-comment\">// \t\tnnode := new(node)</span>\n<span class=\"hljs-comment\">// \t\tnnode = head</span>\n<span class=\"hljs-comment\">// \t\t/* create a second node with new value and `next -&gt; nnode`</span>\n<span class=\"hljs-comment\">// \t\t*  is this way, nnode2 is before nnode</span>\n<span class=\"hljs-comment\">// \t\t */</span>\n<span class=\"hljs-comment\">// \t\tnnode2 := &amp;node{</span>\n<span class=\"hljs-comment\">// \t\t\tv:    val,</span>\n<span class=\"hljs-comment\">// \t\t\tnext: nnode,</span>\n<span class=\"hljs-comment\">// \t\t}</span>\n<span class=\"hljs-comment\">// \t\t/* now head is equals nnode2 */</span>\n<span class=\"hljs-comment\">// \t\thead = nnode2</span>\n<span class=\"hljs-comment\">// \t\treturn head</span>\n<span class=\"hljs-comment\">// \t}</span>\n<span class=\"hljs-comment\">// }</span>\n\n<span class=\"hljs-comment\">// func (l *node) pushBack(val int) *node {</span>\n<span class=\"hljs-comment\">// \t/* if there&#x27;s no nodes, head points to l (first node) */</span>\n<span class=\"hljs-comment\">// \tif head == nil {</span>\n<span class=\"hljs-comment\">// \t\tl.v = val</span>\n<span class=\"hljs-comment\">// \t\tl.next = nil</span>\n<span class=\"hljs-comment\">// \t\thead = l</span>\n<span class=\"hljs-comment\">// \t\treturn l</span>\n<span class=\"hljs-comment\">// \t} else {</span>\n<span class=\"hljs-comment\">// \t\t/* read all list to last node */</span>\n<span class=\"hljs-comment\">// \t\tfor l.next != nil {</span>\n<span class=\"hljs-comment\">// \t\t\tl = l.next</span>\n<span class=\"hljs-comment\">// \t\t}</span>\n<span class=\"hljs-comment\">// \t\t/* allocate a new portion of memory */</span>\n<span class=\"hljs-comment\">// \t\tl.next = new(node)</span>\n<span class=\"hljs-comment\">// \t\tl.next.v = val</span>\n<span class=\"hljs-comment\">// \t\tl.next.next = nil</span>\n<span class=\"hljs-comment\">// \t\treturn l</span>\n<span class=\"hljs-comment\">// \t}</span>\n<span class=\"hljs-comment\">// }</span>\n\n<span class=\"hljs-comment\">// func (l *node) popFront() *node {</span>\n<span class=\"hljs-comment\">// \tif head == nil {</span>\n<span class=\"hljs-comment\">// \t\treturn head</span>\n<span class=\"hljs-comment\">// \t}</span>\n<span class=\"hljs-comment\">// \t/* create a new node equals to first node pointed by head */</span>\n<span class=\"hljs-comment\">// \tcpnode := new(node)</span>\n<span class=\"hljs-comment\">// \tcpnode = head.next</span>\n\n<span class=\"hljs-comment\">// \t/* now head is equals cpnode (second node) */</span>\n<span class=\"hljs-comment\">// \thead = cpnode</span>\n\n<span class=\"hljs-comment\">// \treturn head</span>\n<span class=\"hljs-comment\">// }</span>\n\n<span class=\"hljs-comment\">// func (l *node) popBack() *node {</span>\n<span class=\"hljs-comment\">// \tif head == nil {</span>\n<span class=\"hljs-comment\">// \t\treturn head</span>\n<span class=\"hljs-comment\">// \t}</span>\n<span class=\"hljs-comment\">// \t/* create a new node equals to head */</span>\n<span class=\"hljs-comment\">// \tcpnode := new(node)</span>\n<span class=\"hljs-comment\">// \tcpnode = head</span>\n\n<span class=\"hljs-comment\">// \t/* read list to the penultimate node */</span>\n<span class=\"hljs-comment\">// \tfor cpnode.next.next != nil {</span>\n<span class=\"hljs-comment\">// \t\tcpnode = cpnode.next</span>\n<span class=\"hljs-comment\">// \t}</span>\n<span class=\"hljs-comment\">// \t/* the penultimate node points to null. In this way the last node is deleted */</span>\n<span class=\"hljs-comment\">// \tcpnode.next = nil</span>\n<span class=\"hljs-comment\">// \treturn head</span>\n<span class=\"hljs-comment\">// }</span>\n\n<span class=\"hljs-comment\">// func main() {</span>\n<span class=\"hljs-comment\">// \tlista := new(node)</span>\n<span class=\"hljs-comment\">// \tlista.pushBack(25).pushBack(24).pushBack(32) /* lista: 25 24 32 */</span>\n<span class=\"hljs-comment\">// \tlista.pushBack(56)                           /* lista: 25 24 32 56 */</span>\n<span class=\"hljs-comment\">// \tlista.pushFront(36)                          /* lista: 36 25 24 32 56 */</span>\n<span class=\"hljs-comment\">// \tlista.popFront()                             /* lista: 25 24 32 56 */</span>\n<span class=\"hljs-comment\">// \tlista.popBack()                              /* lista: 25 24 32 */</span>\n\n<span class=\"hljs-comment\">// \t/* read the list until head is not nil */</span>\n<span class=\"hljs-comment\">// \tfor head != nil {</span>\n<span class=\"hljs-comment\">// \t\tfmt.Printf(&quot;%d &quot;, head.v)</span>\n<span class=\"hljs-comment\">// \t\thead = head.next /*head points to next node */</span>\n<span class=\"hljs-comment\">// \t}</span>\n<span class=\"hljs-comment\">// }</span>\n"
    }
  },
  "contributors": [
    {
      "name": "Taj",
      "email": "tjgurwara99@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}
