{
  "slug": "inorder-successor-of-bst",
  "name": "Inorder Successor of Bst",
  "categories": ["operationsondatastructures"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "operations_on_datastructures/inorder_successor_of_bst.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/operations_on_datastructures/inorder_successor_of_bst.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * @brief An implementation for finding the [Inorder successor of a binary\n * search tree](https://www.youtube.com/watch?v=5cPbNCrdotA) Inorder\n * successor of a node is the next node in Inorder traversal of the Binary Tree.\n * Inorder Successor is NULL for the last node in Inorder traversal.\n * @details\n * ### Case 1: The given node has the right node/subtree\n *\n *      * In this case, the left-most deepest node in the right subtree will\n * come just after the given node as we go to left deep in inorder.\n *      - Go deep to left most node in right subtree.\n *        OR, we can also say in case if BST, find the minimum of the subtree\n * for a given node.\n *\n * ### Case 2: The given node does not have a right node/subtree\n *\n * #### Method 1: Use parent pointer (store the address of parent nodes)\n *      * If a node does not have the right subtree, and we already visited the\n * node itself, then the next node will be its parent node according to inorder\n * traversal, and if we are going to parent from left, then the parent would be\n * unvisited.\n *      * In other words, go to the nearest ancestor for which given node would\n * be in left subtree.\n *\n * #### Method 2: Search from the root node\n *      * In case if there is no link from a child node to the parent node, we\n * need to walk down the tree starting from the root node to the given node, by\n * doing so, we are visiting every ancestor of the given node.\n *      * In order successor would be the deepest node in this path for which\n * given node is in left subtree.\n *\n * @author [Nitin Sharma](https://github.com/foo290)\n * */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>   <span class=\"hljs-comment\">///  for assert</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>  <span class=\"hljs-comment\">///  for IO Operations</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>    <span class=\"hljs-comment\">///  for std::vector</span></span>\n\n<span class=\"hljs-comment\">/**\n * @namespace operations_on_datastructures\n * @brief Operations on data structures\n */</span>\n<span class=\"hljs-keyword\">namespace</span> operations_on_datastructures {\n\n<span class=\"hljs-comment\">/**\n * @namespace inorder_successor_of_bst\n * @brief Functions for the [Inorder successor of a binary search\n * tree](https://www.youtube.com/watch?v=5cPbNCrdotA) implementation\n */</span>\n<span class=\"hljs-keyword\">namespace</span> inorder_traversal_of_bst {\n\n<span class=\"hljs-comment\">/**\n * @brief A Node structure representing a single node in BST\n */</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Node</span> {\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-type\">int64_t</span> data;  <span class=\"hljs-comment\">///&lt; The key/value of the node</span>\n    Node *left;    <span class=\"hljs-comment\">///&lt; Pointer to Left child</span>\n    Node *right;   <span class=\"hljs-comment\">///&lt; Pointer to right child</span>\n};\n\n<span class=\"hljs-comment\">/**\n * @brief Allocates a new node in heap for given data and returns it&#x27;s pointer.\n * @param data Data for the node.\n * @returns A pointer to the newly allocated Node.\n * */</span>\n<span class=\"hljs-function\">Node *<span class=\"hljs-title\">makeNode</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> data)</span> </span>{\n    Node *node = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>();\n    node-&gt;data = data;      <span class=\"hljs-comment\">///&lt; setting data for node</span>\n    node-&gt;left = <span class=\"hljs-literal\">nullptr</span>;   <span class=\"hljs-comment\">///&lt; setting left child as null</span>\n    node-&gt;right = <span class=\"hljs-literal\">nullptr</span>;  <span class=\"hljs-comment\">///&lt; setting right child as null</span>\n    <span class=\"hljs-keyword\">return</span> node;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Inserts the given data in BST while maintaining the properties of BST.\n * @param root Pointer to the root node of the BST\n * @param data Data to be inserted.\n * @returns Node* Pointer to the root node.\n * */</span>\n<span class=\"hljs-function\">Node *<span class=\"hljs-title\">Insert</span><span class=\"hljs-params\">(Node *root, <span class=\"hljs-type\">int64_t</span> data)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">nullptr</span>) {\n        root = <span class=\"hljs-built_in\">makeNode</span>(data);\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (data &lt;= root-&gt;data) {\n        root-&gt;left = <span class=\"hljs-built_in\">Insert</span>(root-&gt;left, data);\n    } <span class=\"hljs-keyword\">else</span> {\n        root-&gt;right = <span class=\"hljs-built_in\">Insert</span>(root-&gt;right, data);\n    }\n    <span class=\"hljs-keyword\">return</span> root;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Searches the given data in BST and returns the pointer to the node\n * containing that data.\n * @param root Pointer to the root node of the BST\n * @param data Data to be Searched.\n * @returns Node* pointer to the found node\n * */</span>\n<span class=\"hljs-function\">Node *<span class=\"hljs-title\">getNode</span><span class=\"hljs-params\">(Node *root, <span class=\"hljs-type\">int64_t</span> data)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">nullptr</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (root-&gt;data == data) {\n        <span class=\"hljs-keyword\">return</span> root;  <span class=\"hljs-comment\">/// Node found!</span>\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (data &gt; root-&gt;data) {\n        <span class=\"hljs-comment\">/// Traverse right subtree recursively as the given data is greater than</span>\n        <span class=\"hljs-comment\">/// the data in root node, data must be present in right subtree.</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">getNode</span>(root-&gt;right, data);\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">/// Traverse left subtree recursively as the given data is less than the</span>\n        <span class=\"hljs-comment\">/// data in root node, data must be present in left subtree.</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">getNode</span>(root-&gt;left, data);\n    }\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Finds and return the minimum node in BST.\n * @param root A pointer to root node.\n * @returns Node* Pointer to the found node\n * */</span>\n<span class=\"hljs-function\">Node *<span class=\"hljs-title\">findMinNode</span><span class=\"hljs-params\">(Node *root)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">nullptr</span>) {\n        <span class=\"hljs-keyword\">return</span> root;\n    }\n    <span class=\"hljs-keyword\">while</span> (root-&gt;left != <span class=\"hljs-literal\">nullptr</span>) {\n        root = root-&gt;left;\n    }\n    <span class=\"hljs-keyword\">return</span> root;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Prints the BST in inorder traversal using recursion.\n * @param root A pointer to the root node of the BST.\n * @returns void\n * */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printInorder</span><span class=\"hljs-params\">(Node *root)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">nullptr</span>) {\n        <span class=\"hljs-keyword\">return</span>;\n    }\n\n    <span class=\"hljs-built_in\">printInorder</span>(root-&gt;left);  <span class=\"hljs-comment\">/// recursive call to left subtree</span>\n    std::cout &lt;&lt; root-&gt;data &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;\n    <span class=\"hljs-built_in\">printInorder</span>(root-&gt;right);  <span class=\"hljs-comment\">/// recursive call to right subtree</span>\n}\n\n<span class=\"hljs-comment\">/**\n * @brief This function is used in test cases to quickly create BST containing\n * large data instead of hard coding it in code. For a given root, this will add\n * all the nodes containing data passes in data vector.\n * @param root Pointer to the root node.\n * @param data A vector containing integer values which are suppose to be\n * inserted as nodes in BST.\n * @returns Node pointer to the root node.\n * */</span>\n<span class=\"hljs-function\">Node *<span class=\"hljs-title\">makeBST</span><span class=\"hljs-params\">(Node *root, <span class=\"hljs-keyword\">const</span> std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; &amp;data)</span> </span>{\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int64_t</span> values : data) {\n        root = <span class=\"hljs-built_in\">Insert</span>(root, values);\n    }\n    <span class=\"hljs-keyword\">return</span> root;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Inorder successor of a node is the next node in inorder traversal of\n * the Binary Tree. This function takes the root node and the data of the node\n * for which we have to find the inorder successor, and returns the inorder\n * successor node.\n * @details Search from the root node as we need to walk the tree starting from\n * the root node to the given node, by doing so, we are visiting every ancestor\n * of the given node. In order successor would be the deepest node in this path\n * for which given node is in left subtree. Time complexity O(h)\n * @param root A pointer to the root node of the BST\n * @param data The data (or the data of node) for which we have to find inorder\n * successor.\n * @returns Node pointer to the inorder successor node.\n * */</span>\n<span class=\"hljs-function\">Node *<span class=\"hljs-title\">getInorderSuccessor</span><span class=\"hljs-params\">(Node *root, <span class=\"hljs-type\">int64_t</span> data)</span> </span>{\n    Node *current = <span class=\"hljs-built_in\">getNode</span>(root, data);\n    <span class=\"hljs-keyword\">if</span> (current == <span class=\"hljs-literal\">nullptr</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;\n    }\n\n    <span class=\"hljs-comment\">// Case - 1</span>\n    <span class=\"hljs-keyword\">if</span> (current-&gt;right != <span class=\"hljs-literal\">nullptr</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">findMinNode</span>(current-&gt;right);\n    }\n    <span class=\"hljs-comment\">// case - 2</span>\n    <span class=\"hljs-keyword\">else</span> {\n        Node *successor = <span class=\"hljs-literal\">nullptr</span>;\n        Node *ancestor = root;\n\n        <span class=\"hljs-keyword\">while</span> (ancestor != current &amp;&amp; ancestor != <span class=\"hljs-literal\">nullptr</span>) {\n            <span class=\"hljs-comment\">// This means my current node is in left of the root node</span>\n            <span class=\"hljs-keyword\">if</span> (current-&gt;data &lt; ancestor-&gt;data) {\n                successor = ancestor;\n                ancestor = ancestor-&gt;left;  <span class=\"hljs-comment\">// keep going left</span>\n            } <span class=\"hljs-keyword\">else</span> {\n                ancestor = ancestor-&gt;right;\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> successor;  <span class=\"hljs-comment\">// Nodes with maximum vales will not have a successor</span>\n    }\n}\n\n<span class=\"hljs-comment\">/**\n * @brief This function clears the memory allocated to entire tree recursively.\n * Its just for clean up the memory and not relevant to the actual topic.\n * @param root Root node of the tree.\n * @returns void\n * */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">deallocate</span><span class=\"hljs-params\">(Node *rootNode)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (rootNode == <span class=\"hljs-literal\">nullptr</span>) {\n        <span class=\"hljs-keyword\">return</span>;\n    }\n    <span class=\"hljs-built_in\">deallocate</span>(rootNode-&gt;left);\n    <span class=\"hljs-built_in\">deallocate</span>(rootNode-&gt;right);\n    <span class=\"hljs-built_in\">delete</span> (rootNode);\n}\n\n}  <span class=\"hljs-comment\">// namespace inorder_traversal_of_bst</span>\n}  <span class=\"hljs-comment\">// namespace operations_on_datastructures</span>\n\n<span class=\"hljs-comment\">/**\n * @brief class encapsulating the necessary test cases\n */</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TestCases</span> {\n <span class=\"hljs-keyword\">private</span>:\n    <span class=\"hljs-comment\">/**\n     * @brief A function to print given message on console.\n     * @tparam T Type of the given message.\n     * @returns void\n     * */</span>\n    <span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">log</span><span class=\"hljs-params\">(T msg)</span> </span>{\n        <span class=\"hljs-comment\">// It&#x27;s just to avoid writing cout and endl</span>\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;[TESTS] : ---&gt; &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;\n    }\n\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-comment\">/**\n     * @brief Executes test cases\n     * @returns void\n     * */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">runTests</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Running Tests...&quot;</span>);\n\n        <span class=\"hljs-built_in\">testCase_1</span>();\n        <span class=\"hljs-built_in\">testCase_2</span>();\n        <span class=\"hljs-built_in\">testCase_3</span>();\n\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Test Cases over!&quot;</span>);\n        std::cout &lt;&lt; std::endl;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief A test case contains edge case, printing inorder successor of last\n     * node.\n     * @returns void\n     * */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">testCase_1</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">const</span> operations_on_datastructures::inorder_traversal_of_bst::Node\n            *expectedOutput = <span class=\"hljs-literal\">nullptr</span>;  <span class=\"hljs-comment\">///&lt; Expected output of this test</span>\n\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;</span>);\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;This is test case 1 : &quot;</span>);\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Description:&quot;</span>);\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;   EDGE CASE : Printing inorder successor for last node in the &quot;</span>\n            <span class=\"hljs-string\">&quot;BST, Output will be nullptr.&quot;</span>);\n\n        operations_on_datastructures::inorder_traversal_of_bst::Node *root =\n            <span class=\"hljs-literal\">nullptr</span>;\n        std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; node_data{\n            <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">23</span>, <span class=\"hljs-number\">45</span>, <span class=\"hljs-number\">78</span>, <span class=\"hljs-number\">21</span>};  <span class=\"hljs-comment\">///&lt; Data to make nodes in BST</span>\n\n        root = operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">makeBST</span>(\n            root,\n            node_data);  <span class=\"hljs-comment\">///&lt; Adding nodes to BST</span>\n\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Inorder sequence is : &quot;</span>;\n        operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">printInorder</span>(\n            root);  <span class=\"hljs-comment\">///&lt; Printing inorder to cross-verify.</span>\n        std::cout &lt;&lt; std::endl;\n\n        operations_on_datastructures::inorder_traversal_of_bst::Node\n            *inorderSuccessor = operations_on_datastructures::\n                inorder_traversal_of_bst::<span class=\"hljs-built_in\">getInorderSuccessor</span>(\n                    root, <span class=\"hljs-number\">78</span>);  <span class=\"hljs-comment\">///&lt; The inorder successor node for given data</span>\n\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Checking assert expression...&quot;</span>);\n        <span class=\"hljs-built_in\">assert</span>(inorderSuccessor == expectedOutput);\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Assertion check passed!&quot;</span>);\n\n        operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">deallocate</span>(\n            root);  <span class=\"hljs-comment\">/// memory cleanup!</span>\n\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;[PASS] : TEST CASE 1 PASS!&quot;</span>);\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;</span>);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief A test case which contains main list of 100 elements and sublist\n     * of 20.\n     * @returns void\n     * */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">testCase_2</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> expectedOutput = <span class=\"hljs-number\">21</span>;  <span class=\"hljs-comment\">///&lt; Expected output of this test</span>\n\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;</span>);\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;This is test case 2 : &quot;</span>);\n\n        operations_on_datastructures::inorder_traversal_of_bst::Node *root =\n            <span class=\"hljs-literal\">nullptr</span>;\n        std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; node_data{\n            <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">23</span>, <span class=\"hljs-number\">45</span>, <span class=\"hljs-number\">78</span>, <span class=\"hljs-number\">21</span>};  <span class=\"hljs-comment\">///&lt; Data to make nodes in BST</span>\n\n        root = operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">makeBST</span>(\n            root,\n            node_data);  <span class=\"hljs-comment\">///&lt; Adding nodes to BST</span>\n\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Inorder sequence is : &quot;</span>;\n        operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">printInorder</span>(\n            root);  <span class=\"hljs-comment\">///&lt; Printing inorder to cross-verify.</span>\n        std::cout &lt;&lt; std::endl;\n\n        operations_on_datastructures::inorder_traversal_of_bst::Node\n            *inorderSuccessor = operations_on_datastructures::\n                inorder_traversal_of_bst::<span class=\"hljs-built_in\">getInorderSuccessor</span>(\n                    root, <span class=\"hljs-number\">20</span>);  <span class=\"hljs-comment\">///&lt; The inorder successor node for given data</span>\n\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Checking assert expression...&quot;</span>);\n        <span class=\"hljs-built_in\">assert</span>(inorderSuccessor-&gt;data == expectedOutput);\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Assertion check passed!&quot;</span>);\n\n        operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">deallocate</span>(\n            root);  <span class=\"hljs-comment\">/// memory cleanup!</span>\n\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;[PASS] : TEST CASE 2 PASS!&quot;</span>);\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;</span>);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief A test case which contains main list of 50 elements and sublist\n     * of 20.\n     * @returns void\n     * */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">testCase_3</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> expectedOutput = <span class=\"hljs-number\">110</span>;  <span class=\"hljs-comment\">///&lt; Expected output of this test</span>\n\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;</span>);\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;This is test case 3 : &quot;</span>);\n\n        operations_on_datastructures::inorder_traversal_of_bst::Node *root =\n            <span class=\"hljs-literal\">nullptr</span>;\n        std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; node_data{\n            <span class=\"hljs-number\">89</span>,  <span class=\"hljs-number\">67</span>,  <span class=\"hljs-number\">32</span>, <span class=\"hljs-number\">56</span>, <span class=\"hljs-number\">90</span>, <span class=\"hljs-number\">123</span>, <span class=\"hljs-number\">120</span>,\n            <span class=\"hljs-number\">110</span>, <span class=\"hljs-number\">115</span>, <span class=\"hljs-number\">6</span>,  <span class=\"hljs-number\">78</span>, <span class=\"hljs-number\">7</span>,  <span class=\"hljs-number\">10</span>};  <span class=\"hljs-comment\">///&lt; Data to make nodes in BST</span>\n\n        root = operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">makeBST</span>(\n            root,\n            node_data);  <span class=\"hljs-comment\">///&lt; Adding nodes to BST</span>\n\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Inorder sequence is : &quot;</span>;\n        operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">printInorder</span>(\n            root);  <span class=\"hljs-comment\">///&lt; Printing inorder to cross-verify.</span>\n        std::cout &lt;&lt; std::endl;\n\n        operations_on_datastructures::inorder_traversal_of_bst::Node\n            *inorderSuccessor = operations_on_datastructures::\n                inorder_traversal_of_bst::<span class=\"hljs-built_in\">getInorderSuccessor</span>(\n                    root, <span class=\"hljs-number\">90</span>);  <span class=\"hljs-comment\">///&lt; The inorder successor node for given data</span>\n\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Checking assert expression...&quot;</span>);\n        <span class=\"hljs-built_in\">assert</span>(inorderSuccessor-&gt;data == expectedOutput);\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;Assertion check passed!&quot;</span>);\n\n        operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">deallocate</span>(\n            root);  <span class=\"hljs-comment\">/// memory cleanup!</span>\n\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;[PASS] : TEST CASE 3 PASS!&quot;</span>);\n        <span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;</span>);\n    }\n};\n\n<span class=\"hljs-comment\">/**\n * @brief Self-test implementations\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\n    TestCases tc;\n    tc.<span class=\"hljs-built_in\">runTests</span>();\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Main function\n * @param argc commandline argument count (ignored)\n * @param argv commandline array of arguments (ignored)\n * @returns 0 on exit\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span> </span>{\n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">// run self-test implementations</span>\n\n    operations_on_datastructures::inorder_traversal_of_bst::Node *root =\n        <span class=\"hljs-literal\">nullptr</span>;  <span class=\"hljs-comment\">///&lt; root node of the bst</span>\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; node_data{<span class=\"hljs-number\">3</span>,  <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>,\n                                   <span class=\"hljs-number\">89</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>};  <span class=\"hljs-comment\">///&lt; Data to add nodes in BST</span>\n\n    <span class=\"hljs-type\">int64_t</span> targetElement = <span class=\"hljs-number\">4</span>;  <span class=\"hljs-comment\">///&lt; An element to find inorder successor for.</span>\n    root = operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">makeBST</span>(\n        root, node_data);  <span class=\"hljs-comment\">///&lt; Making BST</span>\n\n    operations_on_datastructures::inorder_traversal_of_bst::Node\n        *inorderSuccessor = operations_on_datastructures::\n            inorder_traversal_of_bst::<span class=\"hljs-built_in\">getInorderSuccessor</span>(root, targetElement);\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;In-order sequence is : &quot;</span>;\n    operations_on_datastructures::inorder_traversal_of_bst::<span class=\"hljs-built_in\">printInorder</span>(root);\n    std::cout &lt;&lt; std::endl;\n\n    <span class=\"hljs-keyword\">if</span> (inorderSuccessor == <span class=\"hljs-literal\">nullptr</span>) {\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Inorder successor for last node is NULL&quot;</span> &lt;&lt; std::endl;\n    } <span class=\"hljs-keyword\">else</span> {\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Target element is : &quot;</span> &lt;&lt; targetElement &lt;&lt; std::endl;\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Inorder successor for target element is : &quot;</span>\n                  &lt;&lt; inorderSuccessor-&gt;data &lt;&lt; std::endl;\n    }\n\n    <span class=\"hljs-built_in\">deallocate</span>(root);  <span class=\"hljs-comment\">/// memory cleanup!</span>\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Nitin Sharma",
      "email": "32377892+foo290@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}
