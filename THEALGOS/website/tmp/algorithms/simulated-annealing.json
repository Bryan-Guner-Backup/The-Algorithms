{
  "slug": "simulated-annealing",
  "name": "Simulated Annealing",
  "categories": ["searches"],
  "body": {},
  "implementations": {
    "python": {
      "dir": "searches/simulated_annealing.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/searches/simulated_annealing.py",
      "code": "<span class=\"hljs-comment\"># https://en.wikipedia.org/wiki/Simulated_annealing</span>\n<span class=\"hljs-keyword\">import</span> math\n<span class=\"hljs-keyword\">import</span> random\n\n<span class=\"hljs-keyword\">from</span> .hill_climbing <span class=\"hljs-keyword\">import</span> SearchProblem\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">simulated_annealing</span>(<span class=\"hljs-params\">\n    search_prob,\n    find_max: <span class=\"hljs-built_in\">bool</span> = <span class=\"hljs-literal\">True</span>,\n    max_x: <span class=\"hljs-built_in\">float</span> = math.inf,\n    min_x: <span class=\"hljs-built_in\">float</span> = -math.inf,\n    max_y: <span class=\"hljs-built_in\">float</span> = math.inf,\n    min_y: <span class=\"hljs-built_in\">float</span> = -math.inf,\n    visualization: <span class=\"hljs-built_in\">bool</span> = <span class=\"hljs-literal\">False</span>,\n    start_temperate: <span class=\"hljs-built_in\">float</span> = <span class=\"hljs-number\">100</span>,\n    rate_of_decrease: <span class=\"hljs-built_in\">float</span> = <span class=\"hljs-number\">0.01</span>,\n    threshold_temp: <span class=\"hljs-built_in\">float</span> = <span class=\"hljs-number\">1</span>,\n</span>) -&gt; SearchProblem:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Implementation of the simulated annealing algorithm. We start with a given state,\n    find all its neighbors. Pick a random neighbor, if that neighbor improves the\n    solution, we move in that direction, if that neighbor does not improve the solution,\n    we generate a random real number between 0 and 1, if the number is within a certain\n    range (calculated using temperature) we move in that direction, else we pick\n    another neighbor randomly and repeat the process.\n\n    Args:\n        search_prob: The search state at the start.\n        find_max: If True, the algorithm should find the minimum else the minimum.\n        max_x, min_x, max_y, min_y: the maximum and minimum bounds of x and y.\n        visualization: If True, a matplotlib graph is displayed.\n        start_temperate: the initial temperate of the system when the program starts.\n        rate_of_decrease: the rate at which the temperate decreases in each iteration.\n        threshold_temp: the threshold temperature below which we end the search\n    Returns a search state having the maximum (or minimum) score.\n    &quot;&quot;&quot;</span>\n    search_end = <span class=\"hljs-literal\">False</span>\n    current_state = search_prob\n    current_temp = start_temperate\n    scores = []\n    iterations = <span class=\"hljs-number\">0</span>\n    best_state = <span class=\"hljs-literal\">None</span>\n\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">not</span> search_end:\n        current_score = current_state.score()\n        <span class=\"hljs-keyword\">if</span> best_state <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">or</span> current_score &gt; best_state.score():\n            best_state = current_state\n        scores.append(current_score)\n        iterations += <span class=\"hljs-number\">1</span>\n        next_state = <span class=\"hljs-literal\">None</span>\n        neighbors = current_state.get_neighbors()\n        <span class=\"hljs-keyword\">while</span> (\n            next_state <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span> <span class=\"hljs-keyword\">and</span> neighbors\n        ):  <span class=\"hljs-comment\"># till we do not find a neighbor that we can move to</span>\n            index = random.randint(<span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">len</span>(neighbors) - <span class=\"hljs-number\">1</span>)  <span class=\"hljs-comment\"># picking a random neighbor</span>\n            picked_neighbor = neighbors.pop(index)\n            change = picked_neighbor.score() - current_score\n\n            <span class=\"hljs-keyword\">if</span> (\n                picked_neighbor.x &gt; max_x\n                <span class=\"hljs-keyword\">or</span> picked_neighbor.x &lt; min_x\n                <span class=\"hljs-keyword\">or</span> picked_neighbor.y &gt; max_y\n                <span class=\"hljs-keyword\">or</span> picked_neighbor.y &lt; min_y\n            ):\n                <span class=\"hljs-keyword\">continue</span>  <span class=\"hljs-comment\"># neighbor outside our bounds</span>\n\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> find_max:\n                change = change * -<span class=\"hljs-number\">1</span>  <span class=\"hljs-comment\"># in case we are finding minimum</span>\n            <span class=\"hljs-keyword\">if</span> change &gt; <span class=\"hljs-number\">0</span>:  <span class=\"hljs-comment\"># improves the solution</span>\n                next_state = picked_neighbor\n            <span class=\"hljs-keyword\">else</span>:\n                probability = (math.e) ** (\n                    change / current_temp\n                )  <span class=\"hljs-comment\"># probability generation function</span>\n                <span class=\"hljs-keyword\">if</span> random.random() &lt; probability:  <span class=\"hljs-comment\"># random number within probability</span>\n                    next_state = picked_neighbor\n        current_temp = current_temp - (current_temp * rate_of_decrease)\n\n        <span class=\"hljs-keyword\">if</span> current_temp &lt; threshold_temp <span class=\"hljs-keyword\">or</span> next_state <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:\n            <span class=\"hljs-comment\"># temperature below threshold, or could not find a suitable neighbor</span>\n            search_end = <span class=\"hljs-literal\">True</span>\n        <span class=\"hljs-keyword\">else</span>:\n            current_state = next_state\n\n    <span class=\"hljs-keyword\">if</span> visualization:\n        <span class=\"hljs-keyword\">from</span> matplotlib <span class=\"hljs-keyword\">import</span> pyplot <span class=\"hljs-keyword\">as</span> plt\n\n        plt.plot(<span class=\"hljs-built_in\">range</span>(iterations), scores)\n        plt.xlabel(<span class=\"hljs-string\">&quot;Iterations&quot;</span>)\n        plt.ylabel(<span class=\"hljs-string\">&quot;Function values&quot;</span>)\n        plt.show()\n    <span class=\"hljs-keyword\">return</span> best_state\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">test_f1</span>(<span class=\"hljs-params\">x, y</span>):\n        <span class=\"hljs-keyword\">return</span> (x ** <span class=\"hljs-number\">2</span>) + (y ** <span class=\"hljs-number\">2</span>)\n\n    <span class=\"hljs-comment\"># starting the problem with initial coordinates (12, 47)</span>\n    prob = SearchProblem(x=<span class=\"hljs-number\">12</span>, y=<span class=\"hljs-number\">47</span>, step_size=<span class=\"hljs-number\">1</span>, function_to_optimize=test_f1)\n    local_min = simulated_annealing(\n        prob, find_max=<span class=\"hljs-literal\">False</span>, max_x=<span class=\"hljs-number\">100</span>, min_x=<span class=\"hljs-number\">5</span>, max_y=<span class=\"hljs-number\">50</span>, min_y=-<span class=\"hljs-number\">5</span>, visualization=<span class=\"hljs-literal\">True</span>\n    )\n    <span class=\"hljs-built_in\">print</span>(\n        <span class=\"hljs-string\">&quot;The minimum score for f(x, y) = x^2 + y^2 with the domain 100 &gt; x &gt; 5 &quot;</span>\n        <span class=\"hljs-string\">f&quot;and 50 &gt; y &gt; - 5 found via hill climbing: <span class=\"hljs-subst\">{local_min.score()}</span>&quot;</span>\n    )\n\n    <span class=\"hljs-comment\"># starting the problem with initial coordinates (12, 47)</span>\n    prob = SearchProblem(x=<span class=\"hljs-number\">12</span>, y=<span class=\"hljs-number\">47</span>, step_size=<span class=\"hljs-number\">1</span>, function_to_optimize=test_f1)\n    local_min = simulated_annealing(\n        prob, find_max=<span class=\"hljs-literal\">True</span>, max_x=<span class=\"hljs-number\">100</span>, min_x=<span class=\"hljs-number\">5</span>, max_y=<span class=\"hljs-number\">50</span>, min_y=-<span class=\"hljs-number\">5</span>, visualization=<span class=\"hljs-literal\">True</span>\n    )\n    <span class=\"hljs-built_in\">print</span>(\n        <span class=\"hljs-string\">&quot;The maximum score for f(x, y) = x^2 + y^2 with the domain 100 &gt; x &gt; 5 &quot;</span>\n        <span class=\"hljs-string\">f&quot;and 50 &gt; y &gt; - 5 found via hill climbing: <span class=\"hljs-subst\">{local_min.score()}</span>&quot;</span>\n    )\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">test_f2</span>(<span class=\"hljs-params\">x, y</span>):\n        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">3</span> * x ** <span class=\"hljs-number\">2</span>) - (<span class=\"hljs-number\">6</span> * y)\n\n    prob = SearchProblem(x=<span class=\"hljs-number\">3</span>, y=<span class=\"hljs-number\">4</span>, step_size=<span class=\"hljs-number\">1</span>, function_to_optimize=test_f1)\n    local_min = simulated_annealing(prob, find_max=<span class=\"hljs-literal\">False</span>, visualization=<span class=\"hljs-literal\">True</span>)\n    <span class=\"hljs-built_in\">print</span>(\n        <span class=\"hljs-string\">&quot;The minimum score for f(x, y) = 3*x^2 - 6*y found via hill climbing: &quot;</span>\n        <span class=\"hljs-string\">f&quot;<span class=\"hljs-subst\">{local_min.score()}</span>&quot;</span>\n    )\n\n    prob = SearchProblem(x=<span class=\"hljs-number\">3</span>, y=<span class=\"hljs-number\">4</span>, step_size=<span class=\"hljs-number\">1</span>, function_to_optimize=test_f1)\n    local_min = simulated_annealing(prob, find_max=<span class=\"hljs-literal\">True</span>, visualization=<span class=\"hljs-literal\">True</span>)\n    <span class=\"hljs-built_in\">print</span>(\n        <span class=\"hljs-string\">&quot;The maximum score for f(x, y) = 3*x^2 - 6*y found via hill climbing: &quot;</span>\n        <span class=\"hljs-string\">f&quot;<span class=\"hljs-subst\">{local_min.score()}</span>&quot;</span>\n    )\n"
    }
  },
  "contributors": [
    {
      "name": "Dhruv Manilawala",
      "email": "dhruvmanila@gmail.com",
      "commits": 1
    },
    {
      "name": "matkosoric",
      "email": "soric.matko@gmail.com",
      "commits": 1
    },
    {
      "name": "Faraz Ahmed Khan",
      "email": "31242842+fk03983@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 4
    }
  ],
  "explanationUrl": {}
}
