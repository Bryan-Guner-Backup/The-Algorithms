{
  "slug": "lowest-common-ancestor",
  "name": "Lowest Common Ancestor",
  "categories": ["datastructures", "binarytree"],
  "body": {},
  "implementations": {
    "python": {
      "dir": "data_structures/binary_tree/lowest_common_ancestor.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/data_structures/binary_tree/lowest_common_ancestor.py",
      "code": "<span class=\"hljs-comment\"># https://en.wikipedia.org/wiki/Lowest_common_ancestor</span>\n<span class=\"hljs-comment\"># https://en.wikipedia.org/wiki/Breadth-first_search</span>\n\n<span class=\"hljs-keyword\">from</span> __future__ <span class=\"hljs-keyword\">import</span> annotations\n\n<span class=\"hljs-keyword\">import</span> queue\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">swap</span>(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">int</span>, b: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>]:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Return a tuple (b, a) when given two integers a and b\n    &gt;&gt;&gt; swap(2,3)\n    (3, 2)\n    &gt;&gt;&gt; swap(3,4)\n    (4, 3)\n    &gt;&gt;&gt; swap(67, 12)\n    (12, 67)\n    &quot;&quot;&quot;</span>\n    a ^= b\n    b ^= a\n    a ^= b\n    <span class=\"hljs-keyword\">return</span> a, b\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">create_sparse</span>(<span class=\"hljs-params\">max_node: <span class=\"hljs-built_in\">int</span>, parent: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]]</span>) -&gt; <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]]:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    creating sparse table which saves each nodes 2^i-th parent\n    &quot;&quot;&quot;</span>\n    j = <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span> &lt;&lt; j) &lt; max_node:\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, max_node + <span class=\"hljs-number\">1</span>):\n            parent[j][i] = parent[j - <span class=\"hljs-number\">1</span>][parent[j - <span class=\"hljs-number\">1</span>][i]]\n        j += <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">return</span> parent\n\n\n<span class=\"hljs-comment\"># returns lca of node u,v</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">lowest_common_ancestor</span>(<span class=\"hljs-params\">\n    u: <span class=\"hljs-built_in\">int</span>, v: <span class=\"hljs-built_in\">int</span>, level: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>], parent: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]]\n</span>) -&gt; <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]]:\n    <span class=\"hljs-comment\"># u must be deeper in the tree than v</span>\n    <span class=\"hljs-keyword\">if</span> level[u] &lt; level[v]:\n        u, v = swap(u, v)\n    <span class=\"hljs-comment\"># making depth of u same as depth of v</span>\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">18</span>, -<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>):\n        <span class=\"hljs-keyword\">if</span> level[u] - (<span class=\"hljs-number\">1</span> &lt;&lt; i) &gt;= level[v]:\n            u = parent[i][u]\n    <span class=\"hljs-comment\"># at the same depth if u==v that mean lca is found</span>\n    <span class=\"hljs-keyword\">if</span> u == v:\n        <span class=\"hljs-keyword\">return</span> u\n    <span class=\"hljs-comment\"># moving both nodes upwards till lca in found</span>\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">18</span>, -<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>):\n        <span class=\"hljs-keyword\">if</span> parent[i][u] != <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> parent[i][u] != parent[i][v]:\n            u, v = parent[i][u], parent[i][v]\n    <span class=\"hljs-comment\"># returning longest common ancestor of u,v</span>\n    <span class=\"hljs-keyword\">return</span> parent[<span class=\"hljs-number\">0</span>][u]\n\n\n<span class=\"hljs-comment\"># runs a breadth first search from root node of the tree</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">breadth_first_search</span>(<span class=\"hljs-params\">\n    level: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>],\n    parent: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]],\n    max_node: <span class=\"hljs-built_in\">int</span>,\n    graph: <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>],\n    root=<span class=\"hljs-number\">1</span>,\n</span>) -&gt; <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>], <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]]]:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    sets every nodes direct parent\n    parent of root node is set to 0\n    calculates depth of each node from root node\n    &quot;&quot;&quot;</span>\n    level[root] = <span class=\"hljs-number\">0</span>\n    q = queue.Queue(maxsize=max_node)\n    q.put(root)\n    <span class=\"hljs-keyword\">while</span> q.qsize() != <span class=\"hljs-number\">0</span>:\n        u = q.get()\n        <span class=\"hljs-keyword\">for</span> v <span class=\"hljs-keyword\">in</span> graph[u]:\n            <span class=\"hljs-keyword\">if</span> level[v] == -<span class=\"hljs-number\">1</span>:\n                level[v] = level[u] + <span class=\"hljs-number\">1</span>\n                q.put(v)\n                parent[<span class=\"hljs-number\">0</span>][v] = u\n    <span class=\"hljs-keyword\">return</span> level, parent\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">main</span>() -&gt; <span class=\"hljs-literal\">None</span>:\n    max_node = <span class=\"hljs-number\">13</span>\n    <span class=\"hljs-comment\"># initializing with 0</span>\n    parent = [[<span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(max_node + <span class=\"hljs-number\">10</span>)] <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">20</span>)]\n    <span class=\"hljs-comment\"># initializing with -1 which means every node is unvisited</span>\n    level = [-<span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(max_node + <span class=\"hljs-number\">10</span>)]\n    graph = {\n        <span class=\"hljs-number\">1</span>: [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>],\n        <span class=\"hljs-number\">2</span>: [<span class=\"hljs-number\">5</span>],\n        <span class=\"hljs-number\">3</span>: [<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>],\n        <span class=\"hljs-number\">4</span>: [<span class=\"hljs-number\">8</span>],\n        <span class=\"hljs-number\">5</span>: [<span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">10</span>],\n        <span class=\"hljs-number\">6</span>: [<span class=\"hljs-number\">11</span>],\n        <span class=\"hljs-number\">7</span>: [],\n        <span class=\"hljs-number\">8</span>: [<span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">13</span>],\n        <span class=\"hljs-number\">9</span>: [],\n        <span class=\"hljs-number\">10</span>: [],\n        <span class=\"hljs-number\">11</span>: [],\n        <span class=\"hljs-number\">12</span>: [],\n        <span class=\"hljs-number\">13</span>: [],\n    }\n    level, parent = breadth_first_search(level, parent, max_node, graph, <span class=\"hljs-number\">1</span>)\n    parent = create_sparse(max_node, parent)\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;LCA of node 1 and 3 is: &quot;</span>, lowest_common_ancestor(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, level, parent))\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;LCA of node 5 and 6 is: &quot;</span>, lowest_common_ancestor(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, level, parent))\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;LCA of node 7 and 11 is: &quot;</span>, lowest_common_ancestor(<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>, level, parent))\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;LCA of node 6 and 7 is: &quot;</span>, lowest_common_ancestor(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, level, parent))\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;LCA of node 4 and 12 is: &quot;</span>, lowest_common_ancestor(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">12</span>, level, parent))\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;LCA of node 8 and 8 is: &quot;</span>, lowest_common_ancestor(<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">8</span>, level, parent))\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    main()\n"
    },
    "c-plus-plus": {
      "dir": "graph/lowest_common_ancestor.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph/lowest_common_ancestor.cpp",
      "code": "<span class=\"hljs-comment\">/**\n *\n * \\file\n *\n * \\brief Data structure for finding the lowest common ancestor\n * of two vertices in a rooted tree using binary lifting.\n *\n * \\details\n * Algorithm: https://cp-algorithms.com/graph/lca_binary_lifting.html\n *\n * Complexity:\n *   - Precomputation: \\f$O(N \\log N)\\f$ where \\f$N\\f$ is the number of vertices\n * in the tree\n *   - Query: \\f$O(\\log N)\\f$\n *   - Space: \\f$O(N \\log N)\\f$\n *\n * Example:\n * &lt;br/&gt;  Tree:\n * &lt;pre&gt;\n *             _  3  _\n *          /     |     \\\n *        1       6       4\n *      / |     /   \\       \\\n *    7   5   2       8       0\n *            |\n *            9\n * &lt;/pre&gt;\n *\n * &lt;br/&gt;  lowest_common_ancestor(7, 4) = 3\n * &lt;br/&gt;  lowest_common_ancestor(9, 6) = 6\n * &lt;br/&gt;  lowest_common_ancestor(0, 0) = 0\n * &lt;br/&gt;  lowest_common_ancestor(8, 2) = 6\n *\n *   The query is symmetrical, therefore\n *     lowest_common_ancestor(x, y) = lowest_common_ancestor(y, x)\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;utility&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\n\n<span class=\"hljs-comment\">/**\n * \\namespace graph\n * \\brief Graph algorithms\n */</span>\n<span class=\"hljs-keyword\">namespace</span> graph {\n<span class=\"hljs-comment\">/**\n * Class for representing a graph as an adjacency list.\n * Its vertices are indexed 0, 1, ..., N - 1.\n */</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Graph</span> {\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-comment\">/**\n     * \\brief Populate the adjacency list for each vertex in the graph.\n     * Assumes that evey edge is a pair of valid vertex indices.\n     *\n     * @param N number of vertices in the graph\n     * @param undirected_edges list of graph&#x27;s undirected edges\n     */</span>\n    <span class=\"hljs-built_in\">Graph</span>(<span class=\"hljs-type\">size_t</span> N, <span class=\"hljs-keyword\">const</span> std::vector&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; &gt; &amp;undirected_edges) {\n        neighbors.<span class=\"hljs-built_in\">resize</span>(N);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;edge : undirected_edges) {\n            neighbors[edge.first].<span class=\"hljs-built_in\">push_back</span>(edge.second);\n            neighbors[edge.second].<span class=\"hljs-built_in\">push_back</span>(edge.first);\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Function to get the number of vertices in the graph\n     * @return the number of vertices in the graph.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">number_of_vertices</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span> </span>{ <span class=\"hljs-keyword\">return</span> neighbors.<span class=\"hljs-built_in\">size</span>(); }\n\n    <span class=\"hljs-comment\">/** \\brief for each vertex it stores a list indicies of its neighbors */</span>\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; neighbors;\n};\n\n<span class=\"hljs-comment\">/**\n * Representation of a rooted tree. For every vertex its parent is\n * precalculated.\n */</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RootedTree</span> : <span class=\"hljs-keyword\">public</span> Graph {\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-comment\">/**\n     * \\brief Constructs the tree by calculating parent for every vertex.\n     * Assumes a valid description of a tree is provided.\n     *\n     * @param undirected_edges list of graph&#x27;s undirected edges\n     * @param root_ index of the root vertex\n     */</span>\n    <span class=\"hljs-built_in\">RootedTree</span>(<span class=\"hljs-keyword\">const</span> std::vector&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; &gt; &amp;undirected_edges,\n               <span class=\"hljs-type\">int</span> root_)\n        : <span class=\"hljs-built_in\">Graph</span>(undirected_edges.<span class=\"hljs-built_in\">size</span>() + <span class=\"hljs-number\">1</span>, undirected_edges), <span class=\"hljs-built_in\">root</span>(root_) {\n        <span class=\"hljs-built_in\">populate_parents</span>();\n    }\n\n    <span class=\"hljs-comment\">/**\n     * \\brief Stores parent of every vertex and for root its own index.\n     * The root is technically not its own parent, but it&#x27;s very practical\n     * for the lowest common ancestor algorithm.\n     */</span>\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; parent;\n    <span class=\"hljs-comment\">/** \\brief Stores the distance from the root. */</span>\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; level;\n    <span class=\"hljs-comment\">/** \\brief Index of the root vertex. */</span>\n    <span class=\"hljs-type\">int</span> root;\n\n <span class=\"hljs-keyword\">protected</span>:\n    <span class=\"hljs-comment\">/**\n     * \\brief Calculate the parents for all the vertices in the tree.\n     * Implements the breadth first search algorithm starting from the root\n     * vertex searching the entire tree and labeling parents for all vertices.\n     * @returns none\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">populate_parents</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// Initialize the vector with -1 which indicates the vertex</span>\n        <span class=\"hljs-comment\">// wasn&#x27;t yet visited.</span>\n        parent = std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(<span class=\"hljs-built_in\">number_of_vertices</span>(), <span class=\"hljs-number\">-1</span>);\n        level = std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(<span class=\"hljs-built_in\">number_of_vertices</span>());\n        parent[root] = root;\n        level[root] = <span class=\"hljs-number\">0</span>;\n        std::queue&lt;<span class=\"hljs-type\">int</span>&gt; queue_of_vertices;\n        queue_of_vertices.<span class=\"hljs-built_in\">push</span>(root);\n        <span class=\"hljs-keyword\">while</span> (!queue_of_vertices.<span class=\"hljs-built_in\">empty</span>()) {\n            <span class=\"hljs-type\">int</span> vertex = queue_of_vertices.<span class=\"hljs-built_in\">front</span>();\n            queue_of_vertices.<span class=\"hljs-built_in\">pop</span>();\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> neighbor : neighbors[vertex]) {\n                <span class=\"hljs-comment\">// As long as the vertex was not yet visited.</span>\n                <span class=\"hljs-keyword\">if</span> (parent[neighbor] == <span class=\"hljs-number\">-1</span>) {\n                    parent[neighbor] = vertex;\n                    level[neighbor] = level[vertex] + <span class=\"hljs-number\">1</span>;\n                    queue_of_vertices.<span class=\"hljs-built_in\">push</span>(neighbor);\n                }\n            }\n        }\n    }\n};\n\n<span class=\"hljs-comment\">/**\n * A structure that holds a rooted tree and allow for effecient\n * queries of the lowest common ancestor of two given vertices in the tree.\n */</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LowestCommonAncestor</span> {\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-comment\">/**\n     * \\brief Stores the tree and precomputs &quot;up lifts&quot;.\n     * @param tree_ rooted tree.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">LowestCommonAncestor</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> RootedTree &amp;tree_)</span> : tree(tree_) {</span>\n        <span class=\"hljs-built_in\">populate_up</span>();\n    }\n\n    <span class=\"hljs-comment\">/**\n     * \\brief Query the structure to find the lowest common ancestor.\n     * Assumes that the provided numbers are valid indices of vertices.\n     * Iterativelly modifies (&quot;lifts&quot;) u an v until it finnds their lowest\n     * common ancestor.\n     * @param u index of one of the queried vertex\n     * @param v index of the other queried vertex\n     * @return index of the vertex which is the lowet common ancestor of u and v\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">lowest_common_ancestor</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u, <span class=\"hljs-type\">int</span> v)</span> <span class=\"hljs-keyword\">const</span> </span>{\n        <span class=\"hljs-comment\">// Ensure u is the deeper (higher level) of the two vertices</span>\n        <span class=\"hljs-keyword\">if</span> (tree.level[v] &gt; tree.level[u]) {\n            std::<span class=\"hljs-built_in\">swap</span>(u, v);\n        }\n\n        <span class=\"hljs-comment\">// &quot;Lift&quot; u to the same level as v.</span>\n        <span class=\"hljs-type\">int</span> level_diff = tree.level[u] - tree.level[v];\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; (<span class=\"hljs-number\">1</span> &lt;&lt; i) &lt;= level_diff; ++i) {\n            <span class=\"hljs-keyword\">if</span> (level_diff &amp; (<span class=\"hljs-number\">1</span> &lt;&lt; i)) {\n                u = up[u][i];\n            }\n        }\n        <span class=\"hljs-built_in\">assert</span>(tree.level[u] == tree.level[v]);\n\n        <span class=\"hljs-keyword\">if</span> (u == v) {\n            <span class=\"hljs-keyword\">return</span> u;\n        }\n\n        <span class=\"hljs-comment\">// &quot;Lift&quot; u and v to their 2^i th ancestor if they are different</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(up[u].<span class=\"hljs-built_in\">size</span>()) - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; --i) {\n            <span class=\"hljs-keyword\">if</span> (up[u][i] != up[v][i]) {\n                u = up[u][i];\n                v = up[v][i];\n            }\n        }\n\n        <span class=\"hljs-comment\">// As we regressed u an v such that they cannot further be lifted so</span>\n        <span class=\"hljs-comment\">// that their ancestor would be different, the only logical</span>\n        <span class=\"hljs-comment\">// consequence is that their parent is the sought answer.</span>\n        <span class=\"hljs-built_in\">assert</span>(up[u][<span class=\"hljs-number\">0</span>] == up[v][<span class=\"hljs-number\">0</span>]);\n        <span class=\"hljs-keyword\">return</span> up[u][<span class=\"hljs-number\">0</span>];\n    }\n\n    <span class=\"hljs-comment\">/* \\brief reference to the rooted tree this structure allows to query */</span>\n    <span class=\"hljs-keyword\">const</span> RootedTree &amp;tree;\n    <span class=\"hljs-comment\">/**\n     * \\brief for every vertex stores a list of its ancestors by powers of two\n     * For each vertex, the first element of the corresponding list contains\n     * the index of its parent. The i-th element of the list is an index of\n     * the (2^i)-th ancestor of the vertex.\n     */</span>\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; up;\n\n <span class=\"hljs-keyword\">protected</span>:\n    <span class=\"hljs-comment\">/**\n     * Populate the &quot;up&quot; structure. See above.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">populate_up</span><span class=\"hljs-params\">()</span> </span>{\n        up.<span class=\"hljs-built_in\">resize</span>(tree.<span class=\"hljs-built_in\">number_of_vertices</span>());\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> vertex = <span class=\"hljs-number\">0</span>; vertex &lt; tree.<span class=\"hljs-built_in\">number_of_vertices</span>(); ++vertex) {\n            up[vertex].<span class=\"hljs-built_in\">push_back</span>(tree.parent[vertex]);\n        }\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> level = <span class=\"hljs-number\">0</span>; (<span class=\"hljs-number\">1</span> &lt;&lt; level) &lt; tree.<span class=\"hljs-built_in\">number_of_vertices</span>(); ++level) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> vertex = <span class=\"hljs-number\">0</span>; vertex &lt; tree.<span class=\"hljs-built_in\">number_of_vertices</span>(); ++vertex) {\n                <span class=\"hljs-comment\">// up[vertex][level + 1] = 2^(level + 1) th ancestor of vertex =</span>\n                <span class=\"hljs-comment\">// = 2^level th ancestor of 2^level th ancestor of vertex =</span>\n                <span class=\"hljs-comment\">// = 2^level th ancestor of up[vertex][level]</span>\n                up[vertex].<span class=\"hljs-built_in\">push_back</span>(up[up[vertex][level]][level]);\n            }\n        }\n    }\n};\n\n}  <span class=\"hljs-comment\">// namespace graph</span>\n\n<span class=\"hljs-comment\">/**\n * Unit tests\n * @returns none\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">tests</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">/**\n     *             _  3  _\n     *          /     |     \\\n     *        1       6       4\n     *      / |     /   \\       \\\n     *    7   5   2       8       0\n     *            |\n     *            9\n     */</span>\n    std::vector&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; &gt; edges = {\n        {<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">1</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>}, {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>}, {<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">9</span>}, {<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>}, {<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>}, {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">4</span>}};\n    <span class=\"hljs-function\">graph::RootedTree <span class=\"hljs-title\">t</span><span class=\"hljs-params\">(edges, <span class=\"hljs-number\">3</span>)</span></span>;\n    <span class=\"hljs-function\">graph::LowestCommonAncestor <span class=\"hljs-title\">lca</span><span class=\"hljs-params\">(t)</span></span>;\n    <span class=\"hljs-built_in\">assert</span>(lca.<span class=\"hljs-built_in\">lowest_common_ancestor</span>(<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">4</span>) == <span class=\"hljs-number\">3</span>);\n    <span class=\"hljs-built_in\">assert</span>(lca.<span class=\"hljs-built_in\">lowest_common_ancestor</span>(<span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">6</span>) == <span class=\"hljs-number\">6</span>);\n    <span class=\"hljs-built_in\">assert</span>(lca.<span class=\"hljs-built_in\">lowest_common_ancestor</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>) == <span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-built_in\">assert</span>(lca.<span class=\"hljs-built_in\">lowest_common_ancestor</span>(<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">2</span>) == <span class=\"hljs-number\">6</span>);\n}\n\n<span class=\"hljs-comment\">/** Main function */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">tests</span>();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "David Leal",
      "email": "halfpacho@gmail.com",
      "commits": 1
    },
    {
      "name": "kanthuc",
      "email": "srikanthuchavali@gmail.com",
      "commits": 1
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 2
    },
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 3
    }
  ],
  "explanationUrl": {}
}
