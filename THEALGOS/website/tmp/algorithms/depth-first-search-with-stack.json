{
  "slug": "depth-first-search-with-stack",
  "name": "Depth First Search with Stack",
  "categories": ["graphs"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "graph/depth_first_search_with_stack.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph/depth_first_search_with_stack.cpp",
      "code": "<span class=\"hljs-comment\">/**\n *\n * @file\n * @brief [Depth First Search Algorithm using Stack\n * (Depth First Search Algorithm)](https://en.wikipedia.org/wiki/Depth-first_search)\n *\n * @author [Ayaan Khan](http://github.com/ayaankhan98)\n * @author [Saurav Uppoor](https://github.com/sauravUppoor)\n *\n * @details\n * Depth First Search also quoted as DFS is a Graph Traversal Algorithm.\n * Time Complexity O(|V| + |E|) where V is number of vertices and E\n * is number of edges in graph.\n *\n * Application of Depth First Search are\n *\n * 1. Finding connected components\n * 2. Finding 2-(edge or vertex)-connected components.\n * 3. Finding 3-(edge or vertex)-connected components.\n * 4. Finding the bridges of a graph.\n * 5. Generating words in order to plot the limit set of a group.\n * 6. Finding strongly connected components.\n *\n * &lt;h4&gt;Working&lt;/h4&gt;\n * 1. Mark all vertices as unvisited (colour it WHITE).\n * 2. Push starting vertex into the stack and colour it GREY.\n * 3. Once a node is popped out of the stack and is coloured GREY, we colour it BLACK.\n * 4. Push all its neighbours which are not coloured BLACK.\n * 5. Repeat steps 4 and 5 until the stack is empty.\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span> \t <span class=\"hljs-comment\">/// for IO operations</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span>    \t <span class=\"hljs-comment\">/// header for std::stack</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>   \t <span class=\"hljs-comment\">/// header for std::vector</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>  \t <span class=\"hljs-comment\">/// header for preprocessor macro assert() </span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;limits&gt;</span>   \t <span class=\"hljs-comment\">/// header for limits of integral types</span></span>\n\n<span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> WHITE = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">/// indicates the node hasn&#x27;t been explored</span>\n<span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> GREY = <span class=\"hljs-number\">1</span>;\t <span class=\"hljs-comment\">/// indicates node is in stack waiting to be explored</span>\n<span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int</span> BLACK = <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">/// indicates node has already been explored</span>\n<span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int64_t</span> INF = std::numeric_limits&lt;<span class=\"hljs-type\">int16_t</span>&gt;::<span class=\"hljs-built_in\">max</span>();\n\n\n<span class=\"hljs-comment\">/**\n * @namespace graph\n * @brief Graph algorithms\n */</span>\n<span class=\"hljs-keyword\">namespace</span> graph {\n<span class=\"hljs-comment\">/**\n * @namespace depth_first_search\n * @brief Functions for [Depth First Search](https://en.wikipedia.org/wiki/Depth-first_search) algorithm\n */</span>\n<span class=\"hljs-keyword\">namespace</span> depth_first_search {\n<span class=\"hljs-comment\">/**\n * @brief\n * Adds and edge between two vertices of graph say u and v in this\n * case.\n *\n * @param adj Adjacency list representation of graph\n * @param u first vertex\n * @param v second vertex\n *\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addEdge</span><span class=\"hljs-params\">(std::vector&lt;std::vector&lt;<span class=\"hljs-type\">size_t</span>&gt;&gt; *adj, <span class=\"hljs-type\">size_t</span> u, <span class=\"hljs-type\">size_t</span> v)</span> </span>{\n\t<span class=\"hljs-comment\">/*\n\t*\n\t* Here we are considering undirected graph that&#x27;s the\n\t* reason we are adding v to the adjacency list representation of u\n\t* and also adding u to the adjacency list representation of v\n\t*\n\t*/</span>\n\t(*adj)[u - <span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">push_back</span>(v - <span class=\"hljs-number\">1</span>);\n}\n\n<span class=\"hljs-comment\">/**\n *\n * @brief\n * Explores the given vertex, exploring a vertex means traversing\n * over all the vertices which are connected to the vertex that is\n * currently being explored and push it onto the stack.\n *\n * @param adj graph\n * @param start starting vertex for DFS\n * @return vector with nodes stored in the order of DFS traversal\n *\n */</span>\n<span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::vector&lt;std::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; &gt; &amp;graph, <span class=\"hljs-type\">size_t</span> start)</span> </span>{\n    <span class=\"hljs-comment\">/// checked[i] stores the status of each node</span>\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; <span class=\"hljs-title\">checked</span><span class=\"hljs-params\">(graph.size(), WHITE)</span>, traversed_path</span>;\n\n    checked[start] = GREY;\n    std::stack&lt;<span class=\"hljs-type\">size_t</span>&gt; stack;\n    stack.<span class=\"hljs-built_in\">push</span>(start);\n\n    <span class=\"hljs-comment\">/// while stack is not empty we keep exploring the node on top of stack</span>\n    <span class=\"hljs-keyword\">while</span> (!stack.<span class=\"hljs-built_in\">empty</span>()) {\n        <span class=\"hljs-type\">int</span> act = stack.<span class=\"hljs-built_in\">top</span>();\n        stack.<span class=\"hljs-built_in\">pop</span>();\n\n        <span class=\"hljs-keyword\">if</span> (checked[act] == GREY) {\n            <span class=\"hljs-comment\">/// push the node to the final result vector</span>\n            traversed_path.<span class=\"hljs-built_in\">push_back</span>(act + <span class=\"hljs-number\">1</span>);\n\n            <span class=\"hljs-comment\">/// exploring the neighbours of the current node</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it : graph[act]) {\n                stack.<span class=\"hljs-built_in\">push</span>(it);\n                <span class=\"hljs-keyword\">if</span> (checked[it] != BLACK) {\n                    checked[it] = GREY;\n                }\n            }\n            checked[act] = BLACK;  <span class=\"hljs-comment\">/// Node has been explored</span>\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> traversed_path;\n}\n}  <span class=\"hljs-comment\">// namespace depth_first_search</span>\n}  <span class=\"hljs-comment\">// namespace graph</span>\n\n<span class=\"hljs-comment\">/**\n * Self-test implementations\n * @returns none\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">tests</span><span class=\"hljs-params\">()</span> </span>{\n\t<span class=\"hljs-type\">size_t</span> start_pos;\n\n\t<span class=\"hljs-comment\">/// Test 1</span>\n\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Case 1: &quot;</span> &lt;&lt; std::endl;\n\tstart_pos = <span class=\"hljs-number\">1</span>;\n\tstd::vector&lt;std::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; &gt; <span class=\"hljs-built_in\">g1</span>(<span class=\"hljs-number\">3</span>, std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">size_t</span>&gt;());\n\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g1, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g1, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g1, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span>);\n\n\tstd::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; expected1 {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}; <span class=\"hljs-comment\">/// for the above sample data, this is the expected output</span>\n\t<span class=\"hljs-built_in\">assert</span>(graph::depth_first_search::<span class=\"hljs-built_in\">dfs</span>(g1, start_pos - <span class=\"hljs-number\">1</span>) == expected1);\n\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Passed&quot;</span> &lt;&lt; std::endl;\n\n\t<span class=\"hljs-comment\">/// Test 2</span>\n\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Case 2: &quot;</span> &lt;&lt; std::endl;\n\tstart_pos = <span class=\"hljs-number\">1</span>;\n\tstd::vector&lt;std::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; &gt; <span class=\"hljs-built_in\">g2</span>(<span class=\"hljs-number\">4</span>, std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">size_t</span>&gt;());\n\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g2, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g2, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>);\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g2, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>);\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g2, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>);\n\n\tstd::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; expected2 {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>}; <span class=\"hljs-comment\">/// for the above sample data, this is the expected output</span>\n\t<span class=\"hljs-built_in\">assert</span>(graph::depth_first_search::<span class=\"hljs-built_in\">dfs</span>(g2, start_pos - <span class=\"hljs-number\">1</span>) == expected2);\n\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Passed&quot;</span> &lt;&lt; std::endl;\n\n\t<span class=\"hljs-comment\">/// Test 3</span>\n\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Case 3: &quot;</span> &lt;&lt; std::endl;\n\tstart_pos = <span class=\"hljs-number\">2</span>;\n\tstd::vector&lt;std::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; &gt; <span class=\"hljs-built_in\">g3</span>(<span class=\"hljs-number\">4</span>, std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">size_t</span>&gt;());\n\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g3, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g3, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>);\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g3, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>);\n\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;g3, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>);\n\n\tstd::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; expected3 {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>}; <span class=\"hljs-comment\">/// for the above sample data, this is the expected output</span>\n\t<span class=\"hljs-built_in\">assert</span>(graph::depth_first_search::<span class=\"hljs-built_in\">dfs</span>(g3, start_pos - <span class=\"hljs-number\">1</span>) == expected3);\n\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Passed&quot;</span> &lt;&lt; std::endl;\n\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Main function\n * @returns 0 on exit\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">tests</span>();  <span class=\"hljs-comment\">// execute the tests</span>\n\n    <span class=\"hljs-type\">size_t</span> vertices = <span class=\"hljs-number\">0</span>, edges = <span class=\"hljs-number\">0</span>, start_pos = <span class=\"hljs-number\">1</span>;\n\tstd::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; traversal;\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the Vertices : &quot;</span>;\n\tstd::cin &gt;&gt; vertices;\n\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the Edges : &quot;</span>;\n\tstd::cin &gt;&gt; edges;\n\n    <span class=\"hljs-comment\">/// creating a graph</span>\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">size_t</span>&gt; &gt; <span class=\"hljs-built_in\">adj</span>(vertices, std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">size_t</span>&gt;());\n\n    <span class=\"hljs-comment\">/// taking input for the edges</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the vertices which have edges between them : &quot;</span> &lt;&lt; std::endl;\n\t<span class=\"hljs-keyword\">while</span> (edges--) {\n\t\t<span class=\"hljs-type\">size_t</span> u = <span class=\"hljs-number\">0</span>, v = <span class=\"hljs-number\">0</span>;\n\t\tstd::cin &gt;&gt; u &gt;&gt; v;\n\t\tgraph::depth_first_search::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj, u, v);\n\t}\n\n    <span class=\"hljs-comment\">/// taking input for the starting position</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the starting vertex [1,n]: &quot;</span> &lt;&lt; std::endl;\n\tstd::cin &gt;&gt; start_pos;\n\tstart_pos -= <span class=\"hljs-number\">1</span>;\n\ttraversal = graph::depth_first_search::<span class=\"hljs-built_in\">dfs</span>(adj, start_pos);\n\n    <span class=\"hljs-comment\">/// Printing the order of traversal</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> x : traversal) {\n\t\tstd::cout &lt;&lt; x &lt;&lt; <span class=\"hljs-string\">&#x27; &#x27;</span>;\n\t}\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 1
    },
    {
      "name": "Saurav Uppoor",
      "email": "41644947+sauravUppoor@users.noreply.github.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}
