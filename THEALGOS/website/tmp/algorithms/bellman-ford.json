{
  "slug": "bellman-ford",
  "name": "Bellman Ford",
  "categories": ["graphs"],
  "body": {
    "en": "<h4>Problem Statement</h4>\n<p>Given a weighted directed graph G(V,E) and a source vertex s ∈ V, determine for each vertex v ∈ V the shortest path between s and v.</p>\n<h4>Approach</h4>\n<ul>\n<li>Initialize the distance from the source to all vertices as infinite.</li>\n<li>Initialize the distance to itself as 0.</li>\n<li>Create an array dist[] of size |V| with all values as infinite except dist[s].</li>\n<li>Repeat the following |V| - 1 times. Where |V| is number of vertices.</li>\n<li>Create another loop to go through each edge (u, v) in E and do the following:\n<ol>\n<li>dist[v] = minimum(dist[v], dist[u] + weight of edge).</li>\n</ol>\n</li>\n<li>Lastly iterate through all edges on last time to make sure there are no negatively weighted cycles.</li>\n</ul>\n<h4>Time Complexity</h4>\n<p>O(VE)</p>\n<h4>Space Complexity</h4>\n<p>O(V^2)</p>\n<h4>Founder's Name</h4>\n<ul>\n<li>Richard Bellman &#x26; Lester Ford, Jr.</li>\n</ul>\n<h4>Example</h4>\n<pre><code class=\"hljs language-json\">    # of vertices in graph = <span class=\"hljs-number\">5</span> [A, B, C, D, E]\n    # of edges in graph = <span class=\"hljs-number\">8</span> \n\n    edges  [A->B, A->C, B->C, B->D, B->E, D->C, D->B, E->D]\n    weight [ <span class=\"hljs-number\">-1</span>,    <span class=\"hljs-number\">4</span>,    <span class=\"hljs-number\">3</span>,    <span class=\"hljs-number\">2</span>,    <span class=\"hljs-number\">2</span>,    <span class=\"hljs-number\">5</span>,    <span class=\"hljs-number\">1</span>,   <span class=\"hljs-number\">-4</span> ]\n    source [  A,    A,    B,    B,    B,    D,    D,    E ]\n\n\n\n    <span class=\"hljs-comment\">// edge A->B </span>\n    graph->edge[<span class=\"hljs-number\">0</span>].src = A \n    graph->edge[<span class=\"hljs-number\">0</span>].dest = B \n    graph->edge[<span class=\"hljs-number\">0</span>].weight = <span class=\"hljs-number\">-1</span> \n  \n    <span class=\"hljs-comment\">// edge A->C </span>\n    graph->edge[<span class=\"hljs-number\">1</span>].src = A \n    graph->edge[<span class=\"hljs-number\">1</span>].dest = C \n    graph->edge[<span class=\"hljs-number\">1</span>].weight = <span class=\"hljs-number\">4</span> \n  \n    <span class=\"hljs-comment\">// edge B->C </span>\n    graph->edge[<span class=\"hljs-number\">2</span>].src = B \n    graph->edge[<span class=\"hljs-number\">2</span>].dest = C \n    graph->edge[<span class=\"hljs-number\">2</span>].weight = <span class=\"hljs-number\">3</span> \n  \n    <span class=\"hljs-comment\">// edge B->D </span>\n    graph->edge[<span class=\"hljs-number\">3</span>].src = B \n    graph->edge[<span class=\"hljs-number\">3</span>].dest = D \n    graph->edge[<span class=\"hljs-number\">3</span>].weight = <span class=\"hljs-number\">2</span> \n  \n    <span class=\"hljs-comment\">// edge B->E </span>\n    graph->edge[<span class=\"hljs-number\">4</span>].src = B \n    graph->edge[<span class=\"hljs-number\">4</span>].dest = E \n    graph->edge[<span class=\"hljs-number\">4</span>].weight = <span class=\"hljs-number\">2</span> \n  \n    <span class=\"hljs-comment\">// edge D->C </span>\n    graph->edge[<span class=\"hljs-number\">5</span>].src = D\n    graph->edge[<span class=\"hljs-number\">5</span>].dest = C \n    graph->edge[<span class=\"hljs-number\">5</span>].weight = <span class=\"hljs-number\">5</span> \n  \n    <span class=\"hljs-comment\">// edge D->B </span>\n    graph->edge[<span class=\"hljs-number\">6</span>].src = D\n    graph->edge[<span class=\"hljs-number\">6</span>].dest = B \n    graph->edge[<span class=\"hljs-number\">6</span>].weight = <span class=\"hljs-number\">1</span> \n  \n    <span class=\"hljs-comment\">// edge E->D </span>\n    graph->edge[<span class=\"hljs-number\">7</span>].src = E\n    graph->edge[<span class=\"hljs-number\">7</span>].dest = D \n    graph->edge[<span class=\"hljs-number\">7</span>].weight = <span class=\"hljs-number\">-3</span>\n\n    for source = A\n\n    Vertex   Distance from Source\n\tA                <span class=\"hljs-number\">0</span>\t\t\t\tA->A\n\tB                <span class=\"hljs-number\">-1</span>\t\t\t\tA->B\n\tC                <span class=\"hljs-number\">2</span> \t\t\t\tA->B->C = <span class=\"hljs-number\">-1</span> + <span class=\"hljs-number\">3</span>\n\tD                <span class=\"hljs-number\">-2</span>\t\t\t\tA->B->E->D = <span class=\"hljs-number\">-1</span> + <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">-3</span>\n\tE                <span class=\"hljs-number\">1</span>\t\t\t\tA->B->E = <span class=\"hljs-number\">-1</span> + <span class=\"hljs-number\">2</span>\n</code></pre>\n<h4>Code Implementation Links</h4>\n<ul>\n<li><a href=\"https://github.com/TheAlgorithms/Java/blob/master/DataStructures/Graphs/BellmanFord.java\">Java</a></li>\n<li><a href=\"https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/Dynamic%20Programming/Bellman-Ford.cpp\">C++</a></li>\n<li><a href=\"https://github.com/TheAlgorithms/Python/blob/master/data_structures/graph/bellman_ford.py\">Python</a></li>\n<li><a href=\"https://github.com/TheAlgorithms/C/blob/master/data_structures/graphs/Bellman-Ford.c\">C</a></li>\n</ul>\n<h4>Video Explanation</h4>\n<p><a href=\"https://www.youtube.com/watch?v=hxMWBBCpR6A\">A video explaining the Bellman-Ford Algorithm</a></p>\n<h4>Others</h4>\n<p>Sources Used:</p>\n<ul>\n<li><a href=\"https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/\">https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\">https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm</a></li>\n</ul>",
    "es": "<h4>Declaración de problema</h4>\n<p>Dado un gráfico dirigido ponderado <code>G(V,E)</code> y un vértice de origen s ∈ V, determine para cada <code>v v v ∈ V</code> el trayecto más corto entre <code>s</code> y <code>v</code>.</p>\n<h4>Enfoque</h4>\n<ul>\n<li>Inicializar la distancia de la fuente a todos los vértices como infinito.</li>\n<li>Inicializar la distancia a sí mismo como 0.</li>\n<li>Crear una matriz dist[] de tamaño | V| con todos los valores como infinitos excepto dist[s].</li>\n<li>Repita los siguientes |V| - 1 vez, dónde |V| es el número de vértices.</li>\n<li>Crear otro bucle para ir a través de cada borde <code>(u, v)</code> en E y hacer lo siguiente:\n<ol>\n<li><code>dist[v] = minimum(dist[v], dist[u] + peso de borde</code>.</li>\n</ol>\n</li>\n<li>Por último, iterar a través de todos los bordes en la última vez, para asegurarse de que no hay ciclos ponderados negativamente.</li>\n</ul>\n<h4>Complejidad horaria</h4>\n<p><code>O(VE)</code></p>\n<h4>Complejidad espacial</h4>\n<p><code>O(V^2)</code></p>\n<h4>Nombre del Fundador</h4>\n<ul>\n<li>Richard Bellman &#x26; Lester Ford, Jr.</li>\n</ul>\n<h4>Ejemplo</h4>\n<pre><code class=\"hljs language-markdown\"><span class=\"hljs-section\"># de vértices en el gráfico = 5 [A, B, C, D, E]</span>\n<span class=\"hljs-section\"># de bordes en gráfico = 8</span>\n\nbordes [A->B, A->C, B->C, B->D, B->E, D->C, D->B, E->D]\npeso [ -1, 4, 3, 2, 2, 5, 1, -4 ]\nfuente [ A, A, B, B, B, D, D, E ]\n\nborde A->B\ngraph->edge[0].src = A\ngraph->edge[0].dest = B\ngraph->edge[0].weight = -1\n\nborde A->C\ngraph->edge[1] .src = A\ngraph->edge[1].dest = C\ngráfico->edge[1] .weight = 4\n\nborde B->C\ngraph->edge[2].src = B\ngraph->edge[2].dest = C\ngráfico->edge[2].peso = 3\n\nborde B->D\ngráfico->edge[3] .src = B\ngraph->edge[3] .dest = D\ngráfico->edge[3] .peso = 2\n\nborde B->E\ngraph->edge[4].src = B\ngraph->edge[4].dest = E\ngráfico->edge[4].peso = 2\n\nborde D->C\ngraph->edge[5].src = D\ngraph->edge[5].dest = C\ngráfico->edge[5].peso = 5\n\nborde D->B\ngraph->edge[6] .src = D\ngraph->edge[6].dest = B\ngráfico->edge[6].weight = 1\n\nborde E->D\ngraph->edge[7] .src = E\ngraph->edge[7].dest = D\ngráfico->edge[7].weight = -3\n\npara la fuente = A\n\nDistancia de vértice desde la fuente\nA 0 A->A\nB -1 A->B\nC 2 A->B->C = -1 + 3\nD -2 A->B->E->D = -1 + 2 + -3\nE 1 A->B->E = -1 + 2\n</code></pre>\n<h4>Enlaces de implementación de código</h4>\n<ul>\n<li><a href=\"https://github.com/TheAlgorithms/Java/blob/master/DataStructures/Graphs/BellmanFord.java\">Java</a></li>\n<li><a href=\"https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/Dynamic%20Programming/Bellman-Ford.cpp\">C++</a></li>\n<li><a href=\"https://github.com/TheAlgorithms/Python/blob/master/data_structures/graph/bellman_ford.py\">Python</a></li>\n<li><a href=\"https://github.com/TheAlgorithms/C/blob/master/data_structures/graphs/Bellman-Ford.c\">C</a></li>\n</ul>\n<h4>Explicación de vídeo</h4>\n<p><a href=\"https://www.youtube.com/watch?v=hxMWBBCpR6A\">Un video explicando el algoritmo Bellman Ford</a></p>\n<h4>Otros</h4>\n<p>Fuentes utilizadas:</p>\n<ul>\n<li><a href=\"https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/\">https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\">https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm</a></li>\n</ul>"
  },
  "implementations": {
    "python": {
      "dir": "graphs/bellman_ford.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/graphs/bellman_ford.py",
      "code": "<span class=\"hljs-keyword\">from</span> __future__ <span class=\"hljs-keyword\">import</span> annotations\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">print_distance</span>(<span class=\"hljs-params\">distance: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">float</span>], src</span>):\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;Vertex\\tShortest Distance from vertex <span class=\"hljs-subst\">{src}</span>&quot;</span>)\n    <span class=\"hljs-keyword\">for</span> i, d <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(distance):\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;<span class=\"hljs-subst\">{i}</span>\\t\\t<span class=\"hljs-subst\">{d}</span>&quot;</span>)\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">check_negative_cycle</span>(<span class=\"hljs-params\">\n    graph: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">int</span>]], distance: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">float</span>], edge_count: <span class=\"hljs-built_in\">int</span>\n</span>):\n    <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(edge_count):\n        u, v, w = [graph[j][k] <span class=\"hljs-keyword\">for</span> k <span class=\"hljs-keyword\">in</span> [<span class=\"hljs-string\">&quot;src&quot;</span>, <span class=\"hljs-string\">&quot;dst&quot;</span>, <span class=\"hljs-string\">&quot;weight&quot;</span>]]\n        <span class=\"hljs-keyword\">if</span> distance[u] != <span class=\"hljs-built_in\">float</span>(<span class=\"hljs-string\">&quot;inf&quot;</span>) <span class=\"hljs-keyword\">and</span> distance[u] + w &lt; distance[v]:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">bellman_ford</span>(<span class=\"hljs-params\">\n    graph: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">int</span>]], vertex_count: <span class=\"hljs-built_in\">int</span>, edge_count: <span class=\"hljs-built_in\">int</span>, src: <span class=\"hljs-built_in\">int</span>\n</span>) -&gt; <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">float</span>]:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Returns shortest paths from a vertex src to all\n    other vertices.\n    &gt;&gt;&gt; edges = [(2, 1, -10), (3, 2, 3), (0, 3, 5), (0, 1, 4)]\n    &gt;&gt;&gt; g = [{&quot;src&quot;: s, &quot;dst&quot;: d, &quot;weight&quot;: w} for s, d, w in edges]\n    &gt;&gt;&gt; bellman_ford(g, 4, 4, 0)\n    [0.0, -2.0, 8.0, 5.0]\n    &gt;&gt;&gt; g = [{&quot;src&quot;: s, &quot;dst&quot;: d, &quot;weight&quot;: w} for s, d, w in edges + [(1, 3, 5)]]\n    &gt;&gt;&gt; bellman_ford(g, 4, 5, 0)\n    Traceback (most recent call last):\n     ...\n    Exception: Negative cycle found\n    &quot;&quot;&quot;</span>\n    distance = [<span class=\"hljs-built_in\">float</span>(<span class=\"hljs-string\">&quot;inf&quot;</span>)] * vertex_count\n    distance[src] = <span class=\"hljs-number\">0.0</span>\n\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(vertex_count - <span class=\"hljs-number\">1</span>):\n        <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(edge_count):\n            u, v, w = [graph[j][k] <span class=\"hljs-keyword\">for</span> k <span class=\"hljs-keyword\">in</span> [<span class=\"hljs-string\">&quot;src&quot;</span>, <span class=\"hljs-string\">&quot;dst&quot;</span>, <span class=\"hljs-string\">&quot;weight&quot;</span>]]\n\n            <span class=\"hljs-keyword\">if</span> distance[u] != <span class=\"hljs-built_in\">float</span>(<span class=\"hljs-string\">&quot;inf&quot;</span>) <span class=\"hljs-keyword\">and</span> distance[u] + w &lt; distance[v]:\n                distance[v] = distance[u] + w\n\n    negative_cycle_exists = check_negative_cycle(graph, distance, edge_count)\n    <span class=\"hljs-keyword\">if</span> negative_cycle_exists:\n        <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">&quot;Negative cycle found&quot;</span>)\n\n    <span class=\"hljs-keyword\">return</span> distance\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    <span class=\"hljs-keyword\">import</span> doctest\n\n    doctest.testmod()\n\n    V = <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&quot;Enter number of vertices: &quot;</span>).strip())\n    E = <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&quot;Enter number of edges: &quot;</span>).strip())\n\n    graph: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">int</span>]] = [<span class=\"hljs-built_in\">dict</span>() <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(E)]\n\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(E):\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Edge &quot;</span>, i + <span class=\"hljs-number\">1</span>)\n        src, dest, weight = [\n            <span class=\"hljs-built_in\">int</span>(x)\n            <span class=\"hljs-keyword\">for</span> x <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&quot;Enter source, destination, weight: &quot;</span>).strip().split(<span class=\"hljs-string\">&quot; &quot;</span>)\n        ]\n        graph[i] = {<span class=\"hljs-string\">&quot;src&quot;</span>: src, <span class=\"hljs-string\">&quot;dst&quot;</span>: dest, <span class=\"hljs-string\">&quot;weight&quot;</span>: weight}\n\n    source = <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&quot;\\nEnter shortest path source:&quot;</span>).strip())\n    shortest_distance = bellman_ford(graph, V, E, source)\n    print_distance(shortest_distance, <span class=\"hljs-number\">0</span>)\n"
    },
    "c-plus-plus": {
      "dir": "dynamic_programming/bellman_ford.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/dynamic_programming/bellman_ford.cpp",
      "code": "<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;limits.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;\n\n<span class=\"hljs-comment\">// Wrapper class for storing an edge</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Edge</span> {\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-type\">int</span> src, dst, weight;\n};\n\n<span class=\"hljs-comment\">// Wrapper class for storing a graph</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Graph</span> {\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-type\">int</span> vertexNum, edgeNum;\n    Edge *edges;\n\n    <span class=\"hljs-comment\">// Constructs a graph with V vertices and E edges</span>\n    <span class=\"hljs-built_in\">Graph</span>(<span class=\"hljs-type\">int</span> V, <span class=\"hljs-type\">int</span> E) {\n        <span class=\"hljs-keyword\">this</span>-&gt;vertexNum = V;\n        <span class=\"hljs-keyword\">this</span>-&gt;edgeNum = E;\n        <span class=\"hljs-keyword\">this</span>-&gt;edges = (Edge *)<span class=\"hljs-built_in\">malloc</span>(E * <span class=\"hljs-built_in\">sizeof</span>(Edge));\n    }\n\n    <span class=\"hljs-comment\">// Adds the given edge to the graph</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addEdge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> src, <span class=\"hljs-type\">int</span> dst, <span class=\"hljs-type\">int</span> weight)</span> </span>{\n        <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> edgeInd = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-keyword\">if</span> (edgeInd &lt; <span class=\"hljs-keyword\">this</span>-&gt;edgeNum) {\n            Edge newEdge;\n            newEdge.src = src;\n            newEdge.dst = dst;\n            newEdge.weight = weight;\n            <span class=\"hljs-keyword\">this</span>-&gt;edges[edgeInd++] = newEdge;\n        }\n    }\n};\n\n<span class=\"hljs-comment\">// Utility function to print distances</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> dist[], <span class=\"hljs-type\">int</span> V)</span> </span>{\n    cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nVertex  Distance&quot;</span> &lt;&lt; endl;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++) {\n        <span class=\"hljs-keyword\">if</span> (dist[i] != INT_MAX)\n            cout &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot;\\t&quot;</span> &lt;&lt; dist[i] &lt;&lt; endl;\n        <span class=\"hljs-keyword\">else</span>\n            cout &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot;\\tINF&quot;</span> &lt;&lt; endl;\n    }\n}\n\n<span class=\"hljs-comment\">// The main function that finds the shortest path from given source</span>\n<span class=\"hljs-comment\">// to all other vertices using Bellman-Ford.It also detects negative</span>\n<span class=\"hljs-comment\">// weight cycle</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">BellmanFord</span><span class=\"hljs-params\">(Graph graph, <span class=\"hljs-type\">int</span> src)</span> </span>{\n    <span class=\"hljs-type\">int</span> V = graph.vertexNum;\n    <span class=\"hljs-type\">int</span> E = graph.edgeNum;\n    <span class=\"hljs-type\">int</span> dist[V];\n\n    <span class=\"hljs-comment\">// Initialize distances array as INF for all except source</span>\n    <span class=\"hljs-comment\">// Intialize source as zero</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++) dist[i] = INT_MAX;\n    dist[src] = <span class=\"hljs-number\">0</span>;\n\n    <span class=\"hljs-comment\">// Calculate shortest path distance from source to all edges</span>\n    <span class=\"hljs-comment\">// A path can contain maximum (|V|-1) edges</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= V - <span class=\"hljs-number\">1</span>; i++)\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; E; j++) {\n            <span class=\"hljs-type\">int</span> u = graph.edges[j].src;\n            <span class=\"hljs-type\">int</span> v = graph.edges[j].dst;\n            <span class=\"hljs-type\">int</span> w = graph.edges[j].weight;\n\n            <span class=\"hljs-keyword\">if</span> (dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; dist[v])\n                dist[v] = dist[u] + w;\n        }\n\n    <span class=\"hljs-comment\">// Iterate inner loop once more to check for negative cycle</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; E; j++) {\n        <span class=\"hljs-type\">int</span> u = graph.edges[j].src;\n        <span class=\"hljs-type\">int</span> v = graph.edges[j].dst;\n        <span class=\"hljs-type\">int</span> w = graph.edges[j].weight;\n\n        <span class=\"hljs-keyword\">if</span> (dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; dist[v]) {\n            cout &lt;&lt; <span class=\"hljs-string\">&quot;Graph contains negative weight cycle. Hence, shortest &quot;</span>\n                    <span class=\"hljs-string\">&quot;distance not guaranteed.&quot;</span>\n                 &lt;&lt; endl;\n            <span class=\"hljs-keyword\">return</span>;\n        }\n    }\n\n    <span class=\"hljs-built_in\">print</span>(dist, V);\n\n    <span class=\"hljs-keyword\">return</span>;\n}\n\n<span class=\"hljs-comment\">// Driver Function</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-type\">int</span> V, E, gsrc;\n    <span class=\"hljs-type\">int</span> src, dst, weight;\n    cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter number of vertices: &quot;</span>;\n    cin &gt;&gt; V;\n    cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter number of edges: &quot;</span>;\n    cin &gt;&gt; E;\n    <span class=\"hljs-function\">Graph <span class=\"hljs-title\">G</span><span class=\"hljs-params\">(V, E)</span></span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; E; i++) {\n        cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nEdge &quot;</span> &lt;&lt; i + <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-string\">&quot;\\nEnter source: &quot;</span>;\n        cin &gt;&gt; src;\n        cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter destination: &quot;</span>;\n        cin &gt;&gt; dst;\n        cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter weight: &quot;</span>;\n        cin &gt;&gt; weight;\n        G.<span class=\"hljs-built_in\">addEdge</span>(src, dst, weight);\n    }\n    cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nEnter source: &quot;</span>;\n    cin &gt;&gt; gsrc;\n    <span class=\"hljs-built_in\">BellmanFord</span>(G, gsrc);\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "java": {
      "dir": "DataStructures/Graphs/BellmanFord.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/DataStructures/Graphs/BellmanFord.java",
      "code": "<span class=\"hljs-keyword\">package</span> DataStructures.Graphs;\n\n<span class=\"hljs-keyword\">import</span> java.util.*;\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BellmanFord</span>\n<span class=\"hljs-comment\">/*Implementation of Bellman ford to detect negative cycles. Graph accepts inputs in form of edges which have\nstart vertex, end vertex and weights. Vertices should be labelled with a number between 0 and total number of vertices-1,both inclusive*/</span>\n{\n  <span class=\"hljs-type\">int</span> vertex, edge;\n  <span class=\"hljs-keyword\">private</span> Edge edges[];\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">index</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n\n  BellmanFord(<span class=\"hljs-type\">int</span> v, <span class=\"hljs-type\">int</span> e) {\n    vertex = v;\n    edge = e;\n    edges = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Edge</span>[e];\n  }\n\n  <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Edge</span> {\n    <span class=\"hljs-type\">int</span> u, v;\n    <span class=\"hljs-type\">int</span> w;\n    <span class=\"hljs-comment\">/**\n     * <span class=\"hljs-doctag\">@param</span> u Source Vertex\n     * <span class=\"hljs-doctag\">@param</span> v End vertex\n     * <span class=\"hljs-doctag\">@param</span> c Weight\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Edge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b, <span class=\"hljs-type\">int</span> c)</span> {\n      u = a;\n      v = b;\n      w = c;\n    }\n  }\n  <span class=\"hljs-comment\">/**\n   * <span class=\"hljs-doctag\">@param</span> p[] Parent array which shows updates in edges\n   * <span class=\"hljs-doctag\">@param</span> i Current vertex under consideration\n   */</span>\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printPath</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> p[], <span class=\"hljs-type\">int</span> i)</span> {\n    <span class=\"hljs-keyword\">if</span> (p[i] == -<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// Found the path back to parent</span>\n    <span class=\"hljs-keyword\">return</span>;\n    printPath(p, p[i]);\n    System.out.print(i + <span class=\"hljs-string\">&quot; &quot;</span>);\n  }\n\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String args[])</span> {\n    <span class=\"hljs-type\">BellmanFord</span> <span class=\"hljs-variable\">obj</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BellmanFord</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// Dummy object to call nonstatic variables</span>\n    obj.go();\n  }\n\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span>\n      <span class=\"hljs-title function_\">go</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">// Interactive run for understanding the class first time. Assumes source vertex is 0 and</span>\n        <span class=\"hljs-comment\">// shows distance to all vertices</span>\n      {\n    <span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">sc</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in); <span class=\"hljs-comment\">// Grab scanner object for user input</span>\n    <span class=\"hljs-type\">int</span> i, v, e, u, ve, w, j, neg = <span class=\"hljs-number\">0</span>;\n    System.out.println(<span class=\"hljs-string\">&quot;Enter no. of vertices and edges please&quot;</span>);\n    v = sc.nextInt();\n    e = sc.nextInt();\n    Edge arr[] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Edge</span>[e]; <span class=\"hljs-comment\">// Array of edges</span>\n    System.out.println(<span class=\"hljs-string\">&quot;Input edges&quot;</span>);\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; e; i++) {\n      u = sc.nextInt();\n      ve = sc.nextInt();\n      w = sc.nextInt();\n      arr[i] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Edge</span>(u, ve, w);\n    }\n    <span class=\"hljs-type\">int</span> dist[] =\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>\n            [v]; <span class=\"hljs-comment\">// Distance array for holding the finalized shortest path distance between source</span>\n    <span class=\"hljs-comment\">// and all vertices</span>\n    <span class=\"hljs-type\">int</span> p[] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[v]; <span class=\"hljs-comment\">// Parent array for holding the paths</span>\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; v; i++) dist[i] = Integer.MAX_VALUE; <span class=\"hljs-comment\">// Initializing distance values</span>\n    dist[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;\n    p[<span class=\"hljs-number\">0</span>] = -<span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; v - <span class=\"hljs-number\">1</span>; i++) {\n      <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; e; j++) {\n        <span class=\"hljs-keyword\">if</span> ((<span class=\"hljs-type\">int</span>) dist[arr[j].u] != Integer.MAX_VALUE\n            &amp;&amp; dist[arr[j].v] &gt; dist[arr[j].u] + arr[j].w) {\n          dist[arr[j].v] = dist[arr[j].u] + arr[j].w; <span class=\"hljs-comment\">// Update</span>\n          p[arr[j].v] = arr[j].u;\n        }\n      }\n    }\n    <span class=\"hljs-comment\">// Final cycle for negative checking</span>\n    <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; e; j++)\n      <span class=\"hljs-keyword\">if</span> ((<span class=\"hljs-type\">int</span>) dist[arr[j].u] != Integer.MAX_VALUE &amp;&amp; dist[arr[j].v] &gt; dist[arr[j].u] + arr[j].w) {\n        neg = <span class=\"hljs-number\">1</span>;\n        System.out.println(<span class=\"hljs-string\">&quot;Negative cycle&quot;</span>);\n        <span class=\"hljs-keyword\">break</span>;\n      }\n    <span class=\"hljs-keyword\">if</span> (neg == <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// Go ahead and show results of computation</span>\n    {\n      System.out.println(<span class=\"hljs-string\">&quot;Distances are: &quot;</span>);\n      <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; v; i++) System.out.println(i + <span class=\"hljs-string\">&quot; &quot;</span> + dist[i]);\n      System.out.println(<span class=\"hljs-string\">&quot;Path followed:&quot;</span>);\n      <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; v; i++) {\n        System.out.print(<span class=\"hljs-string\">&quot;0 &quot;</span>);\n        printPath(p, i);\n        System.out.println();\n      }\n    }\n    sc.close();\n  }\n  <span class=\"hljs-comment\">/**\n   * <span class=\"hljs-doctag\">@param</span> source Starting vertex\n   * <span class=\"hljs-doctag\">@param</span> end Ending vertex\n   * <span class=\"hljs-doctag\">@param</span> Edge Array of edges\n   */</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">show</span><span class=\"hljs-params\">(\n      <span class=\"hljs-type\">int</span> source,\n      <span class=\"hljs-type\">int</span> end,\n      Edge arr[])</span> <span class=\"hljs-comment\">// Just shows results of computation, if graph is passed to it. The graph should</span>\n        <span class=\"hljs-comment\">// be created by using addEdge() method and passed by calling getEdgeArray() method</span>\n      {\n    <span class=\"hljs-type\">int</span> i, j, v = vertex, e = edge, neg = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">double</span> dist[] =\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">double</span>\n            [v]; <span class=\"hljs-comment\">// Distance array for holding the finalized shortest path distance between source</span>\n    <span class=\"hljs-comment\">// and all vertices</span>\n    <span class=\"hljs-type\">int</span> p[] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[v]; <span class=\"hljs-comment\">// Parent array for holding the paths</span>\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; v; i++) dist[i] = Integer.MAX_VALUE; <span class=\"hljs-comment\">// Initializing distance values</span>\n    dist[source] = <span class=\"hljs-number\">0</span>;\n    p[source] = -<span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; v - <span class=\"hljs-number\">1</span>; i++) {\n      <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; e; j++) {\n        <span class=\"hljs-keyword\">if</span> ((<span class=\"hljs-type\">int</span>) dist[arr[j].u] != Integer.MAX_VALUE\n            &amp;&amp; dist[arr[j].v] &gt; dist[arr[j].u] + arr[j].w) {\n          dist[arr[j].v] = dist[arr[j].u] + arr[j].w; <span class=\"hljs-comment\">// Update</span>\n          p[arr[j].v] = arr[j].u;\n        }\n      }\n    }\n    <span class=\"hljs-comment\">// Final cycle for negative checking</span>\n    <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; e; j++)\n      <span class=\"hljs-keyword\">if</span> ((<span class=\"hljs-type\">int</span>) dist[arr[j].u] != Integer.MAX_VALUE &amp;&amp; dist[arr[j].v] &gt; dist[arr[j].u] + arr[j].w) {\n        neg = <span class=\"hljs-number\">1</span>;\n        System.out.println(<span class=\"hljs-string\">&quot;Negative cycle&quot;</span>);\n        <span class=\"hljs-keyword\">break</span>;\n      }\n    <span class=\"hljs-keyword\">if</span> (neg == <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// Go ahead and show results of computaion</span>\n    {\n      System.out.println(<span class=\"hljs-string\">&quot;Distance is: &quot;</span> + dist[end]);\n      System.out.println(<span class=\"hljs-string\">&quot;Path followed:&quot;</span>);\n      System.out.print(source + <span class=\"hljs-string\">&quot; &quot;</span>);\n      printPath(p, end);\n      System.out.println();\n    }\n  }\n  <span class=\"hljs-comment\">/**\n   * <span class=\"hljs-doctag\">@param</span> x Source Vertex\n   * <span class=\"hljs-doctag\">@param</span> y End vertex\n   * <span class=\"hljs-doctag\">@param</span> z Weight\n   */</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">addEdge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y, <span class=\"hljs-type\">int</span> z)</span> <span class=\"hljs-comment\">// Adds unidirectional edge</span>\n      {\n    edges[index++] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Edge</span>(x, y, z);\n  }\n\n  <span class=\"hljs-keyword\">public</span> Edge[] getEdgeArray() {\n    <span class=\"hljs-keyword\">return</span> edges;\n  }\n}\n"
    },
    "c": {
      "dir": "data_structures/graphs/bellman_ford.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/data_structures/graphs/bellman_ford.c",
      "code": "<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;limits.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string.h&gt;</span></span>\n\n<span class=\"hljs-comment\">// Structure for storing edge</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span>\n{</span>\n    <span class=\"hljs-type\">int</span> src, dst, weight;\n};\n\n<span class=\"hljs-comment\">// Structure for storing a graph</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Graph</span>\n{</span>\n    <span class=\"hljs-type\">int</span> vertexNum;\n    <span class=\"hljs-type\">int</span> edgeNum;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span> *<span class=\"hljs-title\">edges</span>;</span>\n};\n\n<span class=\"hljs-comment\">// Constructs a graph with V vertices and E edges</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">createGraph</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Graph *G, <span class=\"hljs-type\">int</span> V, <span class=\"hljs-type\">int</span> E)</span>\n{\n    G-&gt;vertexNum = V;\n    G-&gt;edgeNum = E;\n    G-&gt;edges = (<span class=\"hljs-keyword\">struct</span> Edge *)<span class=\"hljs-built_in\">malloc</span>(E * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> Edge));\n}\n\n<span class=\"hljs-comment\">// Adds the given edge to the graph</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">addEdge</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Graph *G, <span class=\"hljs-type\">int</span> src, <span class=\"hljs-type\">int</span> dst, <span class=\"hljs-type\">int</span> weight)</span>\n{\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> ind;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span> <span class=\"hljs-title\">newEdge</span>;</span>\n    newEdge.src = src;\n    newEdge.dst = dst;\n    newEdge.weight = weight;\n    G-&gt;edges[ind++] = newEdge;\n}\n\n<span class=\"hljs-comment\">// Utility function to find minimum distance vertex in mdist</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">minDistance</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> mdist[], <span class=\"hljs-type\">int</span> vset[], <span class=\"hljs-type\">int</span> V)</span>\n{\n    <span class=\"hljs-type\">int</span> minVal = INT_MAX, minInd;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++)\n        <span class=\"hljs-keyword\">if</span> (vset[i] == <span class=\"hljs-number\">0</span> &amp;&amp; mdist[i] &lt; minVal)\n        {\n            minVal = mdist[i];\n            minInd = i;\n        }\n\n    <span class=\"hljs-keyword\">return</span> minInd;\n}\n\n<span class=\"hljs-comment\">// Utility function to print distances</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">print</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> dist[], <span class=\"hljs-type\">int</span> V)</span>\n{\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\nVertex  Distance\\n&quot;</span>);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++)\n    {\n        <span class=\"hljs-keyword\">if</span> (dist[i] != INT_MAX)\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\t%d\\n&quot;</span>, i, dist[i]);\n        <span class=\"hljs-keyword\">else</span>\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\tINF&quot;</span>, i);\n    }\n}\n\n<span class=\"hljs-comment\">// The main function that finds the shortest path from given source</span>\n<span class=\"hljs-comment\">// to all other vertices using Bellman-Ford.It also detects negative</span>\n<span class=\"hljs-comment\">// weight cycle</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">BellmanFord</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Graph *graph, <span class=\"hljs-type\">int</span> src)</span>\n{\n    <span class=\"hljs-type\">int</span> V = graph-&gt;vertexNum;\n    <span class=\"hljs-type\">int</span> E = graph-&gt;edgeNum;\n    <span class=\"hljs-type\">int</span> dist[V];\n\n    <span class=\"hljs-comment\">// Initialize distances array as INF for all except source</span>\n    <span class=\"hljs-comment\">// Intialize source as zero</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++) dist[i] = INT_MAX;\n    dist[src] = <span class=\"hljs-number\">0</span>;\n\n    <span class=\"hljs-comment\">// Calculate shortest path distance from source to all edges</span>\n    <span class=\"hljs-comment\">// A path can contain maximum (|V|-1) edges</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= V - <span class=\"hljs-number\">1</span>; i++)\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; E; j++)\n        {\n            <span class=\"hljs-type\">int</span> u = graph-&gt;edges[j].src;\n            <span class=\"hljs-type\">int</span> v = graph-&gt;edges[j].dst;\n            <span class=\"hljs-type\">int</span> w = graph-&gt;edges[j].weight;\n\n            <span class=\"hljs-keyword\">if</span> (dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; dist[v])\n                dist[v] = dist[u] + w;\n        }\n\n    <span class=\"hljs-comment\">// Iterate inner loop once more to check for negative cycle</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; E; j++)\n    {\n        <span class=\"hljs-type\">int</span> u = graph-&gt;edges[j].src;\n        <span class=\"hljs-type\">int</span> v = graph-&gt;edges[j].dst;\n        <span class=\"hljs-type\">int</span> w = graph-&gt;edges[j].weight;\n\n        <span class=\"hljs-keyword\">if</span> (dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; dist[v])\n        {\n            <span class=\"hljs-built_in\">printf</span>(\n                <span class=\"hljs-string\">&quot;Graph contains negative weight cycle. Hence, shortest &quot;</span>\n                <span class=\"hljs-string\">&quot;distance not guaranteed.&quot;</span>);\n            <span class=\"hljs-keyword\">return</span>;\n        }\n    }\n\n    print(dist, V);\n\n    <span class=\"hljs-keyword\">return</span>;\n}\n\n<span class=\"hljs-comment\">// Driver Function</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span>\n{\n    <span class=\"hljs-type\">int</span> V, E, gsrc;\n    <span class=\"hljs-type\">int</span> src, dst, weight;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Graph</span> <span class=\"hljs-title\">G</span>;</span>\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter number of vertices: &quot;</span>);\n    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;V);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter number of edges: &quot;</span>);\n    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;E);\n    createGraph(&amp;G, V, E);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; E; i++)\n    {\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\nEdge %d \\nEnter source: &quot;</span>, i + <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;src);\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter destination: &quot;</span>);\n        <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;dst);\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter weight: &quot;</span>);\n        <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;weight);\n        addEdge(&amp;G, src, dst, weight);\n    }\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\nEnter source:&quot;</span>);\n    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;gsrc);\n    BellmanFord(&amp;G, gsrc);\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "PalAditya",
      "email": "adityapal.nghss@gmail.com",
      "commits": 1
    },
    {
      "name": "hasan",
      "email": "hasanuli10@gmail.com",
      "commits": 1
    },
    {
      "name": "ParthS007",
      "email": "parth1989shandilya@gmail.com",
      "commits": 1
    },
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Nishant Chatterjee",
      "email": "52992695+nishantc1527@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Maria Lungeanu",
      "email": "Maria.Lungeanu@anritsu.com",
      "commits": 1
    },
    {
      "name": "John Law",
      "email": "johnlaw.po@gmail.com",
      "commits": 1
    },
    {
      "name": "matkosoric",
      "email": "soric.matko@gmail.com",
      "commits": 1
    },
    {
      "name": "JakobZhao",
      "email": "52325554+JakobMusik@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "cclauss",
      "email": "cclauss@bluewin.ch",
      "commits": 1
    },
    {
      "name": "ashu01",
      "email": "as01hu@gmail.com",
      "commits": 1
    },
    {
      "name": "AlexDvorak",
      "email": "opti.jawsome@gmail.com",
      "commits": 2
    },
    {
      "name": "Libin Yang",
      "email": "szuyanglb@outlook.com",
      "commits": 2
    },
    {
      "name": "Hassan",
      "email": "hassan.elseoudy@gmail.com",
      "commits": 2
    },
    {
      "name": "Sameer Ahmed Khan",
      "email": "68906588+sameerahmedk@users.noreply.github.com",
      "commits": 3
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 4
    },
    {
      "name": "arpanjain97",
      "email": "arpanjain97@gmail.com",
      "commits": 5
    }
  ],
  "explanationUrl": {
    "en": "https://github.com/TheAlgorithms/Algorithms-Explanation/tree/master/en/Data Structures/Graph/Bellman-Ford.md",
    "es": "https://github.com/TheAlgorithms/Algorithms-Explanation/tree/master/es/Estructuras de datos/Gráfico/Bellman Ford.md"
  }
}
