{
  "slug": "rabin-karp",
  "name": "Rabin Karp",
  "categories": ["strings"],
  "body": {},
  "implementations": {
    "python": {
      "dir": "strings/rabin_karp.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/strings/rabin_karp.py",
      "code": "<span class=\"hljs-comment\"># Numbers of alphabet which we call base</span>\nalphabet_size = <span class=\"hljs-number\">256</span>\n<span class=\"hljs-comment\"># Modulus to hash a string</span>\nmodulus = <span class=\"hljs-number\">1000003</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">rabin_karp</span>(<span class=\"hljs-params\">pattern: <span class=\"hljs-built_in\">str</span>, text: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    The Rabin-Karp Algorithm for finding a pattern within a piece of text\n    with complexity O(nm), most efficient when it is used with multiple patterns\n    as it is able to check if any of a set of patterns match a section of text in o(1)\n    given the precomputed hashes.\n\n    This will be the simple version which only assumes one pattern is being searched\n    for but it&#x27;s not hard to modify\n\n    1) Calculate pattern hash\n\n    2) Step through the text one character at a time passing a window with the same\n        length as the pattern\n        calculating the hash of the text within the window compare it with the hash\n        of the pattern. Only testing equality if the hashes match\n    &quot;&quot;&quot;</span>\n    p_len = <span class=\"hljs-built_in\">len</span>(pattern)\n    t_len = <span class=\"hljs-built_in\">len</span>(text)\n    <span class=\"hljs-keyword\">if</span> p_len &gt; t_len:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n\n    p_hash = <span class=\"hljs-number\">0</span>\n    text_hash = <span class=\"hljs-number\">0</span>\n    modulus_power = <span class=\"hljs-number\">1</span>\n\n    <span class=\"hljs-comment\"># Calculating the hash of pattern and substring of text</span>\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(p_len):\n        p_hash = (<span class=\"hljs-built_in\">ord</span>(pattern[i]) + p_hash * alphabet_size) % modulus\n        text_hash = (<span class=\"hljs-built_in\">ord</span>(text[i]) + text_hash * alphabet_size) % modulus\n        <span class=\"hljs-keyword\">if</span> i == p_len - <span class=\"hljs-number\">1</span>:\n            <span class=\"hljs-keyword\">continue</span>\n        modulus_power = (modulus_power * alphabet_size) % modulus\n\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">0</span>, t_len - p_len + <span class=\"hljs-number\">1</span>):\n        <span class=\"hljs-keyword\">if</span> text_hash == p_hash <span class=\"hljs-keyword\">and</span> text[i : i + p_len] == pattern:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n        <span class=\"hljs-keyword\">if</span> i == t_len - p_len:\n            <span class=\"hljs-keyword\">continue</span>\n        <span class=\"hljs-comment\"># Calculate the https://en.wikipedia.org/wiki/Rolling_hash</span>\n        text_hash = (\n            (text_hash - <span class=\"hljs-built_in\">ord</span>(text[i]) * modulus_power) * alphabet_size\n            + <span class=\"hljs-built_in\">ord</span>(text[i + p_len])\n        ) % modulus\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">test_rabin_karp</span>() -&gt; <span class=\"hljs-literal\">None</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    &gt;&gt;&gt; test_rabin_karp()\n    Success.\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-comment\"># Test 1)</span>\n    pattern = <span class=\"hljs-string\">&quot;abc1abc12&quot;</span>\n    text1 = <span class=\"hljs-string\">&quot;alskfjaldsabc1abc1abc12k23adsfabcabc&quot;</span>\n    text2 = <span class=\"hljs-string\">&quot;alskfjaldsk23adsfabcabc&quot;</span>\n    <span class=\"hljs-keyword\">assert</span> rabin_karp(pattern, text1) <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">not</span> rabin_karp(pattern, text2)\n\n    <span class=\"hljs-comment\"># Test 2)</span>\n    pattern = <span class=\"hljs-string\">&quot;ABABX&quot;</span>\n    text = <span class=\"hljs-string\">&quot;ABABZABABYABABX&quot;</span>\n    <span class=\"hljs-keyword\">assert</span> rabin_karp(pattern, text)\n\n    <span class=\"hljs-comment\"># Test 3)</span>\n    pattern = <span class=\"hljs-string\">&quot;AAAB&quot;</span>\n    text = <span class=\"hljs-string\">&quot;ABAAAAAB&quot;</span>\n    <span class=\"hljs-keyword\">assert</span> rabin_karp(pattern, text)\n\n    <span class=\"hljs-comment\"># Test 4)</span>\n    pattern = <span class=\"hljs-string\">&quot;abcdabcy&quot;</span>\n    text = <span class=\"hljs-string\">&quot;abcxabcdabxabcdabcdabcy&quot;</span>\n    <span class=\"hljs-keyword\">assert</span> rabin_karp(pattern, text)\n\n    <span class=\"hljs-comment\"># Test 5)</span>\n    pattern = <span class=\"hljs-string\">&quot;Lü&quot;</span>\n    text = <span class=\"hljs-string\">&quot;Lüsai&quot;</span>\n    <span class=\"hljs-keyword\">assert</span> rabin_karp(pattern, text)\n    pattern = <span class=\"hljs-string\">&quot;Lue&quot;</span>\n    <span class=\"hljs-keyword\">assert</span> <span class=\"hljs-keyword\">not</span> rabin_karp(pattern, text)\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Success.&quot;</span>)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    test_rabin_karp()\n"
    },
    "c-plus-plus": {
      "dir": "strings/rabin_karp.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/strings/rabin_karp.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * \\file\n * \\brief The [Rabin-Karp\n * Algorithm](https://en.wikipedia.org/wiki/Rabin–Karp_algorithm) for finding a\n * pattern within a piece of text with complexity O(n + m)\n */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _MSC_VER</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span>  <span class=\"hljs-comment\">// use this for MS Visucal C++</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstring&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> PRIME 5  <span class=\"hljs-comment\">///&lt; Prime modulus for hash functions</span></span>\n\n<span class=\"hljs-keyword\">namespace</span> string_search {\n<span class=\"hljs-comment\">/**\n * convert a string to an intger - called as hashing function\n * \\param[in] s source of string to hash\n * \\param[in] n length of substring to hash\n * \\returns hash integer\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title\">create_hash</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string&amp; s, <span class=\"hljs-type\">int</span> n)</span> </span>{\n    <span class=\"hljs-type\">int64_t</span> result = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) {\n        result += (<span class=\"hljs-type\">int64_t</span>)(s[i] * (<span class=\"hljs-type\">int64_t</span>)<span class=\"hljs-built_in\">pow</span>(PRIME, i));\n    }\n    <span class=\"hljs-keyword\">return</span> result;\n}\n\n<span class=\"hljs-comment\">/**\n * re-hash a string using known existing hash\n * \\param[in] s source of string to hash\n * \\param[in] old_index previous index of string\n * \\param[in] new_index new index of string\n * \\param[in] old_hash previous hash of substring\n * \\param[in] patLength length of substring to hash\n * \\returns new hash integer\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title\">recalculate_hash</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string&amp; s, <span class=\"hljs-type\">int</span> old_index, <span class=\"hljs-type\">int</span> new_index,\n                         <span class=\"hljs-type\">int64_t</span> old_hash, <span class=\"hljs-type\">int</span> patLength)</span> </span>{\n    <span class=\"hljs-type\">int64_t</span> new_hash = old_hash - s[old_index];\n    new_hash /= PRIME;\n    new_hash += (<span class=\"hljs-type\">int64_t</span>)(s[new_index] * (<span class=\"hljs-type\">int64_t</span>)<span class=\"hljs-built_in\">pow</span>(PRIME, patLength - <span class=\"hljs-number\">1</span>));\n    <span class=\"hljs-keyword\">return</span> new_hash;\n}\n\n<span class=\"hljs-comment\">/**\n * compare if two sub-strings are equal\n * \\param[in] str1 string pattern to search\n * \\param[in] str2 text in which to search\n * \\param[in] start1,end1 start and end indices for substring in str1\n * \\param[in] start2,end2 start and end indices for substring in str2\n * \\returns `true` if pattern was found\n * \\returns `false` if pattern was not found\n * @note can this be replaced by std::string::compare?\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">check_if_equal</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string&amp; str1, <span class=\"hljs-keyword\">const</span> std::string&amp; str2,\n                    <span class=\"hljs-type\">int</span> start1, <span class=\"hljs-type\">int</span> end1, <span class=\"hljs-type\">int</span> start2, <span class=\"hljs-type\">int</span> end2)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (end1 - start1 != end2 - start2) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    }\n    <span class=\"hljs-keyword\">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) {\n        <span class=\"hljs-keyword\">if</span> (str1[start1] != str2[start2]) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n        }\n        start1++;\n        start2++;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n}\n\n<span class=\"hljs-comment\">/**\n *  Perform string pattern search using Rabin-Karp algorithm\n *  @param[in] str string to search in\n *  @param[in] pat pattern to search for\n *  @return index of first occurrence of pattern\n *  @return -1 if pattern not found\n */</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">rabin_karp</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string&amp; str, <span class=\"hljs-keyword\">const</span> std::string&amp; pat)</span> </span>{\n    <span class=\"hljs-type\">int64_t</span> pat_hash = <span class=\"hljs-built_in\">create_hash</span>(pat, pat.<span class=\"hljs-built_in\">size</span>());\n    <span class=\"hljs-type\">int64_t</span> str_hash = <span class=\"hljs-built_in\">create_hash</span>(str, pat.<span class=\"hljs-built_in\">size</span>());\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= str.<span class=\"hljs-built_in\">size</span>() - pat.<span class=\"hljs-built_in\">size</span>(); ++i) {\n        <span class=\"hljs-keyword\">if</span> (pat_hash == str_hash &amp;&amp;\n            <span class=\"hljs-built_in\">check_if_equal</span>(str, pat, i, i + pat.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>,\n                           pat.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>)) {\n            <span class=\"hljs-keyword\">return</span> i;\n        }\n        <span class=\"hljs-keyword\">if</span> (i &lt; str.<span class=\"hljs-built_in\">size</span>() - pat.<span class=\"hljs-built_in\">size</span>()) {\n            str_hash =\n                <span class=\"hljs-built_in\">recalculate_hash</span>(str, i, i + pat.<span class=\"hljs-built_in\">size</span>(), str_hash, pat.<span class=\"hljs-built_in\">size</span>());\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;  <span class=\"hljs-comment\">// return -1 if given pattern not found</span>\n}\n\n}  <span class=\"hljs-comment\">// namespace string_search</span>\n\n<span class=\"hljs-keyword\">using</span> string_search::rabin_karp;\n\n<span class=\"hljs-comment\">/** Main function */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> </span>{\n    <span class=\"hljs-built_in\">assert</span>(<span class=\"hljs-built_in\">rabin_karp</span>(<span class=\"hljs-string\">&quot;helloWorld&quot;</span>, <span class=\"hljs-string\">&quot;world&quot;</span>) == <span class=\"hljs-number\">-1</span>);\n    <span class=\"hljs-built_in\">assert</span>(<span class=\"hljs-built_in\">rabin_karp</span>(<span class=\"hljs-string\">&quot;helloWorld&quot;</span>, <span class=\"hljs-string\">&quot;World&quot;</span>) == <span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-built_in\">assert</span>(<span class=\"hljs-built_in\">rabin_karp</span>(<span class=\"hljs-string\">&quot;this_is_c++&quot;</span>, <span class=\"hljs-string\">&quot;c++&quot;</span>) == <span class=\"hljs-number\">8</span>);\n    <span class=\"hljs-built_in\">assert</span>(<span class=\"hljs-built_in\">rabin_karp</span>(<span class=\"hljs-string\">&quot;happy_coding&quot;</span>, <span class=\"hljs-string\">&quot;happy&quot;</span>) == <span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "java": {
      "dir": "Others/RabinKarp.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/Others/RabinKarp.java",
      "code": "<span class=\"hljs-comment\">/** <span class=\"hljs-doctag\">@author</span> Prateek Kumar Oraon (https://github.com/prateekKrOraon) */</span>\n<span class=\"hljs-keyword\">import</span> java.util.Scanner;\n\n<span class=\"hljs-comment\">// An implementation of Rabin-Karp string matching algorithm</span>\n<span class=\"hljs-comment\">// Program will simply end if there is no match</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RabinKarp</span> {\n\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">scanner</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">d</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">256</span>;\n\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n\n    scanner = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);\n    System.out.println(<span class=\"hljs-string\">&quot;Enter String&quot;</span>);\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">text</span> <span class=\"hljs-operator\">=</span> scanner.nextLine();\n    System.out.println(<span class=\"hljs-string\">&quot;Enter pattern&quot;</span>);\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">pattern</span> <span class=\"hljs-operator\">=</span> scanner.nextLine();\n\n    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">q</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">101</span>;\n    searchPat(text, pattern, q);\n  }\n\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">searchPat</span><span class=\"hljs-params\">(String text, String pattern, <span class=\"hljs-type\">int</span> q)</span> {\n\n    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">m</span> <span class=\"hljs-operator\">=</span> pattern.length();\n    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">n</span> <span class=\"hljs-operator\">=</span> text.length();\n    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">t</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">p</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">h</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n\n    h = (<span class=\"hljs-type\">int</span>) Math.pow(d, m - <span class=\"hljs-number\">1</span>) % q;\n\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; m; i++) {\n      <span class=\"hljs-comment\">// hash value is calculated for each character and then added with the hash value of the next</span>\n      <span class=\"hljs-comment\">// character for pattern</span>\n      <span class=\"hljs-comment\">// as well as the text for length equal to the length of pattern</span>\n      p = (d * p + pattern.charAt(i)) % q;\n      t = (d * t + text.charAt(i)) % q;\n    }\n\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt;= n - m; i++) {\n\n      <span class=\"hljs-comment\">// if the calculated hash value of the pattern and text matches then</span>\n      <span class=\"hljs-comment\">// all the characters of the pattern is matched with the text of length equal to length of the</span>\n      <span class=\"hljs-comment\">// pattern</span>\n      <span class=\"hljs-comment\">// if all matches then pattern exist in string</span>\n      <span class=\"hljs-comment\">// if not then the hash value of the first character of the text is subtracted and hash value</span>\n      <span class=\"hljs-comment\">// of the next character after the end</span>\n      <span class=\"hljs-comment\">// of the evaluated characters is added</span>\n      <span class=\"hljs-keyword\">if</span> (p == t) {\n\n        <span class=\"hljs-comment\">// if hash value matches then the individual characters are matched</span>\n        <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; m; j++) {\n\n          <span class=\"hljs-comment\">// if not matched then break out of the loop</span>\n          <span class=\"hljs-keyword\">if</span> (text.charAt(i + j) != pattern.charAt(j)) <span class=\"hljs-keyword\">break</span>;\n        }\n\n        <span class=\"hljs-comment\">// if all characters are matched then pattern exist in the string</span>\n        <span class=\"hljs-keyword\">if</span> (j == m) {\n          System.out.println(<span class=\"hljs-string\">&quot;Pattern found at index &quot;</span> + i);\n        }\n      }\n\n      <span class=\"hljs-comment\">// if i&lt;n-m then hash value of the first character of the text is subtracted and hash value of</span>\n      <span class=\"hljs-comment\">// the next character after the end</span>\n      <span class=\"hljs-comment\">// of the evaluated characters is added to get the hash value of the next window of characters</span>\n      <span class=\"hljs-comment\">// in the text</span>\n      <span class=\"hljs-keyword\">if</span> (i &lt; n - m) {\n        t = (d * (t - text.charAt(i) * h) + text.charAt(i + m)) % q;\n\n        <span class=\"hljs-comment\">// if hash value becomes less than zero than q is added to make it positive</span>\n        <span class=\"hljs-keyword\">if</span> (t &lt; <span class=\"hljs-number\">0</span>) t = (t + q);\n      }\n    }\n  }\n}\n"
    },
    "f-sharp": {
      "dir": "Algorithms/Strings/RabinKarp.fs",
      "url": "https://github.com/TheAlgorithms/f-sharp/tree/master/Algorithms/Strings/RabinKarp.fs",
      "code": "﻿<span class=\"hljs-keyword\">namespace</span> Algorithms.Strings\n\n<span class=\"hljs-keyword\">module</span> RabinKarp =\n    <span class=\"hljs-comment\">/// Numbers of alphabet which we call base</span>\n    <span class=\"hljs-keyword\">let</span> alphabetSize = <span class=\"hljs-number\">256</span>L\n\n    <span class=\"hljs-comment\">/// Modulus to hash a string</span>\n    <span class=\"hljs-keyword\">let</span> modulus = <span class=\"hljs-number\">1000003</span>L\n\n    <span class=\"hljs-keyword\">let</span> nfmod (a: int64, b: int64) =\n        <span class=\"hljs-keyword\">let</span> aD = double a\n        <span class=\"hljs-keyword\">let</span> bD = double b\n        int64 (aD - bD * floor (aD / bD))\n\n    <span class=\"hljs-comment\">/// &lt;summary&gt;</span>\n    <span class=\"hljs-comment\">/// The Rabin-Karp Algorithm for finding a pattern within a piece of text</span>\n    <span class=\"hljs-comment\">/// with complexity O(nm), most efficient when it is used with multiple patterns</span>\n    <span class=\"hljs-comment\">/// as it is able to check if any of a set of patterns match a section of text in o(1)</span>\n    <span class=\"hljs-comment\">/// given the precomputed hashes.</span>\n    <span class=\"hljs-comment\">/// &lt;/summary&gt;</span>\n    <span class=\"hljs-comment\">/// &lt;remarks&gt;</span>\n    <span class=\"hljs-comment\">/// This will be the simple version which only assumes one pattern is being searched</span>\n    <span class=\"hljs-comment\">/// for but it&#x27;s not hard to modify</span>\n    <span class=\"hljs-comment\">///</span>\n    <span class=\"hljs-comment\">/// 1) Calculate pattern hash</span>\n    <span class=\"hljs-comment\">///</span>\n    <span class=\"hljs-comment\">/// 2) Step through the text one character at a time passing a window with the same</span>\n    <span class=\"hljs-comment\">/// length as the pattern</span>\n    <span class=\"hljs-comment\">/// calculating the hash of the text within the window compare it with the hash</span>\n    <span class=\"hljs-comment\">/// of the pattern. Only testing equality if the hashes match</span>\n    <span class=\"hljs-comment\">/// &lt;/remarks&gt;</span>\n    <span class=\"hljs-comment\">/// &lt;param name=&quot;pattern&quot;&gt;&lt;/param&gt;</span>\n    <span class=\"hljs-comment\">/// &lt;param name=&quot;text&quot;&gt;&lt;/param&gt;</span>\n    <span class=\"hljs-comment\">/// &lt;returns&gt;&lt;/returns&gt;</span>\n    <span class=\"hljs-keyword\">let</span> rabinKarp (pattern: string, text: string): bool =\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mutable</span> result = <span class=\"hljs-keyword\">false</span>\n\n        <span class=\"hljs-keyword\">let</span> patLen = pattern.Length\n        <span class=\"hljs-keyword\">let</span> textLen = text.Length\n\n        <span class=\"hljs-keyword\">match</span> patLen <span class=\"hljs-keyword\">with</span>\n        | p <span class=\"hljs-keyword\">when</span> p &gt; textLen -&gt; <span class=\"hljs-keyword\">false</span>\n        | _ -&gt;\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mutable</span> patternHash = <span class=\"hljs-number\">0</span>L\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mutable</span> textHash = <span class=\"hljs-number\">0</span>L\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mutable</span> modulusPower = <span class=\"hljs-number\">1</span>L\n\n\n            <span class=\"hljs-comment\">// Calculating the hash of pattern and substring of text</span>\n            <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span> .. (patLen - <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">do</span>\n                patternHash &lt;- (int64 (pattern.[i]) + patternHash * alphabetSize) % modulus\n                textHash &lt;- (int64 (text.[i]) + textHash * alphabetSize) % modulus\n\n                <span class=\"hljs-keyword\">if</span> i &lt;&gt; (patLen - <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">then</span>\n                    modulusPower &lt;- (modulusPower * alphabetSize) % modulus\n\n\n            <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span> .. (textLen - patLen + <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">do</span>\n                <span class=\"hljs-keyword\">if</span> textHash = patternHash\n                   &amp;&amp; text.[i..i + (patLen - <span class=\"hljs-number\">1</span>)] = pattern <span class=\"hljs-keyword\">then</span>\n                    result &lt;- <span class=\"hljs-keyword\">true</span>\n\n                <span class=\"hljs-keyword\">if</span> not result <span class=\"hljs-keyword\">then</span>\n                    <span class=\"hljs-keyword\">if</span> i &lt;&gt; (textLen - patLen) <span class=\"hljs-keyword\">then</span>\n                        <span class=\"hljs-keyword\">let</span> first =\n                            (textHash - int64 (text.[i]) * modulusPower)\n                            * alphabetSize\n\n                        <span class=\"hljs-keyword\">let</span> second = int64 (text.[i + patLen])\n                        <span class=\"hljs-keyword\">let</span> third = (first + second) % modulus\n\n                        textHash &lt;-\n                            ((((textHash - int64 (text.[i]) * modulusPower)\n                               * alphabetSize)\n                              + int64 (text.[i + patLen])) % modulus)\n                            + modulus\n\n            result\n"
    },
    "c-sharp": {
      "dir": "Algorithms/Strings/RabinKarp.cs",
      "url": "https://github.com/TheAlgorithms/C-Sharp/blob/master/Algorithms/Strings/RabinKarp.cs",
      "code": "<span class=\"hljs-keyword\">using</span> System;\n<span class=\"hljs-keyword\">using</span> System.Collections.Generic;\n\n<span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">Algorithms.Strings</span>\n{\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     The idea: You calculate the hash for the pattern <span class=\"hljs-doctag\">&lt;c&gt;</span>p<span class=\"hljs-doctag\">&lt;/c&gt;</span> and the hash values for all the prefixes of the text</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;c&gt;</span>t<span class=\"hljs-doctag\">&lt;/c&gt;</span>.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Now, you can compare a substring in constant time using the calculated hashes.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     time complexity: O(p + t),</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     space complexity: O(t),</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     where   t - text length</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     p - pattern length.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RabinKarp</span>\n    {\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Finds the index of all occurrences of the pattern <span class=\"hljs-doctag\">&lt;c&gt;</span>p<span class=\"hljs-doctag\">&lt;/c&gt;</span> int <span class=\"hljs-doctag\">&lt;c&gt;</span>t<span class=\"hljs-doctag\">&lt;/c&gt;</span>.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>List of starting indices of the pattern in the text.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> List&lt;<span class=\"hljs-built_in\">int</span>&gt; <span class=\"hljs-title\">FindAllOccurrences</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span> text, <span class=\"hljs-built_in\">string</span> pattern</span>)</span>\n        {\n            <span class=\"hljs-comment\">// Prime number</span>\n            <span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">ulong</span> p = <span class=\"hljs-number\">65537</span>;\n\n            <span class=\"hljs-comment\">// Modulo coefficient</span>\n            <span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">ulong</span> m = (<span class=\"hljs-built_in\">ulong</span>)<span class=\"hljs-number\">1e9</span> + <span class=\"hljs-number\">7</span>;\n\n            <span class=\"hljs-comment\">// p_pow[i] = P^i mod M</span>\n            <span class=\"hljs-built_in\">ulong</span>[] pPow = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ulong</span>[Math.Max(pattern.Length, text.Length)];\n            pPow[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">1</span>; i &lt; pPow.Length; i++)\n            {\n                pPow[i] = pPow[i - <span class=\"hljs-number\">1</span>] * p % m;\n            }\n\n            <span class=\"hljs-comment\">// hash_t[i] is the sum of the previous hash values of the letters (t[0], t[1], ..., t[i-1]) and the hash value of t[i] itself (mod M).</span>\n            <span class=\"hljs-comment\">// The hash value of a letter t[i] is equal to the product of t[i] and p_pow[i] (mod M).</span>\n            <span class=\"hljs-built_in\">ulong</span>[] hashT = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ulong</span>[text.Length + <span class=\"hljs-number\">1</span>];\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; text.Length; i++)\n            {\n                hashT[i + <span class=\"hljs-number\">1</span>] = (hashT[i] + text[i] * pPow[i]) % m;\n            }\n\n            <span class=\"hljs-comment\">// hash_s is equal to sum of the hash values of the pattern (mod M).</span>\n            <span class=\"hljs-built_in\">ulong</span> hashS = <span class=\"hljs-number\">0</span>;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; pattern.Length; i++)\n            {\n                hashS = (hashS + pattern[i] * pPow[i]) % m;\n            }\n\n            <span class=\"hljs-comment\">// In the next step you iterate over the text with the pattern.</span>\n            List&lt;<span class=\"hljs-built_in\">int</span>&gt; occurrences = <span class=\"hljs-keyword\">new</span>();\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i + pattern.Length - <span class=\"hljs-number\">1</span> &lt; text.Length; i++)\n            {\n                <span class=\"hljs-comment\">// In each step you calculate the hash value of the substring to be tested.</span>\n                <span class=\"hljs-comment\">// By storing the hash values of the letters as a prefixes you can do this in constant time.</span>\n                <span class=\"hljs-keyword\">var</span> currentHash = (hashT[i + pattern.Length] + m - hashT[i]) % m;\n\n                <span class=\"hljs-comment\">// Now you can compare the hash value of the substring with the product of the hash value of the pattern and p_pow[i].</span>\n                <span class=\"hljs-keyword\">if</span> (currentHash == hashS * pPow[i] % m)\n                {\n                    <span class=\"hljs-comment\">// If the hash values are identical, do a double-check in case a hash collision occurs.</span>\n                    <span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>;\n                    <span class=\"hljs-keyword\">while</span> (j &lt; pattern.Length &amp;&amp; text[i + j] == pattern[j])\n                    {\n                        ++j;\n                    }\n\n                    <span class=\"hljs-keyword\">if</span> (j == pattern.Length)\n                    {\n                        <span class=\"hljs-comment\">// If the hash values are identical and the double-check passes, a substring was found that matches the pattern.</span>\n                        <span class=\"hljs-comment\">// In this case you add the index i to the list of occurences.</span>\n                        occurrences.Add(i);\n                    }\n                }\n            }\n\n            <span class=\"hljs-keyword\">return</span> occurrences;\n        }\n    }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 1
    },
    {
      "name": "Antony",
      "email": "45163503+DuckNrOne@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Prateek Kumar Oraon",
      "email": "b170078@nitsikkim.ac.in",
      "commits": 1
    },
    {
      "name": "Hector S",
      "email": "hfsam88@gmail.com",
      "commits": 1
    },
    {
      "name": "Amit Kumar",
      "email": "offamitkumar@gmail.com",
      "commits": 1
    },
    {
      "name": "Dmytro Litvinov",
      "email": "litvinov.dmytro.it@gmail.com",
      "commits": 1
    },
    {
      "name": "Nolan Emirot",
      "email": "emirot.nolan@gmail.com",
      "commits": 1
    },
    {
      "name": "Md. Mahbubur Rahman",
      "email": "mahbuburrahman2111@gmail.com",
      "commits": 1
    },
    {
      "name": "damelLP",
      "email": "dlambertpowell@gmail.com",
      "commits": 1
    },
    {
      "name": "Andrii Siriak",
      "email": "siryaka@gmail.com",
      "commits": 2
    },
    {
      "name": "Allister Isaiah Harvey",
      "email": "41553768+powpow58@users.noreply.github.com",
      "commits": 5
    }
  ],
  "explanationUrl": {}
}
