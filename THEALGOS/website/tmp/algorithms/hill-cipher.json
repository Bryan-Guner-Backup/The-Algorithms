{
  "slug": "hill-cipher",
  "name": "Hill Cipher",
  "categories": ["ciphers"],
  "body": {
    "en": "<p>The Hill cipher was invented by <a href=\"https://en.wikipedia.org/wiki/Lester_S._Hill\">Lester S. Hill</a>.</p>\n<p>Hill cipher is a polygraphic substitution cipher based on linear algebra. Each letter is represented by a number modulo 26. Often the simple scheme <code>A = 0, B = 1, …, Z = 25</code> is used, but this is not an essential feature of the cipher. To encrypt a message, each block of <code>n</code> letters (considered as an n-component vector) is multiplied by an invertible <code>n × n</code> matrix, against modulus 26. To decrypt the message, each block is multiplied by the inverse of the matrix used for encryption.</p>\n<h2>Example</h2>\n<p>Suppose we take an example as:\nPlain Text (PT):ACT\nkey:<code>GYBNQKURP</code></p>\n<h2>Steps</h2>\n<h3>Encryption</h3>\n<ol>\n<li>We have to write key as an <code>n × n</code> matrix as</li>\n</ol>\n<pre><code class=\"hljs language-apache\">   [<span class=\"hljs-attribute\">6</span> <span class=\"hljs-number\">24</span> <span class=\"hljs-number\">1</span>]\n   [<span class=\"hljs-attribute\">13</span> <span class=\"hljs-number\">16</span> <span class=\"hljs-number\">10</span>]\n   [<span class=\"hljs-attribute\">20</span> <span class=\"hljs-number\">17</span> <span class=\"hljs-number\">15</span>]\n</code></pre>\n<ol start=\"2\">\n<li>Same way convert PT into a vector as</li>\n</ol>\n<pre><code class=\"hljs language-json\">    [<span class=\"hljs-number\">0</span>]\n    [<span class=\"hljs-number\">2</span>]\n    [<span class=\"hljs-number\">19</span>]\n</code></pre>\n<ol start=\"3\">\n<li>Now, we need to encipher the vector by just multiplying these two matrices</li>\n</ol>\n<pre><code class=\"hljs language-json\">    [<span class=\"hljs-number\">6</span> <span class=\"hljs-number\">24</span> <span class=\"hljs-number\">1</span>]        [<span class=\"hljs-number\">0</span>]         [<span class=\"hljs-number\">67</span>]        [<span class=\"hljs-number\">15</span>]\n    [<span class=\"hljs-number\">13</span> <span class=\"hljs-number\">16</span> <span class=\"hljs-number\">10</span>]  *   [<span class=\"hljs-number\">2</span>]     =   [<span class=\"hljs-number\">222</span>]   ≈   [<span class=\"hljs-number\">4</span>]   (mod <span class=\"hljs-number\">26</span>)\n    [<span class=\"hljs-number\">20</span> <span class=\"hljs-number\">17</span> <span class=\"hljs-number\">15</span>]      [<span class=\"hljs-number\">19</span>]        [<span class=\"hljs-number\">319</span>]       [<span class=\"hljs-number\">7</span>]\n</code></pre>\n<p>So we will get the encrypted text as <strong>POH</strong>.</p>\n<h3>Decryption</h3>\n<ol>\n<li>We need to first inverse our key matrix</li>\n</ol>\n<pre><code class=\"hljs language-json\">           <span class=\"hljs-number\">-1</span> \n   [<span class=\"hljs-number\">6</span> <span class=\"hljs-number\">24</span> <span class=\"hljs-number\">1</span>]        [<span class=\"hljs-number\">8</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">10</span>]\n   [<span class=\"hljs-number\">13</span> <span class=\"hljs-number\">16</span> <span class=\"hljs-number\">10</span>]   ≈  [<span class=\"hljs-number\">21</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">21</span>]  (mod <span class=\"hljs-number\">26</span>) \n   [<span class=\"hljs-number\">20</span> <span class=\"hljs-number\">17</span> <span class=\"hljs-number\">15</span>]      [<span class=\"hljs-number\">21</span> <span class=\"hljs-number\">12</span> <span class=\"hljs-number\">8</span>]\n</code></pre>\n<ol start=\"2\">\n<li>For the previous Cipher Text <strong>POH</strong></li>\n</ol>\n<pre><code class=\"hljs language-json\">    [<span class=\"hljs-number\">8</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">10</span>]      [<span class=\"hljs-number\">15</span>]      [<span class=\"hljs-number\">260</span>]     [<span class=\"hljs-number\">0</span>]\n    [<span class=\"hljs-number\">21</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">21</span>]  *  [<span class=\"hljs-number\">14</span>]  ≈   [<span class=\"hljs-number\">574</span>]  ≈  [<span class=\"hljs-number\">2</span>]    (mod <span class=\"hljs-number\">26</span>)  ≈ ACT\n    [<span class=\"hljs-number\">21</span> <span class=\"hljs-number\">12</span> <span class=\"hljs-number\">8</span>]     [<span class=\"hljs-number\">7</span>]       [<span class=\"hljs-number\">539</span>]     [<span class=\"hljs-number\">19</span>]\n</code></pre>\n<h2>Implementations</h2>\n<p><a href=\"https://github.com/TheAlgorithms/Python/blob/master/ciphers/hill_cipher.py\"><strong>Python</strong></a></p>\n<h2>Video Explanation</h2>\n<p><a href=\"https://www.youtube.com/watch?v=6T46sgty4Mk\">Video explanation of the Hill Cipher</a></p>"
  },
  "implementations": {
    "python": {
      "dir": "ciphers/hill_cipher.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/ciphers/hill_cipher.py",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;\n\nHill Cipher:\nThe &#x27;HillCipher&#x27; class below implements the Hill Cipher algorithm which uses\nmodern linear algebra techniques to encode and decode text using an encryption\nkey matrix.\n\nAlgorithm:\nLet the order of the encryption key be N (as it is a square matrix).\nYour text is divided into batches of length N and converted to numerical vectors\nby a simple mapping starting with A=0 and so on.\n\nThe key is then multiplied with the newly created batch vector to obtain the\nencoded vector. After each multiplication modular 36 calculations are performed\non the vectors so as to bring the numbers between 0 and 36 and then mapped with\ntheir corresponding alphanumerics.\n\nWhile decrypting, the decrypting key is found which is the inverse of the\nencrypting key modular 36. The same process is repeated for decrypting to get\nthe original message back.\n\nConstraints:\nThe determinant of the encryption key matrix must be relatively prime w.r.t 36.\n\nNote:\nThis implementation only considers alphanumerics in the text.  If the length of\nthe text to be encrypted is not a multiple of the break key(the length of one\nbatch of letters), the last character of the text is added to the text until the\nlength of the text reaches a multiple of the break_key. So the text after\ndecrypting might be a little different than the original text.\n\nReferences:\nhttps://apprendre-en-ligne.net/crypto/hill/Hillciph.pdf\nhttps://www.youtube.com/watch?v=kfmNeskzs2o\nhttps://www.youtube.com/watch?v=4RhLNDqcjpA\n\n&quot;&quot;&quot;</span>\n<span class=\"hljs-keyword\">import</span> string\n\n<span class=\"hljs-keyword\">import</span> numpy\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">greatest_common_divisor</span>(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">int</span>, b: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    &gt;&gt;&gt; greatest_common_divisor(4, 8)\n    4\n    &gt;&gt;&gt; greatest_common_divisor(8, 4)\n    4\n    &gt;&gt;&gt; greatest_common_divisor(4, 7)\n    1\n    &gt;&gt;&gt; greatest_common_divisor(0, 10)\n    10\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-keyword\">return</span> b <span class=\"hljs-keyword\">if</span> a == <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">else</span> greatest_common_divisor(b % a, a)\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HillCipher</span>:\n    key_string = string.ascii_uppercase + string.digits\n    <span class=\"hljs-comment\"># This cipher takes alphanumerics into account</span>\n    <span class=\"hljs-comment\"># i.e. a total of 36 characters</span>\n\n    <span class=\"hljs-comment\"># take x and return x % len(key_string)</span>\n    modulus = numpy.vectorize(<span class=\"hljs-keyword\">lambda</span> x: x % <span class=\"hljs-number\">36</span>)\n\n    to_int = numpy.vectorize(<span class=\"hljs-keyword\">lambda</span> x: <span class=\"hljs-built_in\">round</span>(x))\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, encrypt_key: numpy.ndarray</span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        encrypt_key is an NxN numpy array\n        &quot;&quot;&quot;</span>\n        self.encrypt_key = self.modulus(encrypt_key)  <span class=\"hljs-comment\"># mod36 calc&#x27;s on the encrypt key</span>\n        self.check_determinant()  <span class=\"hljs-comment\"># validate the determinant of the encryption key</span>\n        self.break_key = encrypt_key.shape[<span class=\"hljs-number\">0</span>]\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">replace_letters</span>(<span class=\"hljs-params\">self, letter: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        &gt;&gt;&gt; hill_cipher = HillCipher(numpy.array([[2, 5], [1, 6]]))\n        &gt;&gt;&gt; hill_cipher.replace_letters(&#x27;T&#x27;)\n        19\n        &gt;&gt;&gt; hill_cipher.replace_letters(&#x27;0&#x27;)\n        26\n        &quot;&quot;&quot;</span>\n        <span class=\"hljs-keyword\">return</span> self.key_string.index(letter)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">replace_digits</span>(<span class=\"hljs-params\">self, num: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        &gt;&gt;&gt; hill_cipher = HillCipher(numpy.array([[2, 5], [1, 6]]))\n        &gt;&gt;&gt; hill_cipher.replace_digits(19)\n        &#x27;T&#x27;\n        &gt;&gt;&gt; hill_cipher.replace_digits(26)\n        &#x27;0&#x27;\n        &quot;&quot;&quot;</span>\n        <span class=\"hljs-keyword\">return</span> self.key_string[<span class=\"hljs-built_in\">round</span>(num)]\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">check_determinant</span>(<span class=\"hljs-params\">self</span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        &gt;&gt;&gt; hill_cipher = HillCipher(numpy.array([[2, 5], [1, 6]]))\n        &gt;&gt;&gt; hill_cipher.check_determinant()\n        &quot;&quot;&quot;</span>\n        det = <span class=\"hljs-built_in\">round</span>(numpy.linalg.det(self.encrypt_key))\n\n        <span class=\"hljs-keyword\">if</span> det &lt; <span class=\"hljs-number\">0</span>:\n            det = det % <span class=\"hljs-built_in\">len</span>(self.key_string)\n\n        req_l = <span class=\"hljs-built_in\">len</span>(self.key_string)\n        <span class=\"hljs-keyword\">if</span> greatest_common_divisor(det, <span class=\"hljs-built_in\">len</span>(self.key_string)) != <span class=\"hljs-number\">1</span>:\n            <span class=\"hljs-keyword\">raise</span> ValueError(\n                <span class=\"hljs-string\">f&quot;determinant modular <span class=\"hljs-subst\">{req_l}</span> of encryption key(<span class=\"hljs-subst\">{det}</span>) is not co prime &quot;</span>\n                <span class=\"hljs-string\">f&quot;w.r.t <span class=\"hljs-subst\">{req_l}</span>.\\nTry another key.&quot;</span>\n            )\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">process_text</span>(<span class=\"hljs-params\">self, text: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        &gt;&gt;&gt; hill_cipher = HillCipher(numpy.array([[2, 5], [1, 6]]))\n        &gt;&gt;&gt; hill_cipher.process_text(&#x27;Testing Hill Cipher&#x27;)\n        &#x27;TESTINGHILLCIPHERR&#x27;\n        &gt;&gt;&gt; hill_cipher.process_text(&#x27;hello&#x27;)\n        &#x27;HELLOO&#x27;\n        &quot;&quot;&quot;</span>\n        chars = [char <span class=\"hljs-keyword\">for</span> char <span class=\"hljs-keyword\">in</span> text.upper() <span class=\"hljs-keyword\">if</span> char <span class=\"hljs-keyword\">in</span> self.key_string]\n\n        last = chars[-<span class=\"hljs-number\">1</span>]\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-built_in\">len</span>(chars) % self.break_key != <span class=\"hljs-number\">0</span>:\n            chars.append(last)\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>.join(chars)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">encrypt</span>(<span class=\"hljs-params\">self, text: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        &gt;&gt;&gt; hill_cipher = HillCipher(numpy.array([[2, 5], [1, 6]]))\n        &gt;&gt;&gt; hill_cipher.encrypt(&#x27;testing hill cipher&#x27;)\n        &#x27;WHXYJOLM9C6XT085LL&#x27;\n        &gt;&gt;&gt; hill_cipher.encrypt(&#x27;hello&#x27;)\n        &#x27;85FF00&#x27;\n        &quot;&quot;&quot;</span>\n        text = self.process_text(text.upper())\n        encrypted = <span class=\"hljs-string\">&quot;&quot;</span>\n\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">len</span>(text) - self.break_key + <span class=\"hljs-number\">1</span>, self.break_key):\n            batch = text[i : i + self.break_key]\n            vec = [self.replace_letters(char) <span class=\"hljs-keyword\">for</span> char <span class=\"hljs-keyword\">in</span> batch]\n            batch_vec = numpy.array([vec]).T\n            batch_encrypted = self.modulus(self.encrypt_key.dot(batch_vec)).T.tolist()[\n                <span class=\"hljs-number\">0</span>\n            ]\n            encrypted_batch = <span class=\"hljs-string\">&quot;&quot;</span>.join(\n                self.replace_digits(num) <span class=\"hljs-keyword\">for</span> num <span class=\"hljs-keyword\">in</span> batch_encrypted\n            )\n            encrypted += encrypted_batch\n\n        <span class=\"hljs-keyword\">return</span> encrypted\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">make_decrypt_key</span>(<span class=\"hljs-params\">self</span>) -&gt; numpy.ndarray:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        &gt;&gt;&gt; hill_cipher = HillCipher(numpy.array([[2, 5], [1, 6]]))\n        &gt;&gt;&gt; hill_cipher.make_decrypt_key()\n        array([[ 6, 25],\n               [ 5, 26]])\n        &quot;&quot;&quot;</span>\n        det = <span class=\"hljs-built_in\">round</span>(numpy.linalg.det(self.encrypt_key))\n\n        <span class=\"hljs-keyword\">if</span> det &lt; <span class=\"hljs-number\">0</span>:\n            det = det % <span class=\"hljs-built_in\">len</span>(self.key_string)\n        det_inv = <span class=\"hljs-literal\">None</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(self.key_string)):\n            <span class=\"hljs-keyword\">if</span> (det * i) % <span class=\"hljs-built_in\">len</span>(self.key_string) == <span class=\"hljs-number\">1</span>:\n                det_inv = i\n                <span class=\"hljs-keyword\">break</span>\n\n        inv_key = (\n            det_inv\n            * numpy.linalg.det(self.encrypt_key)\n            * numpy.linalg.inv(self.encrypt_key)\n        )\n\n        <span class=\"hljs-keyword\">return</span> self.to_int(self.modulus(inv_key))\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">decrypt</span>(<span class=\"hljs-params\">self, text: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        &gt;&gt;&gt; hill_cipher = HillCipher(numpy.array([[2, 5], [1, 6]]))\n        &gt;&gt;&gt; hill_cipher.decrypt(&#x27;WHXYJOLM9C6XT085LL&#x27;)\n        &#x27;TESTINGHILLCIPHERR&#x27;\n        &gt;&gt;&gt; hill_cipher.decrypt(&#x27;85FF00&#x27;)\n        &#x27;HELLOO&#x27;\n        &quot;&quot;&quot;</span>\n        decrypt_key = self.make_decrypt_key()\n        text = self.process_text(text.upper())\n        decrypted = <span class=\"hljs-string\">&quot;&quot;</span>\n\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">len</span>(text) - self.break_key + <span class=\"hljs-number\">1</span>, self.break_key):\n            batch = text[i : i + self.break_key]\n            vec = [self.replace_letters(char) <span class=\"hljs-keyword\">for</span> char <span class=\"hljs-keyword\">in</span> batch]\n            batch_vec = numpy.array([vec]).T\n            batch_decrypted = self.modulus(decrypt_key.dot(batch_vec)).T.tolist()[<span class=\"hljs-number\">0</span>]\n            decrypted_batch = <span class=\"hljs-string\">&quot;&quot;</span>.join(\n                self.replace_digits(num) <span class=\"hljs-keyword\">for</span> num <span class=\"hljs-keyword\">in</span> batch_decrypted\n            )\n            decrypted += decrypted_batch\n\n        <span class=\"hljs-keyword\">return</span> decrypted\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">main</span>() -&gt; <span class=\"hljs-literal\">None</span>:\n    N = <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&quot;Enter the order of the encryption key: &quot;</span>))\n    hill_matrix = []\n\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Enter each row of the encryption key with space separated integers&quot;</span>)\n    <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(N):\n        row = [<span class=\"hljs-built_in\">int</span>(x) <span class=\"hljs-keyword\">for</span> x <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">input</span>().split()]\n        hill_matrix.append(row)\n\n    hc = HillCipher(numpy.array(hill_matrix))\n\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Would you like to encrypt or decrypt some text? (1 or 2)&quot;</span>)\n    option = <span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&quot;\\n1. Encrypt\\n2. Decrypt\\n&quot;</span>)\n    <span class=\"hljs-keyword\">if</span> option == <span class=\"hljs-string\">&quot;1&quot;</span>:\n        text_e = <span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&quot;What text would you like to encrypt?: &quot;</span>)\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Your encrypted text is:&quot;</span>)\n        <span class=\"hljs-built_in\">print</span>(hc.encrypt(text_e))\n    <span class=\"hljs-keyword\">elif</span> option == <span class=\"hljs-string\">&quot;2&quot;</span>:\n        text_d = <span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&quot;What text would you like to decrypt?: &quot;</span>)\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Your decrypted text is:&quot;</span>)\n        <span class=\"hljs-built_in\">print</span>(hc.decrypt(text_d))\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    <span class=\"hljs-keyword\">import</span> doctest\n\n    doctest.testmod()\n\n    main()\n"
    },
    "c-plus-plus": {
      "dir": "ciphers/hill_cipher.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/ciphers/hill_cipher.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file hill_cipher.cpp\n * @brief Implementation of [Hill\n * cipher](https://en.wikipedia.org/wiki/Hill_cipher) algorithm.\n *\n * Program to generate the encryption-decryption key and perform encryption and\n * decryption of ASCII text using the famous block cipher algorithm. This is a\n * powerful encryption algorithm that is relatively easy to implement with a\n * given key. The strength of the algorithm depends on the size of the block\n * encryption matrix key; the bigger the matrix, the stronger the encryption and\n * more difficult to break it. However, the important requirement for the matrix\n * is that:\n * 1. matrix should be invertible - all inversion conditions should be satisfied\n * and\n * 2. its determinant must not have any common factors with the length of\n * character set\n * Due to this restriction, most implementations only implement with small 3x3\n * encryption keys and a small subset of ASCII alphabets.\n *\n * In the current implementation, I present to you an implementation for\n * generating larger encryption keys (I have attempted upto 10x10) and an ASCII\n * character set of 97 printable characters. Hence, a typical ASCII text file\n * could be easily encrypted with the module. The larger character set increases\n * the modulo of cipher and hence the matrix determinants can get very large\n * very quickly rendering them ill-defined.\n *\n * \\note This program uses determinant computation using LU decomposition from\n * the file lu_decomposition.h\n * \\note The matrix generation algorithm is very rudimentary and does not\n * guarantee an invertible modulus matrix. \\todo Better matrix generation\n * algorithm.\n *\n * @author [Krishna Vedala](https://github.com/kvedala)\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstring&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ctime&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;fstream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iomanip&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;omp.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;../numerical_methods/lu_decomposition.h&quot;</span></span>\n\n<span class=\"hljs-comment\">/**\n * operator to print a matrix\n */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n<span class=\"hljs-keyword\">static</span> std::ostream &amp;<span class=\"hljs-keyword\">operator</span>&lt;&lt;(std::ostream &amp;out, matrix&lt;T&gt; <span class=\"hljs-keyword\">const</span> &amp;v) {\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">int</span> width = <span class=\"hljs-number\">15</span>;\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> separator = <span class=\"hljs-string\">&#x27; &#x27;</span>;\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row = <span class=\"hljs-number\">0</span>; row &lt; v.<span class=\"hljs-built_in\">size</span>(); row++) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> col = <span class=\"hljs-number\">0</span>; col &lt; v[row].<span class=\"hljs-built_in\">size</span>(); col++)\n            out &lt;&lt; std::left &lt;&lt; std::<span class=\"hljs-built_in\">setw</span>(width) &lt;&lt; std::<span class=\"hljs-built_in\">setfill</span>(separator)\n                &lt;&lt; v[row][col];\n        out &lt;&lt; std::endl;\n    }\n\n    <span class=\"hljs-keyword\">return</span> out;\n}\n\n<span class=\"hljs-comment\">/** \\namespace ciphers\n * \\brief Algorithms for encryption and decryption\n */</span>\n<span class=\"hljs-keyword\">namespace</span> ciphers {\n<span class=\"hljs-comment\">/** dictionary of characters that can be encrypted and decrypted */</span>\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> *STRKEY =\n    <span class=\"hljs-string\">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789~!@#$%^&amp;&quot;</span>\n    <span class=\"hljs-string\">&quot;*()_+`-=[]{}|;&#x27;:\\&quot;,./&lt;&gt;?\\\\\\r\\n \\0&quot;</span>;\n\n<span class=\"hljs-comment\">/**\n * @brief Implementation of [Hill\n * Cipher](https://en.wikipedia.org/wiki/Hill_cipher) algorithm\n */</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HillCipher</span> {\n <span class=\"hljs-keyword\">private</span>:\n    <span class=\"hljs-comment\">/**\n     * @brief Function to generate a random integer in a given interval\n     *\n     * @param a lower limit of interval\n     * @param b upper limit of interval\n     * @tparam T type of output\n     * @return random integer in the interval \\f$[a,b)\\f$\n     */</span>\n    <span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T1, <span class=\"hljs-keyword\">typename</span> T2&gt;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">const</span> T2 <span class=\"hljs-title\">rand_range</span><span class=\"hljs-params\">(T1 a, T1 b)</span> </span>{\n        <span class=\"hljs-comment\">// generate random number between 0 and 1</span>\n        <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span> r = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">double</span>&gt;(std::<span class=\"hljs-built_in\">rand</span>()) / RAND_MAX;\n\n        <span class=\"hljs-comment\">// scale and return random number as integer</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">static_cast</span>&lt;T2&gt;(r * (b - a) + a);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Function overload to fill a matrix with random integers in a given\n     * interval\n     *\n     * @param M pointer to matrix to be filled with random numbers\n     * @param a lower limit of interval\n     * @param b upper limit of interval\n     * @tparam T1 type of input range\n     * @tparam T2 type of matrix\n     * @return determinant of generated random matrix\n     *\n     * @warning There will need to be a balance between the matrix size and the\n     * range of random numbers. If the matrix is large, the range of random\n     * numbers must be small to have a well defined keys. Or if the matrix is\n     * smaller, the random numbers range can be larger. For an 8x8 matrix, range\n     * should be no more than \\f$[0,10]\\f$\n     */</span>\n    <span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T1, <span class=\"hljs-keyword\">typename</span> T2&gt;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title\">rand_range</span><span class=\"hljs-params\">(matrix&lt;T2&gt; *M, T1 a, T1 b)</span> </span>{\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; M-&gt;<span class=\"hljs-built_in\">size</span>(); i++) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; M[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>(); j++) {\n                M[<span class=\"hljs-number\">0</span>][i][j] = <span class=\"hljs-built_in\">rand_range</span>&lt;T1, T2&gt;(a, b);\n            }\n        }\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">determinant_lu</span>(*M);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Compute\n     * [GCD](https://en.wikipedia.org/wiki/Greatest_common_divisor) of two\n     * integers using Euler&#x27;s algorithm\n     *\n     * @param a first number\n     * @param b second number\n     * @return GCD of \\f$a\\f$ and \\f$b\\f$\n     */</span>\n    <span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">const</span> T <span class=\"hljs-title\">gcd</span><span class=\"hljs-params\">(T a, T b)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (b &gt; a)  <span class=\"hljs-comment\">// ensure always a &lt; b</span>\n            std::<span class=\"hljs-built_in\">swap</span>(a, b);\n\n        <span class=\"hljs-keyword\">while</span> (b != <span class=\"hljs-number\">0</span>) {\n            T tmp = b;\n            b = a % b;\n            a = tmp;\n        }\n\n        <span class=\"hljs-keyword\">return</span> a;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief helper function to perform vector multiplication with encryption\n     * or decryption matrix\n     *\n     * @param vector vector to multiply\n     * @param key encryption or decryption key matrix\n     * @return corresponding encrypted or decrypted text\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">const</span> std::valarray&lt;<span class=\"hljs-type\">uint8_t</span>&gt; <span class=\"hljs-title\">mat_mul</span><span class=\"hljs-params\">(\n        <span class=\"hljs-keyword\">const</span> std::valarray&lt;<span class=\"hljs-type\">uint8_t</span>&gt; &amp;vector, <span class=\"hljs-keyword\">const</span> matrix&lt;<span class=\"hljs-type\">int</span>&gt; &amp;key)</span> </span>{\n        <span class=\"hljs-function\">std::valarray&lt;<span class=\"hljs-type\">uint8_t</span>&gt; <span class=\"hljs-title\">out</span><span class=\"hljs-params\">(vector)</span></span>;  <span class=\"hljs-comment\">// make a copy</span>\n\n        <span class=\"hljs-type\">size_t</span> L = std::<span class=\"hljs-built_in\">strlen</span>(STRKEY);\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; key.<span class=\"hljs-built_in\">size</span>(); i++) {\n            <span class=\"hljs-type\">int</span> tmp = <span class=\"hljs-number\">0</span>;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; vector.<span class=\"hljs-built_in\">size</span>(); j++) {\n                tmp += key[i][j] * vector[j];\n            }\n            out[i] = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">uint8_t</span>&gt;(tmp % L);\n        }\n\n        <span class=\"hljs-keyword\">return</span> out;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Get the character at a given index in the ::STRKEY\n     *\n     * @param idx index value\n     * @return character at the index\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">char</span> <span class=\"hljs-title\">get_idx_char</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">uint8_t</span> idx)</span> </span>{ <span class=\"hljs-keyword\">return</span> STRKEY[idx]; }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Get the index of a character in the ::STRKEY\n     *\n     * @param ch character to search\n     * @return index of character\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">uint8_t</span> <span class=\"hljs-title\">get_char_idx</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-type\">char</span> ch)</span> </span>{\n        <span class=\"hljs-type\">size_t</span> L = std::<span class=\"hljs-built_in\">strlen</span>(STRKEY);\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> idx = <span class=\"hljs-number\">0</span>; idx &lt;= L; idx++)\n            <span class=\"hljs-keyword\">if</span> (STRKEY[idx] == ch)\n                <span class=\"hljs-keyword\">return</span> idx;\n\n        std::cerr &lt;&lt; __func__ &lt;&lt; <span class=\"hljs-string\">&quot;:&quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class=\"hljs-string\">&quot;: (&quot;</span> &lt;&lt; ch\n                  &lt;&lt; <span class=\"hljs-string\">&quot;) Should not reach here!\\n&quot;</span>;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Convenience function to perform block cipher operations. The\n     * operations are identical for both encryption and decryption.\n     *\n     * @param text input text to encrypt or decrypt\n     * @param key key for encryption or decryption\n     * @return encrypted/decrypted output\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">const</span> std::string <span class=\"hljs-title\">codec</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string &amp;text,\n                                   <span class=\"hljs-keyword\">const</span> matrix&lt;<span class=\"hljs-type\">int</span>&gt; &amp;key)</span> </span>{\n        <span class=\"hljs-type\">size_t</span> text_len = text.<span class=\"hljs-built_in\">length</span>();\n        <span class=\"hljs-type\">size_t</span> key_len = key.<span class=\"hljs-built_in\">size</span>();\n\n        <span class=\"hljs-comment\">// length of output string must be a multiple of key_len</span>\n        <span class=\"hljs-comment\">// create output string and initialize with &#x27;\\0&#x27; character</span>\n        <span class=\"hljs-type\">size_t</span> L2 = text_len % key_len == <span class=\"hljs-number\">0</span>\n                        ? text_len\n                        : text_len + key_len - (text_len % key_len);\n        <span class=\"hljs-function\">std::string <span class=\"hljs-title\">coded_text</span><span class=\"hljs-params\">(L2, <span class=\"hljs-string\">&#x27;\\0&#x27;</span>)</span></span>;\n\n        <span class=\"hljs-comment\">// temporary array for batch processing</span>\n        <span class=\"hljs-type\">int</span> i;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> parallel omp for private(i)</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n        <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; L2 - key_len + <span class=\"hljs-number\">1</span>; i += key_len) {\n            <span class=\"hljs-function\">std::valarray&lt;<span class=\"hljs-type\">uint8_t</span>&gt; <span class=\"hljs-title\">batch_int</span><span class=\"hljs-params\">(key_len)</span></span>;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; key_len; j++) {\n                batch_int[j] = <span class=\"hljs-built_in\">get_char_idx</span>(text[i + j]);\n            }\n\n            batch_int = <span class=\"hljs-built_in\">mat_mul</span>(batch_int, key);\n\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; key_len; j++) {\n                coded_text[i + j] =\n                    STRKEY[batch_int[j]];  <span class=\"hljs-comment\">// get character at key</span>\n            }\n        }\n\n        <span class=\"hljs-keyword\">return</span> coded_text;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Get matrix inverse using Row-transformations. Given matrix must\n     * be a square and non-singular.\n     * \\returns inverse matrix\n     **/</span>\n    <span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> matrix&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">get_inverse</span><span class=\"hljs-params\">(matrix&lt;T&gt; <span class=\"hljs-keyword\">const</span> &amp;A)</span> </span>{\n        <span class=\"hljs-comment\">// Assuming A is square matrix</span>\n        <span class=\"hljs-type\">size_t</span> N = A.<span class=\"hljs-built_in\">size</span>();\n\n        <span class=\"hljs-function\">matrix&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">inverse</span><span class=\"hljs-params\">(N, std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;(N))</span></span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row = <span class=\"hljs-number\">0</span>; row &lt; N; row++) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> col = <span class=\"hljs-number\">0</span>; col &lt; N; col++) {\n                <span class=\"hljs-comment\">// create identity matrix</span>\n                inverse[row][col] = (row == col) ? <span class=\"hljs-number\">1.f</span> : <span class=\"hljs-number\">0.f</span>;\n            }\n        }\n\n        <span class=\"hljs-keyword\">if</span> (A.<span class=\"hljs-built_in\">size</span>() != A[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>()) {\n            std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;A must be a square matrix!&quot;</span> &lt;&lt; std::endl;\n            <span class=\"hljs-keyword\">return</span> inverse;\n        }\n\n        <span class=\"hljs-comment\">// preallocate a temporary matrix identical to A</span>\n        <span class=\"hljs-function\">matrix&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">temp</span><span class=\"hljs-params\">(N, std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;(N))</span></span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row = <span class=\"hljs-number\">0</span>; row &lt; N; row++) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> col = <span class=\"hljs-number\">0</span>; col &lt; N; col++)\n                temp[row][col] = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(A[row][col]);\n        }\n\n        <span class=\"hljs-comment\">// start transformations</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row = <span class=\"hljs-number\">0</span>; row &lt; N; row++) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row2 = row; row2 &lt; N &amp;&amp; temp[row][row] == <span class=\"hljs-number\">0</span>; row2++) {\n                <span class=\"hljs-comment\">// this to ensure diagonal elements are not 0</span>\n                temp[row] = temp[row] + temp[row2];\n                inverse[row] = inverse[row] + inverse[row2];\n            }\n\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> col2 = row; col2 &lt; N &amp;&amp; temp[row][row] == <span class=\"hljs-number\">0</span>; col2++) {\n                <span class=\"hljs-comment\">// this to further ensure diagonal elements are not 0</span>\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row2 = <span class=\"hljs-number\">0</span>; row2 &lt; N; row2++) {\n                    temp[row2][row] = temp[row2][row] + temp[row2][col2];\n                    inverse[row2][row] =\n                        inverse[row2][row] + inverse[row2][col2];\n                }\n            }\n\n            <span class=\"hljs-keyword\">if</span> (temp[row][row] == <span class=\"hljs-number\">0</span>) {\n                <span class=\"hljs-comment\">// Probably a low-rank matrix and hence singular</span>\n                std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;Low-rank matrix, no inverse!&quot;</span> &lt;&lt; std::endl;\n                <span class=\"hljs-keyword\">return</span> inverse;\n            }\n\n            <span class=\"hljs-comment\">// set diagonal to 1</span>\n            <span class=\"hljs-type\">double</span> divisor = temp[row][row];\n            temp[row] = temp[row] / divisor;\n            inverse[row] = inverse[row] / divisor;\n            <span class=\"hljs-comment\">// Row transformations</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> row2 = <span class=\"hljs-number\">0</span>; row2 &lt; N; row2++) {\n                <span class=\"hljs-keyword\">if</span> (row2 == row)\n                    <span class=\"hljs-keyword\">continue</span>;\n                <span class=\"hljs-type\">double</span> factor = temp[row2][row];\n                temp[row2] = temp[row2] - factor * temp[row];\n                inverse[row2] = inverse[row2] - factor * inverse[row];\n            }\n        }\n\n        <span class=\"hljs-keyword\">return</span> inverse;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">modulo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>{\n        <span class=\"hljs-type\">int</span> ret = a % b;\n        <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>)\n            ret += b;\n        <span class=\"hljs-keyword\">return</span> ret;\n    }\n\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-comment\">/**\n     * @brief Generate encryption matrix of a given size. Larger size matrices\n     * are difficult to generate but provide more security. Important conditions\n     * are:\n     * 1. matrix should be invertible\n     * 2. determinant must not have any common factors with the length of\n     * character key\n     * There is no head-fast way to generate hte matrix under the given\n     * numerical restrictions of the machine but the conditions added achieve\n     * the goals. Bigger the matrix, greater is the probability of the matrix\n     * being ill-defined.\n     *\n     * @param size size of matrix (typically \\f$\\text{size}\\le10\\f$)\n     * @param limit1 lower limit of range of random elements (default=0)\n     * @param limit2 upper limit of range of random elements (default=10)\n     * @return Encryption martix\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> matrix&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">generate_encryption_key</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> size, <span class=\"hljs-type\">int</span> limit1 = <span class=\"hljs-number\">0</span>,\n                                               <span class=\"hljs-type\">int</span> limit2 = <span class=\"hljs-number\">10</span>)</span> </span>{\n        <span class=\"hljs-function\">matrix&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">encrypt_key</span><span class=\"hljs-params\">(size, std::valarray&lt;<span class=\"hljs-type\">int</span>&gt;(size))</span></span>;\n        matrix&lt;<span class=\"hljs-type\">int</span>&gt; min_mat = encrypt_key;\n        <span class=\"hljs-type\">int</span> mat_determinant = <span class=\"hljs-number\">-1</span>;  <span class=\"hljs-comment\">// because matrix has only ints, the</span>\n                                   <span class=\"hljs-comment\">// determinant will also be an int</span>\n        <span class=\"hljs-type\">int</span> L = std::<span class=\"hljs-built_in\">strlen</span>(STRKEY);\n\n        <span class=\"hljs-type\">double</span> dd;\n        <span class=\"hljs-keyword\">do</span> {\n            <span class=\"hljs-comment\">// keeping the random number range smaller generates better</span>\n            <span class=\"hljs-comment\">// defined matrices with more ease of cracking</span>\n            dd = <span class=\"hljs-built_in\">rand_range</span>(&amp;encrypt_key, limit1, limit2);\n            mat_determinant = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(dd);\n\n            <span class=\"hljs-keyword\">if</span> (mat_determinant &lt; <span class=\"hljs-number\">0</span>)\n                mat_determinant = (mat_determinant % L);\n        } <span class=\"hljs-keyword\">while</span> (std::<span class=\"hljs-built_in\">abs</span>(dd) &gt; <span class=\"hljs-number\">1e3</span> ||  <span class=\"hljs-comment\">// while ill-defined</span>\n                 dd &lt; <span class=\"hljs-number\">0.1</span> ||  <span class=\"hljs-comment\">// while singular or negative determinant</span>\n                 !std::<span class=\"hljs-built_in\">isfinite</span>(dd) ||  <span class=\"hljs-comment\">// while determinant is not finite</span>\n                 <span class=\"hljs-built_in\">gcd</span>(mat_determinant, L) != <span class=\"hljs-number\">1</span>);  <span class=\"hljs-comment\">// while no common factors</span>\n        <span class=\"hljs-comment\">// std::cout &lt;&lt;</span>\n\n        <span class=\"hljs-keyword\">return</span> encrypt_key;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Generate decryption matrix from an encryption matrix key.\n     *\n     * @param encrypt_key encryption key for which to create a decrypt key\n     * @return Decryption martix\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> matrix&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">generate_decryption_key</span><span class=\"hljs-params\">(matrix&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-keyword\">const</span> &amp;encrypt_key)</span> </span>{\n        <span class=\"hljs-type\">size_t</span> size = encrypt_key.<span class=\"hljs-built_in\">size</span>();\n        <span class=\"hljs-type\">int</span> L = std::<span class=\"hljs-built_in\">strlen</span>(STRKEY);\n\n        <span class=\"hljs-function\">matrix&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">decrypt_key</span><span class=\"hljs-params\">(size, std::valarray&lt;<span class=\"hljs-type\">int</span>&gt;(size))</span></span>;\n        <span class=\"hljs-type\">int</span> det_encrypt = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(<span class=\"hljs-built_in\">determinant_lu</span>(encrypt_key));\n\n        <span class=\"hljs-type\">int</span> mat_determinant = det_encrypt &lt; <span class=\"hljs-number\">0</span> ? det_encrypt % L : det_encrypt;\n\n        matrix&lt;<span class=\"hljs-type\">double</span>&gt; tmp_inverse = <span class=\"hljs-built_in\">get_inverse</span>(encrypt_key);\n        <span class=\"hljs-type\">double</span> d2 = <span class=\"hljs-built_in\">determinant_lu</span>(decrypt_key);\n\n        <span class=\"hljs-comment\">// find co-prime factor for inversion</span>\n        <span class=\"hljs-type\">int</span> det_inv = <span class=\"hljs-number\">-1</span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; L; i++) {\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">modulo</span>(mat_determinant * i, L) == <span class=\"hljs-number\">1</span>) {\n                det_inv = i;\n                <span class=\"hljs-keyword\">break</span>;\n            }\n        }\n\n        <span class=\"hljs-keyword\">if</span> (det_inv == <span class=\"hljs-number\">-1</span>) {\n            std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;Could not find a co-prime for inversion\\n&quot;</span>;\n            std::<span class=\"hljs-built_in\">exit</span>(EXIT_FAILURE);\n        }\n\n        mat_determinant = det_inv * det_encrypt;\n\n        <span class=\"hljs-comment\">// perform modular inverse of encryption matrix</span>\n        <span class=\"hljs-type\">int</span> i;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> parallel omp for private(i)</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n        <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; size; i++) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; size; j++) {\n                <span class=\"hljs-type\">int</span> temp = std::<span class=\"hljs-built_in\">round</span>(tmp_inverse[i][j] * mat_determinant);\n                decrypt_key[i][j] = <span class=\"hljs-built_in\">modulo</span>(temp, L);\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> decrypt_key;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Generate encryption and decryption key pair\n     *\n     * @param size size of matrix key (typically \\f$\\text{size}\\le10\\f$)\n     * @param limit1 lower limit of range of random elements (default=0)\n     * @param limit2 upper limit of range of random elements (default=10)\n     * @return std::pair&lt;matrix&lt;int&gt;, matrix&lt;int&gt;&gt; encryption and decryption\n     * keys as a pair\n     *\n     * @see ::generate_encryption_key\n     */</span>\n    <span class=\"hljs-keyword\">static</span> std::pair&lt;matrix&lt;<span class=\"hljs-type\">int</span>&gt;, matrix&lt;<span class=\"hljs-type\">int</span>&gt;&gt; <span class=\"hljs-built_in\">generate_keys</span>(<span class=\"hljs-type\">size_t</span> size,\n                                                             <span class=\"hljs-type\">int</span> limit1 = <span class=\"hljs-number\">0</span>,\n                                                             <span class=\"hljs-type\">int</span> limit2 = <span class=\"hljs-number\">10</span>) {\n        matrix&lt;<span class=\"hljs-type\">int</span>&gt; encrypt_key = <span class=\"hljs-built_in\">generate_encryption_key</span>(size);\n        matrix&lt;<span class=\"hljs-type\">int</span>&gt; decrypt_key = <span class=\"hljs-built_in\">generate_decryption_key</span>(encrypt_key);\n        <span class=\"hljs-type\">double</span> det2 = <span class=\"hljs-built_in\">determinant_lu</span>(decrypt_key);\n        <span class=\"hljs-keyword\">while</span> (std::<span class=\"hljs-built_in\">abs</span>(det2) &lt; <span class=\"hljs-number\">0.1</span> || std::<span class=\"hljs-built_in\">abs</span>(det2) &gt; <span class=\"hljs-number\">1e3</span>) {\n            encrypt_key = <span class=\"hljs-built_in\">generate_encryption_key</span>(size, limit1, limit2);\n            decrypt_key = <span class=\"hljs-built_in\">generate_decryption_key</span>(encrypt_key);\n            det2 = <span class=\"hljs-built_in\">determinant_lu</span>(decrypt_key);\n        }\n        <span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">make_pair</span>(encrypt_key, decrypt_key);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Encrypt a given text using a given key\n     *\n     * @param text string to encrypt\n     * @param encrypt_key  key for encryption\n     * @return encrypted text\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">const</span> std::string <span class=\"hljs-title\">encrypt_text</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string &amp;text,\n                                          <span class=\"hljs-keyword\">const</span> matrix&lt;<span class=\"hljs-type\">int</span>&gt; &amp;encrypt_key)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">codec</span>(text, encrypt_key);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @brief Decrypt a given text using a given key\n     *\n     * @param text string to decrypt\n     * @param decrypt_key  key for decryption\n     * @return decrypted text\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">const</span> std::string <span class=\"hljs-title\">decrypt_text</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string &amp;text,\n                                          <span class=\"hljs-keyword\">const</span> matrix&lt;<span class=\"hljs-type\">int</span>&gt; &amp;decrypt_key)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">codec</span>(text, decrypt_key);\n    }\n};\n\n}  <span class=\"hljs-comment\">// namespace ciphers</span>\n\n<span class=\"hljs-comment\">/**\n * @brief Self test 1 - using 3x3 randomly generated key\n *\n * @param text string to encrypt and decrypt\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test1</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string &amp;text)</span> </span>{\n    <span class=\"hljs-comment\">// std::string text = &quot;Hello world!&quot;;</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;======Test 1 (3x3 key) ======\\nOriginal text:\\n\\t&quot;</span> &lt;&lt; text\n              &lt;&lt; std::endl;\n\n    std::pair&lt;matrix&lt;<span class=\"hljs-type\">int</span>&gt;, matrix&lt;<span class=\"hljs-type\">int</span>&gt;&gt; p =\n        ciphers::HillCipher::<span class=\"hljs-built_in\">generate_keys</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>);\n    matrix&lt;<span class=\"hljs-type\">int</span>&gt; ekey = p.first;\n    matrix&lt;<span class=\"hljs-type\">int</span>&gt; dkey = p.second;\n\n    <span class=\"hljs-comment\">// matrix&lt;int&gt; ekey = {{22, 28, 25}, {5, 26, 15}, {14, 18, 9}};</span>\n    <span class=\"hljs-comment\">// std::cout &lt;&lt; &quot;Encryption key: \\n&quot; &lt;&lt; ekey;</span>\n    std::string gibberish = ciphers::HillCipher::<span class=\"hljs-built_in\">encrypt_text</span>(text, ekey);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Encrypted text:\\n\\t&quot;</span> &lt;&lt; gibberish &lt;&lt; std::endl;\n\n    <span class=\"hljs-comment\">// matrix&lt;int&gt; dkey = ciphers::HillCipher::generate_decryption_key(ekey);</span>\n    <span class=\"hljs-comment\">// std::cout &lt;&lt; &quot;Decryption key: \\n&quot; &lt;&lt; dkey;</span>\n    std::string txt_back = ciphers::HillCipher::<span class=\"hljs-built_in\">decrypt_text</span>(gibberish, dkey);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Reconstruct text:\\n\\t&quot;</span> &lt;&lt; txt_back &lt;&lt; std::endl;\n\n    <span class=\"hljs-function\">std::ofstream <span class=\"hljs-title\">out_file</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;hill_cipher_test1.txt&quot;</span>)</span></span>;\n    out_file &lt;&lt; <span class=\"hljs-string\">&quot;Block size: &quot;</span> &lt;&lt; ekey.<span class=\"hljs-built_in\">size</span>() &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n    out_file &lt;&lt; <span class=\"hljs-string\">&quot;Encryption Key:\\n&quot;</span> &lt;&lt; ekey;\n    out_file &lt;&lt; <span class=\"hljs-string\">&quot;\\nDecryption Key:\\n&quot;</span> &lt;&lt; dkey;\n    out_file.<span class=\"hljs-built_in\">close</span>();\n\n    <span class=\"hljs-built_in\">assert</span>(txt_back == text);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Passed :)\\n&quot;</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Self test 2 - using 8x8 randomly generated key\n *\n * @param text string to encrypt and decrypt\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test2</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string &amp;text)</span> </span>{\n    <span class=\"hljs-comment\">// std::string text = &quot;Hello world!&quot;;</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;======Test 2 (8x8 key) ======\\nOriginal text:\\n\\t&quot;</span> &lt;&lt; text\n              &lt;&lt; std::endl;\n\n    std::pair&lt;matrix&lt;<span class=\"hljs-type\">int</span>&gt;, matrix&lt;<span class=\"hljs-type\">int</span>&gt;&gt; p =\n        ciphers::HillCipher::<span class=\"hljs-built_in\">generate_keys</span>(<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>);\n    matrix&lt;<span class=\"hljs-type\">int</span>&gt; ekey = p.first;\n    matrix&lt;<span class=\"hljs-type\">int</span>&gt; dkey = p.second;\n\n    std::string gibberish = ciphers::HillCipher::<span class=\"hljs-built_in\">encrypt_text</span>(text, ekey);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Encrypted text:\\n\\t&quot;</span> &lt;&lt; gibberish &lt;&lt; std::endl;\n\n    std::string txt_back = ciphers::HillCipher::<span class=\"hljs-built_in\">decrypt_text</span>(gibberish, dkey);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Reconstruct text:\\n\\t&quot;</span> &lt;&lt; txt_back &lt;&lt; std::endl;\n\n    <span class=\"hljs-function\">std::ofstream <span class=\"hljs-title\">out_file</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;hill_cipher_test2.txt&quot;</span>)</span></span>;\n    out_file &lt;&lt; <span class=\"hljs-string\">&quot;Block size: &quot;</span> &lt;&lt; ekey.<span class=\"hljs-built_in\">size</span>() &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n    out_file &lt;&lt; <span class=\"hljs-string\">&quot;Encryption Key:\\n&quot;</span> &lt;&lt; ekey;\n    out_file &lt;&lt; <span class=\"hljs-string\">&quot;\\nDecryption Key:\\n&quot;</span> &lt;&lt; dkey;\n    out_file.<span class=\"hljs-built_in\">close</span>();\n\n    <span class=\"hljs-built_in\">assert</span>(txt_back.<span class=\"hljs-built_in\">compare</span>(<span class=\"hljs-number\">0</span>, text.<span class=\"hljs-built_in\">size</span>(), text) == <span class=\"hljs-number\">0</span>);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Passed :)\\n&quot;</span>;\n}\n\n<span class=\"hljs-comment\">/** Main function */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    std::<span class=\"hljs-built_in\">srand</span>(std::<span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">nullptr</span>));\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Key dictionary: (&quot;</span> &lt;&lt; std::<span class=\"hljs-built_in\">strlen</span>(ciphers::STRKEY) &lt;&lt; <span class=\"hljs-string\">&quot;)\\n\\t&quot;</span>\n              &lt;&lt; ciphers::STRKEY &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n\n    std::string text = <span class=\"hljs-string\">&quot;This is a simple text with numb3r5 and exclamat!0n.&quot;</span>;\n\n    <span class=\"hljs-built_in\">test1</span>(text);\n    <span class=\"hljs-built_in\">test2</span>(text);\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Jenia Dysin",
      "email": "jenia90@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Bharath kumar Reddy Kotha",
      "email": "bharath.charan.reddy@gmail.com",
      "commits": 1
    },
    {
      "name": "matkosoric",
      "email": "soric.matko@gmail.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Sravan Kumar Vinakota",
      "email": "35956127+JekyllAndHyde8999@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Dhruv Manilawala",
      "email": "dhruvmanila@gmail.com",
      "commits": 2
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 5
    },
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 7
    }
  ],
  "explanationUrl": {
    "en": "https://github.com/TheAlgorithms/Algorithms-Explanation/tree/master/en/Ciphers/hill_cipher.md"
  }
}
