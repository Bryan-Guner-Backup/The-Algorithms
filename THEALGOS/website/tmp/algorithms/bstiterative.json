{
  "slug": "bstiterative",
  "name": "BSTIterative",
  "categories": ["datastructures", "tree"],
  "body": {},
  "implementations": {
    "java": {
      "dir": "DataStructures/Trees/BSTIterative.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/DataStructures/Trees/BSTIterative.java",
      "code": "<span class=\"hljs-comment\">/**\n *\n *\n * &lt;h1&gt;Binary Search Tree (Iterative)&lt;/h1&gt;\n *\n * &lt;p&gt;An implementation of BST iteratively. Binary Search Tree is a binary tree which satisfies\n * three properties: left child is less than root node, right child is grater than root node, both\n * left and right childs must themselves be a BST.\n *\n * <span class=\"hljs-doctag\">@author</span> [Lakhan Nad](https://github.com/Lakhan-Nad)\n */</span>\n<span class=\"hljs-keyword\">import</span> java.util.Stack;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BSTIterative</span> {\n  <span class=\"hljs-comment\">/** Reference for the node of BST. */</span>\n  <span class=\"hljs-keyword\">private</span> Node root;\n\n  <span class=\"hljs-comment\">/** Default Constructor Initializes the root of BST with null. */</span>\n  BSTIterative() {\n    root = <span class=\"hljs-literal\">null</span>;\n  }\n\n  <span class=\"hljs-comment\">/** main function for tests */</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    <span class=\"hljs-type\">BSTIterative</span> <span class=\"hljs-variable\">tree</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BSTIterative</span>();\n    tree.add(<span class=\"hljs-number\">3</span>);\n    tree.add(<span class=\"hljs-number\">2</span>);\n    tree.add(<span class=\"hljs-number\">9</span>);\n    <span class=\"hljs-keyword\">assert</span> !tree.find(<span class=\"hljs-number\">4</span>) : <span class=\"hljs-string\">&quot;4 is not yet present in BST&quot;</span>;\n    <span class=\"hljs-keyword\">assert</span> tree.find(<span class=\"hljs-number\">2</span>) : <span class=\"hljs-string\">&quot;2 should be present in BST&quot;</span>;\n    tree.remove(<span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-keyword\">assert</span> !tree.find(<span class=\"hljs-number\">2</span>) : <span class=\"hljs-string\">&quot;2 was just deleted from BST&quot;</span>;\n    tree.remove(<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-keyword\">assert</span> !tree.find(<span class=\"hljs-number\">1</span>) : <span class=\"hljs-string\">&quot;Since 1 was not present so find deleting would do no change&quot;</span>;\n    tree.add(<span class=\"hljs-number\">30</span>);\n    tree.add(<span class=\"hljs-number\">40</span>);\n    <span class=\"hljs-keyword\">assert</span> tree.find(<span class=\"hljs-number\">40</span>) : <span class=\"hljs-string\">&quot;40 was inserted but not found&quot;</span>;\n    <span class=\"hljs-comment\">/*\n       Will print following order\n       3 9 30 40\n    */</span>\n    tree.inorder();\n  }\n\n  <span class=\"hljs-comment\">/**\n   * A method to insert a new value in BST. If the given value is already present in BST the\n   * insertion is ignored.\n   *\n   * <span class=\"hljs-doctag\">@param</span> data the value to be inserted\n   */</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">add</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> data)</span> {\n    <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">parent</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n    <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">this</span>.root;\n    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">rightOrLeft</span> <span class=\"hljs-operator\">=</span> -<span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-comment\">/* Finds the proper place this node can\n     * be placed in according to rules of BST.\n     */</span>\n    <span class=\"hljs-keyword\">while</span> (temp != <span class=\"hljs-literal\">null</span>) {\n      <span class=\"hljs-keyword\">if</span> (temp.data &gt; data) {\n        parent = temp;\n        temp = parent.left;\n        rightOrLeft = <span class=\"hljs-number\">0</span>;\n      } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (temp.data &lt; data) {\n        parent = temp;\n        temp = parent.right;\n        rightOrLeft = <span class=\"hljs-number\">1</span>;\n      } <span class=\"hljs-keyword\">else</span> {\n        System.out.println(data + <span class=\"hljs-string\">&quot; is already present in BST.&quot;</span>);\n        <span class=\"hljs-keyword\">return</span>; <span class=\"hljs-comment\">// if data already present we ignore insertion</span>\n      }\n    }\n    <span class=\"hljs-comment\">/* Creates a newNode with the value passed\n     * Since this data doesn&#x27;t already exists\n     */</span>\n    <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">newNode</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(data);\n    <span class=\"hljs-comment\">/* If the parent node is null\n     * then the insertion is to be done in\n     * root itself.\n     */</span>\n    <span class=\"hljs-keyword\">if</span> (parent == <span class=\"hljs-literal\">null</span>) {\n      <span class=\"hljs-built_in\">this</span>.root = newNode;\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">/* Check if insertion is to be made in\n       * left or right subtree.\n       */</span>\n      <span class=\"hljs-keyword\">if</span> (rightOrLeft == <span class=\"hljs-number\">0</span>) {\n        parent.left = newNode;\n      } <span class=\"hljs-keyword\">else</span> {\n        parent.right = newNode;\n      }\n    }\n  }\n\n  <span class=\"hljs-comment\">/**\n   * A method to delete the node in BST. If node is present it will be deleted\n   *\n   * <span class=\"hljs-doctag\">@param</span> data the value that needs to be deleted\n   */</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> data)</span> {\n    <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">parent</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n    <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">this</span>.root;\n    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">rightOrLeft</span> <span class=\"hljs-operator\">=</span> -<span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-comment\">/* Find the parent of the node and node itself\n     * That is to be deleted.\n     * parent variable store parent\n     * temp stores node itself.\n     * rightOrLeft use to keep track weather child\n     * is left or right subtree\n     */</span>\n    <span class=\"hljs-keyword\">while</span> (temp != <span class=\"hljs-literal\">null</span>) {\n      <span class=\"hljs-keyword\">if</span> (temp.data == data) {\n        <span class=\"hljs-keyword\">break</span>;\n      } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (temp.data &gt; data) {\n        parent = temp;\n        temp = parent.left;\n        rightOrLeft = <span class=\"hljs-number\">0</span>;\n      } <span class=\"hljs-keyword\">else</span> {\n        parent = temp;\n        temp = parent.right;\n        rightOrLeft = <span class=\"hljs-number\">1</span>;\n      }\n    }\n    <span class=\"hljs-comment\">/* If temp is null than node with given value is not\n     * present in our tree.\n     */</span>\n    <span class=\"hljs-keyword\">if</span> (temp != <span class=\"hljs-literal\">null</span>) {\n      Node replacement; <span class=\"hljs-comment\">// used to store the new values for replacing nodes</span>\n      <span class=\"hljs-keyword\">if</span> (temp.right == <span class=\"hljs-literal\">null</span> &amp;&amp; temp.left == <span class=\"hljs-literal\">null</span>) { <span class=\"hljs-comment\">// Leaf node Case</span>\n        replacement = <span class=\"hljs-literal\">null</span>;\n      } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (temp.right == <span class=\"hljs-literal\">null</span>) { <span class=\"hljs-comment\">// Node with only right child</span>\n        replacement = temp.left;\n        temp.left = <span class=\"hljs-literal\">null</span>;\n      } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (temp.left == <span class=\"hljs-literal\">null</span>) { <span class=\"hljs-comment\">// Node with only left child</span>\n        replacement = temp.right;\n        temp.right = <span class=\"hljs-literal\">null</span>;\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">/* If both left and right child are present\n         * we replace this nodes data with\n         * leftmost node&#x27;s data in its right subtree\n         * to maintain the balance of BST.\n         * And then delete that node\n         */</span>\n        <span class=\"hljs-keyword\">if</span> (temp.right.left == <span class=\"hljs-literal\">null</span>) {\n          temp.data = temp.right.data;\n          replacement = temp;\n          temp.right = temp.right.right;\n        } <span class=\"hljs-keyword\">else</span> {\n          <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">parent2</span> <span class=\"hljs-operator\">=</span> temp.right;\n          <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">child</span> <span class=\"hljs-operator\">=</span> temp.right.left;\n          <span class=\"hljs-keyword\">while</span> (child.left != <span class=\"hljs-literal\">null</span>) {\n            parent2 = child;\n            child = parent2.left;\n          }\n          temp.data = child.data;\n          parent2.left = child.right;\n          replacement = temp;\n        }\n      }\n      <span class=\"hljs-comment\">/* Change references of parent after\n       * deleting the child.\n       */</span>\n      <span class=\"hljs-keyword\">if</span> (parent == <span class=\"hljs-literal\">null</span>) {\n        <span class=\"hljs-built_in\">this</span>.root = replacement;\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">if</span> (rightOrLeft == <span class=\"hljs-number\">0</span>) {\n          parent.left = replacement;\n        } <span class=\"hljs-keyword\">else</span> {\n          parent.right = replacement;\n        }\n      }\n    }\n  }\n\n  <span class=\"hljs-comment\">/** A method for inorder traversal of BST. */</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">inorder</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.root == <span class=\"hljs-literal\">null</span>) {\n      System.out.println(<span class=\"hljs-string\">&quot;This BST is empty.&quot;</span>);\n      <span class=\"hljs-keyword\">return</span>;\n    }\n    System.out.println(<span class=\"hljs-string\">&quot;Inorder traversal of this tree is:&quot;</span>);\n    Stack&lt;Node&gt; st = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Stack</span>&lt;Node&gt;();\n    <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">cur</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">this</span>.root;\n    <span class=\"hljs-keyword\">while</span> (cur != <span class=\"hljs-literal\">null</span> || !st.empty()) {\n      <span class=\"hljs-keyword\">while</span> (cur != <span class=\"hljs-literal\">null</span>) {\n        st.push(cur);\n        cur = cur.left;\n      }\n      cur = st.pop();\n      System.out.print(cur.data + <span class=\"hljs-string\">&quot; &quot;</span>);\n      cur = cur.right;\n    }\n    System.out.println(); <span class=\"hljs-comment\">// for next line</span>\n  }\n\n  <span class=\"hljs-comment\">/** A method used to print postorder traversal of BST. */</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">postorder</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.root == <span class=\"hljs-literal\">null</span>) {\n      System.out.println(<span class=\"hljs-string\">&quot;This BST is empty.&quot;</span>);\n      <span class=\"hljs-keyword\">return</span>;\n    }\n    System.out.println(<span class=\"hljs-string\">&quot;Postorder traversal of this tree is:&quot;</span>);\n    Stack&lt;Node&gt; st = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Stack</span>&lt;Node&gt;();\n    <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">cur</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">this</span>.root, temp2;\n    <span class=\"hljs-keyword\">while</span> (cur != <span class=\"hljs-literal\">null</span> || !st.empty()) {\n      <span class=\"hljs-keyword\">if</span> (cur != <span class=\"hljs-literal\">null</span>) {\n        st.push(cur);\n        cur = cur.left;\n      } <span class=\"hljs-keyword\">else</span> {\n        temp2 = st.peek();\n        <span class=\"hljs-keyword\">if</span> (temp2.right != <span class=\"hljs-literal\">null</span>) {\n          cur = temp2.right;\n        } <span class=\"hljs-keyword\">else</span> {\n          st.pop();\n          <span class=\"hljs-keyword\">while</span> (!st.empty() &amp;&amp; st.peek().right == temp2) {\n            System.out.print(temp2.data + <span class=\"hljs-string\">&quot; &quot;</span>);\n            temp2 = st.pop();\n          }\n          System.out.print(temp2.data + <span class=\"hljs-string\">&quot; &quot;</span>);\n        }\n      }\n    }\n    System.out.println(); <span class=\"hljs-comment\">// for next line</span>\n  }\n\n  <span class=\"hljs-comment\">/** Method used to display preorder traversal of BST. */</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">preorder</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.root == <span class=\"hljs-literal\">null</span>) {\n      System.out.println(<span class=\"hljs-string\">&quot;This BST is empty.&quot;</span>);\n      <span class=\"hljs-keyword\">return</span>;\n    }\n    System.out.println(<span class=\"hljs-string\">&quot;Preorder traversal of this tree is:&quot;</span>);\n    Stack&lt;Node&gt; st = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Stack</span>&lt;Node&gt;();\n    st.push(<span class=\"hljs-built_in\">this</span>.root);\n    Node temp;\n    <span class=\"hljs-keyword\">while</span> (!st.empty()) {\n      temp = st.pop();\n      System.out.print(temp.data + <span class=\"hljs-string\">&quot; &quot;</span>);\n      <span class=\"hljs-keyword\">if</span> (temp.right != <span class=\"hljs-literal\">null</span>) {\n        st.push(temp.right);\n      }\n      <span class=\"hljs-keyword\">if</span> (temp.left != <span class=\"hljs-literal\">null</span>) {\n        st.push(temp.left);\n      }\n    }\n    System.out.println(); <span class=\"hljs-comment\">// for next line</span>\n  }\n\n  <span class=\"hljs-comment\">/**\n   * A method to check if given data exists in out Binary Search Tree.\n   *\n   * <span class=\"hljs-doctag\">@param</span> data the value that needs to be searched for\n   * <span class=\"hljs-doctag\">@return</span> boolean representing if the value was find\n   */</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> data)</span> {\n    <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">this</span>.root;\n    <span class=\"hljs-comment\">/* Check if node exists\n     */</span>\n    <span class=\"hljs-keyword\">while</span> (temp != <span class=\"hljs-literal\">null</span>) {\n      <span class=\"hljs-keyword\">if</span> (temp.data &gt; data) {\n        temp = temp.left;\n      } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (temp.data &lt; data) {\n        temp = temp.right;\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">/* If found return true\n         */</span>\n        System.out.println(data + <span class=\"hljs-string\">&quot; is present in the BST.&quot;</span>);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n      }\n    }\n    System.out.println(data + <span class=\"hljs-string\">&quot; not found.&quot;</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n  }\n\n  <span class=\"hljs-comment\">/** The Node class used for building binary search tree */</span>\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Node</span> {\n    <span class=\"hljs-type\">int</span> data;\n    Node left;\n    Node right;\n\n    <span class=\"hljs-comment\">/** Constructor with data as parameter */</span>\n    Node(<span class=\"hljs-type\">int</span> d) {\n      data = d;\n      left = <span class=\"hljs-literal\">null</span>;\n      right = <span class=\"hljs-literal\">null</span>;\n    }\n  }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "lakhan_nad",
      "email": "lakhannad1999@gmail.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}
