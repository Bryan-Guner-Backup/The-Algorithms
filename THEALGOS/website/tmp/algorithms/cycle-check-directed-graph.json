{
  "slug": "cycle-check-directed-graph",
  "name": "Cycle Check Directed Graph",
  "categories": ["graphs"],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "graph/cycle_check_directed_graph.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph/cycle_check_directed_graph.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file cycle_check_directed graph.cpp\n *\n * @brief BFS and DFS algorithms to check for cycle in a directed graph.\n *\n * @author [Anmol3299](mailto:mittalanmol22@gmail.com)\n *\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>     <span class=\"hljs-comment\">// for std::cout</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;map&gt;</span>          <span class=\"hljs-comment\">// for std::map</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span>        <span class=\"hljs-comment\">// for std::queue</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdexcept&gt;</span>    <span class=\"hljs-comment\">// for throwing errors</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;type_traits&gt;</span>  <span class=\"hljs-comment\">// for std::remove_reference</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;utility&gt;</span>      <span class=\"hljs-comment\">// for std::move</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>       <span class=\"hljs-comment\">// for std::vector</span></span>\n\n<span class=\"hljs-comment\">/**\n * Implementation of non-weighted directed edge of a graph.\n *\n * The source vertex of the edge is labelled &quot;src&quot; and destination vertex is\n * labelled &quot;dest&quot;.\n */</span>\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Edge</span> {\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-type\">int</span> src;\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-type\">int</span> dest;\n\n    <span class=\"hljs-built_in\">Edge</span>() = <span class=\"hljs-keyword\">delete</span>;\n    ~<span class=\"hljs-built_in\">Edge</span>() = <span class=\"hljs-keyword\">default</span>;\n    <span class=\"hljs-built_in\">Edge</span>(Edge&amp;&amp;) = <span class=\"hljs-keyword\">default</span>;\n    Edge&amp; <span class=\"hljs-keyword\">operator</span>=(Edge&amp;&amp;) = <span class=\"hljs-keyword\">default</span>;\n    <span class=\"hljs-built_in\">Edge</span>(Edge <span class=\"hljs-keyword\">const</span>&amp;) = <span class=\"hljs-keyword\">default</span>;\n    Edge&amp; <span class=\"hljs-keyword\">operator</span>=(Edge <span class=\"hljs-keyword\">const</span>&amp;) = <span class=\"hljs-keyword\">default</span>;\n\n    <span class=\"hljs-comment\">/** Set the source and destination of the vertex.\n     *\n     * @param source is the source vertex of the edge.\n     * @param destination is the destination vertex of the edge.\n     */</span>\n    <span class=\"hljs-built_in\">Edge</span>(<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-type\">int</span> source, <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-type\">int</span> destination)\n        : <span class=\"hljs-built_in\">src</span>(source), <span class=\"hljs-built_in\">dest</span>(destination) {}\n};\n\n<span class=\"hljs-keyword\">using</span> AdjList = std::map&lt;<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-type\">int</span>, std::vector&lt;<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-type\">int</span>&gt;&gt;;\n\n<span class=\"hljs-comment\">/**\n * Implementation of graph class.\n *\n * The graph will be represented using Adjacency List representation.\n * This class contains 2 data members &quot;m_vertices&quot; &amp; &quot;m_adjList&quot; used to\n * represent the number of vertices and adjacency list of the graph\n * respectively. The vertices are labelled 0 - (m_vertices - 1).\n */</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Graph</span> {\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-built_in\">Graph</span>() : <span class=\"hljs-built_in\">m_adjList</span>({}) {}\n    ~<span class=\"hljs-built_in\">Graph</span>() = <span class=\"hljs-keyword\">default</span>;\n    <span class=\"hljs-built_in\">Graph</span>(Graph&amp;&amp;) = <span class=\"hljs-keyword\">default</span>;\n    Graph&amp; <span class=\"hljs-keyword\">operator</span>=(Graph&amp;&amp;) = <span class=\"hljs-keyword\">default</span>;\n    <span class=\"hljs-built_in\">Graph</span>(Graph <span class=\"hljs-keyword\">const</span>&amp;) = <span class=\"hljs-keyword\">default</span>;\n    Graph&amp; <span class=\"hljs-keyword\">operator</span>=(Graph <span class=\"hljs-keyword\">const</span>&amp;) = <span class=\"hljs-keyword\">default</span>;\n\n    <span class=\"hljs-comment\">/** Create a graph from vertices and adjacency list.\n     *\n     * @param vertices specify the number of vertices the graph would contain.\n     * @param adjList is the adjacency list representation of graph.\n     */</span>\n    <span class=\"hljs-built_in\">Graph</span>(<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-type\">int</span> vertices, AdjList adjList)\n        : <span class=\"hljs-built_in\">m_vertices</span>(vertices), <span class=\"hljs-built_in\">m_adjList</span>(std::<span class=\"hljs-built_in\">move</span>(adjList)) {}\n\n    <span class=\"hljs-comment\">/** Create a graph from vertices and adjacency list.\n     *\n     * @param vertices specify the number of vertices the graph would contain.\n     * @param adjList is the adjacency list representation of graph.\n     */</span>\n    <span class=\"hljs-built_in\">Graph</span>(<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-type\">int</span> vertices, AdjList&amp;&amp; adjList)\n        : <span class=\"hljs-built_in\">m_vertices</span>(vertices), <span class=\"hljs-built_in\">m_adjList</span>(std::<span class=\"hljs-built_in\">move</span>(adjList)) {}\n\n    <span class=\"hljs-comment\">/** Create a graph from vertices and a set of edges.\n     *\n     * Adjacency list of the graph would be created from the set of edges. If\n     * the source or destination of any edge has a value greater or equal to\n     * number of vertices, then it would throw a range_error.\n     *\n     * @param vertices specify the number of vertices the graph would contain.\n     * @param edges is a vector of edges.\n     */</span>\n    <span class=\"hljs-built_in\">Graph</span>(<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-type\">int</span> vertices, std::vector&lt;Edge&gt; <span class=\"hljs-keyword\">const</span>&amp; edges)\n        : <span class=\"hljs-built_in\">m_vertices</span>(vertices) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> <span class=\"hljs-keyword\">const</span>&amp; edge : edges) {\n            <span class=\"hljs-keyword\">if</span> (edge.src &gt;= vertices || edge.dest &gt;= vertices) {\n                <span class=\"hljs-keyword\">throw</span> std::<span class=\"hljs-built_in\">range_error</span>(\n                    <span class=\"hljs-string\">&quot;Either src or dest of edge out of range&quot;</span>);\n            }\n            m_adjList[edge.src].<span class=\"hljs-built_in\">emplace_back</span>(edge.dest);\n        }\n    }\n\n    <span class=\"hljs-comment\">/** Return a const reference of the adjacency list.\n     *\n     * @return const reference to the adjacency list\n     */</span>\n    std::remove_reference&lt;AdjList&gt;::<span class=\"hljs-function\">type <span class=\"hljs-keyword\">const</span>&amp; <span class=\"hljs-title\">getAdjList</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span> </span>{\n        <span class=\"hljs-keyword\">return</span> m_adjList;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * @return number of vertices in the graph.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">getVertices</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span> </span>{ <span class=\"hljs-keyword\">return</span> m_vertices; }\n\n    <span class=\"hljs-comment\">/** Add vertices in the graph.\n     *\n     * @param num is the number of vertices to be added. It adds 1 vertex by\n     * default.\n     *\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addVertices</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-type\">int</span> num = <span class=\"hljs-number\">1</span>)</span> </span>{ m_vertices += num; }\n\n    <span class=\"hljs-comment\">/** Add an edge in the graph.\n     *\n     * @param edge that needs to be added.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addEdge</span><span class=\"hljs-params\">(Edge <span class=\"hljs-keyword\">const</span>&amp; edge)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (edge.src &gt;= m_vertices || edge.dest &gt;= m_vertices) {\n            <span class=\"hljs-keyword\">throw</span> std::<span class=\"hljs-built_in\">range_error</span>(<span class=\"hljs-string\">&quot;Either src or dest of edge out of range&quot;</span>);\n        }\n        m_adjList[edge.src].<span class=\"hljs-built_in\">emplace_back</span>(edge.dest);\n    }\n\n    <span class=\"hljs-comment\">/** Add an Edge in the graph\n     *\n     * @param source is source vertex of the edge.\n     * @param destination is the destination vertex of the edge.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addEdge</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-type\">int</span> source, <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-type\">int</span> destination)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (source &gt;= m_vertices || destination &gt;= m_vertices) {\n            <span class=\"hljs-keyword\">throw</span> std::<span class=\"hljs-built_in\">range_error</span>(\n                <span class=\"hljs-string\">&quot;Either source or destination of edge out of range&quot;</span>);\n        }\n        m_adjList[source].<span class=\"hljs-built_in\">emplace_back</span>(destination);\n    }\n\n <span class=\"hljs-keyword\">private</span>:\n    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-type\">int</span> m_vertices = <span class=\"hljs-number\">0</span>;\n    AdjList m_adjList;\n};\n\n<span class=\"hljs-comment\">/**\n * Check if a directed graph has a cycle or not.\n *\n * This class provides 2 methods to check for cycle in a directed graph:\n * isCyclicDFS &amp; isCyclicBFS.\n *\n * - isCyclicDFS uses DFS traversal method to check for cycle in a graph.\n * - isCyclidBFS used BFS traversal method to check for cycle in a graph.\n */</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CycleCheck</span> {\n <span class=\"hljs-keyword\">private</span>:\n    <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">nodeStates</span> : <span class=\"hljs-type\">uint8_t</span> { not_visited = <span class=\"hljs-number\">0</span>, in_stack, visited };\n\n    <span class=\"hljs-comment\">/** Helper function of &quot;isCyclicDFS&quot;.\n     *\n     * @param adjList is the adjacency list representation of some graph.\n     * @param state is the state of the nodes of the graph.\n     * @param node is the node being evaluated.\n     *\n     * @return true if graph has a cycle, else false.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isCyclicDFSHelper</span><span class=\"hljs-params\">(AdjList <span class=\"hljs-keyword\">const</span>&amp; adjList,\n                                  std::vector&lt;nodeStates&gt;* state,\n                                  <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-type\">int</span> node)</span> </span>{\n        <span class=\"hljs-comment\">// Add node &quot;in_stack&quot; state.</span>\n        (*state)[node] = in_stack;\n\n        <span class=\"hljs-comment\">// If the node has children, then recursively visit all children of the</span>\n        <span class=\"hljs-comment\">// node.</span>\n        <span class=\"hljs-keyword\">auto</span> <span class=\"hljs-keyword\">const</span> it = adjList.<span class=\"hljs-built_in\">find</span>(node);\n        <span class=\"hljs-keyword\">if</span> (it != adjList.<span class=\"hljs-built_in\">end</span>()) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> child : it-&gt;second) {\n                <span class=\"hljs-comment\">// If state of child node is &quot;not_visited&quot;, evaluate that child</span>\n                <span class=\"hljs-comment\">// for presence of cycle.</span>\n                <span class=\"hljs-keyword\">auto</span> state_of_child = (*state)[child];\n                <span class=\"hljs-keyword\">if</span> (state_of_child == not_visited) {\n                    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isCyclicDFSHelper</span>(adjList, state, child)) {\n                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n                    }\n                } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (state_of_child == in_stack) {\n                    <span class=\"hljs-comment\">// If child node was &quot;in_stack&quot;, then that means that there</span>\n                    <span class=\"hljs-comment\">// is a cycle in the graph. Return true for presence of the</span>\n                    <span class=\"hljs-comment\">// cycle.</span>\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n                }\n            }\n        }\n\n        <span class=\"hljs-comment\">// Current node has been evaluated for the presence of cycle and had no</span>\n        <span class=\"hljs-comment\">// cycle. Mark current node as &quot;visited&quot;.</span>\n        (*state)[node] = visited;\n        <span class=\"hljs-comment\">// Return that current node didn&#x27;t result in any cycles.</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    }\n\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-comment\">/** Driver function to check if a graph has a cycle.\n     *\n     * This function uses DFS to check for cycle in the graph.\n     *\n     * @param graph which needs to be evaluated for the presence of cycle.\n     * @return true if a cycle is detected, else false.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isCyclicDFS</span><span class=\"hljs-params\">(Graph <span class=\"hljs-keyword\">const</span>&amp; graph)</span> </span>{\n        <span class=\"hljs-keyword\">auto</span> vertices = graph.<span class=\"hljs-built_in\">getVertices</span>();\n\n        <span class=\"hljs-comment\">/** State of the node.\n         *\n         * It is a vector of &quot;nodeStates&quot; which represents the state node is in.\n         * It can take only 3 values: &quot;not_visited&quot;, &quot;in_stack&quot;, and &quot;visited&quot;.\n         *\n         * Initially, all nodes are in &quot;not_visited&quot; state.\n         */</span>\n        <span class=\"hljs-function\">std::vector&lt;nodeStates&gt; <span class=\"hljs-title\">state</span><span class=\"hljs-params\">(vertices, not_visited)</span></span>;\n\n        <span class=\"hljs-comment\">// Start visiting each node.</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-type\">int</span> node = <span class=\"hljs-number\">0</span>; node &lt; vertices; node++) {\n            <span class=\"hljs-comment\">// If a node is not visited, only then check for presence of cycle.</span>\n            <span class=\"hljs-comment\">// There is no need to check for presence of cycle for a visited</span>\n            <span class=\"hljs-comment\">// node as it has already been checked for presence of cycle.</span>\n            <span class=\"hljs-keyword\">if</span> (state[node] == not_visited) {\n                <span class=\"hljs-comment\">// Check for cycle.</span>\n                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isCyclicDFSHelper</span>(graph.<span class=\"hljs-built_in\">getAdjList</span>(), &amp;state, node)) {\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n                }\n            }\n        }\n\n        <span class=\"hljs-comment\">// All nodes have been safely traversed, that means there is no cycle in</span>\n        <span class=\"hljs-comment\">// the graph. Return false.</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    }\n\n    <span class=\"hljs-comment\">/** Check if a graph has cycle or not.\n     *\n     * This function uses BFS to check if a graph is cyclic or not.\n     *\n     * @param graph which needs to be evaluated for the presence of cycle.\n     * @return true if a cycle is detected, else false.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isCyclicBFS</span><span class=\"hljs-params\">(Graph <span class=\"hljs-keyword\">const</span>&amp; graph)</span> </span>{\n        <span class=\"hljs-keyword\">auto</span> graphAjdList = graph.<span class=\"hljs-built_in\">getAdjList</span>();\n        <span class=\"hljs-keyword\">auto</span> vertices = graph.<span class=\"hljs-built_in\">getVertices</span>();\n\n        <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">indegree</span><span class=\"hljs-params\">(vertices, <span class=\"hljs-number\">0</span>)</span></span>;\n        <span class=\"hljs-comment\">// Calculate the indegree i.e. the number of incident edges to the node.</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> <span class=\"hljs-keyword\">const</span>&amp; list : graphAjdList) {\n            <span class=\"hljs-keyword\">auto</span> children = list.second;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> <span class=\"hljs-keyword\">const</span>&amp; child : children) {\n                indegree[child]++;\n            }\n        }\n\n        std::queue&lt;<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-type\">int</span>&gt; can_be_solved;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-type\">int</span> node = <span class=\"hljs-number\">0</span>; node &lt; vertices; node++) {\n            <span class=\"hljs-comment\">// If a node doesn&#x27;t have any input edges, then that node will</span>\n            <span class=\"hljs-comment\">// definately not result in a cycle and can be visited safely.</span>\n            <span class=\"hljs-keyword\">if</span> (!indegree[node]) {\n                can_be_solved.<span class=\"hljs-built_in\">emplace</span>(node);\n            }\n        }\n\n        <span class=\"hljs-comment\">// Vertices that need to be traversed.</span>\n        <span class=\"hljs-keyword\">auto</span> remain = vertices;\n        <span class=\"hljs-comment\">// While there are safe nodes that we can visit.</span>\n        <span class=\"hljs-keyword\">while</span> (!can_be_solved.<span class=\"hljs-built_in\">empty</span>()) {\n            <span class=\"hljs-keyword\">auto</span> solved = can_be_solved.<span class=\"hljs-built_in\">front</span>();\n            <span class=\"hljs-comment\">// Visit the node.</span>\n            can_be_solved.<span class=\"hljs-built_in\">pop</span>();\n            <span class=\"hljs-comment\">// Decrease number of nodes that need to be traversed.</span>\n            remain--;\n\n            <span class=\"hljs-comment\">// Visit all the children of the visited node.</span>\n            <span class=\"hljs-keyword\">auto</span> it = graphAjdList.<span class=\"hljs-built_in\">find</span>(solved);\n            <span class=\"hljs-keyword\">if</span> (it != graphAjdList.<span class=\"hljs-built_in\">end</span>()) {\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> child : it-&gt;second) {\n                    <span class=\"hljs-comment\">// Check if we can visited the node safely.</span>\n                    <span class=\"hljs-keyword\">if</span> (--indegree[child] == <span class=\"hljs-number\">0</span>) {\n                        <span class=\"hljs-comment\">// if node can be visited safely, then add that node to</span>\n                        <span class=\"hljs-comment\">// the visit queue.</span>\n                        can_be_solved.<span class=\"hljs-built_in\">emplace</span>(child);\n                    }\n                }\n            }\n        }\n\n        <span class=\"hljs-comment\">// If there are still nodes that we can&#x27;t visit, then it means that</span>\n        <span class=\"hljs-comment\">// there is a cycle and return true, else return false.</span>\n        <span class=\"hljs-keyword\">return</span> !(remain == <span class=\"hljs-number\">0</span>);\n    }\n};\n\n<span class=\"hljs-comment\">/**\n * Main function.\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// Instantiate the graph.</span>\n    <span class=\"hljs-function\">Graph <span class=\"hljs-title\">g</span><span class=\"hljs-params\">(<span class=\"hljs-number\">7</span>, std::vector&lt;Edge&gt;{{<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>}, {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>}})</span></span>;\n    <span class=\"hljs-comment\">// Check for cycle using BFS method.</span>\n    std::cout &lt;&lt; CycleCheck::<span class=\"hljs-built_in\">isCyclicBFS</span>(g) &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;\n\n    <span class=\"hljs-comment\">// Check for cycle using DFS method.</span>\n    std::cout &lt;&lt; CycleCheck::<span class=\"hljs-built_in\">isCyclicDFS</span>(g) &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Ayaan Khan",
      "email": "ayaankhan98@gmail.com",
      "commits": 1
    },
    {
      "name": "Anmol Mittal",
      "email": "mittalanmol22@gmail.com",
      "commits": 1
    },
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}
