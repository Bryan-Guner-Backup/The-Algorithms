{
  "slug": "radix2-fft",
  "name": "Radix2 Fft",
  "categories": ["math"],
  "body": {},
  "implementations": {
    "python": {
      "dir": "maths/radix2_fft.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/maths/radix2_fft.py",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;\r\nFast Polynomial Multiplication using radix-2 fast Fourier Transform.\r\n&quot;&quot;&quot;</span>\r\n\r\n<span class=\"hljs-keyword\">import</span> mpmath  <span class=\"hljs-comment\"># for roots of unity</span>\r\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\r\n\r\n\r\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FFT</span>:\r\n    <span class=\"hljs-string\">&quot;&quot;&quot;\r\n    Fast Polynomial Multiplication using radix-2 fast Fourier Transform.\r\n\r\n    Reference:\r\n    https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm#The_radix-2_DIT_case\r\n\r\n    For polynomials of degree m and n the algorithms has complexity\r\n    O(n*logn + m*logm)\r\n\r\n    The main part of the algorithm is split in two parts:\r\n        1) __DFT: We compute the discrete fourier transform (DFT) of A and B using a\r\n        bottom-up dynamic approach -\r\n        2) __multiply: Once we obtain the DFT of A*B, we can similarly\r\n        invert it to obtain A*B\r\n\r\n    The class FFT takes two polynomials A and B with complex coefficients as arguments;\r\n    The two polynomials should be represented as a sequence of coefficients starting\r\n    from the free term. Thus, for instance x + 2*x^3 could be represented as\r\n    [0,1,0,2] or (0,1,0,2). The constructor adds some zeros at the end so that the\r\n    polynomials have the same length which is a power of 2 at least the length of\r\n    their product.\r\n\r\n    Example:\r\n\r\n    Create two polynomials as sequences\r\n    &gt;&gt;&gt; A = [0, 1, 0, 2]  # x+2x^3\r\n    &gt;&gt;&gt; B = (2, 3, 4, 0)  # 2+3x+4x^2\r\n\r\n    Create an FFT object with them\r\n    &gt;&gt;&gt; x = FFT(A, B)\r\n\r\n    Print product\r\n    &gt;&gt;&gt; print(x.product)  # 2x + 3x^2 + 8x^3 + 4x^4 + 6x^5\r\n    [(-0+0j), (2+0j), (3+0j), (8+0j), (6+0j), (8+0j)]\r\n\r\n    __str__ test\r\n    &gt;&gt;&gt; print(x)\r\n    A = 0*x^0 + 1*x^1 + 2*x^0 + 3*x^2\r\n    B = 0*x^2 + 1*x^3 + 2*x^4\r\n    A*B = 0*x^(-0+0j) + 1*x^(2+0j) + 2*x^(3+0j) + 3*x^(8+0j) + 4*x^(6+0j) + 5*x^(8+0j)\r\n    &quot;&quot;&quot;</span>\r\n\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, polyA=[<span class=\"hljs-number\">0</span>], polyB=[<span class=\"hljs-number\">0</span>]</span>):\r\n        <span class=\"hljs-comment\"># Input as list</span>\r\n        self.polyA = <span class=\"hljs-built_in\">list</span>(polyA)[:]\r\n        self.polyB = <span class=\"hljs-built_in\">list</span>(polyB)[:]\r\n\r\n        <span class=\"hljs-comment\"># Remove leading zero coefficients</span>\r\n        <span class=\"hljs-keyword\">while</span> self.polyA[-<span class=\"hljs-number\">1</span>] == <span class=\"hljs-number\">0</span>:\r\n            self.polyA.pop()\r\n        self.len_A = <span class=\"hljs-built_in\">len</span>(self.polyA)\r\n\r\n        <span class=\"hljs-keyword\">while</span> self.polyB[-<span class=\"hljs-number\">1</span>] == <span class=\"hljs-number\">0</span>:\r\n            self.polyB.pop()\r\n        self.len_B = <span class=\"hljs-built_in\">len</span>(self.polyB)\r\n\r\n        <span class=\"hljs-comment\"># Add 0 to make lengths equal a power of 2</span>\r\n        self.C_max_length = <span class=\"hljs-built_in\">int</span>(\r\n            <span class=\"hljs-number\">2</span> ** np.ceil(np.log2(<span class=\"hljs-built_in\">len</span>(self.polyA) + <span class=\"hljs-built_in\">len</span>(self.polyB) - <span class=\"hljs-number\">1</span>))\r\n        )\r\n\r\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-built_in\">len</span>(self.polyA) &lt; self.C_max_length:\r\n            self.polyA.append(<span class=\"hljs-number\">0</span>)\r\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-built_in\">len</span>(self.polyB) &lt; self.C_max_length:\r\n            self.polyB.append(<span class=\"hljs-number\">0</span>)\r\n        <span class=\"hljs-comment\"># A complex root used for the fourier transform</span>\r\n        self.root = <span class=\"hljs-built_in\">complex</span>(mpmath.root(x=<span class=\"hljs-number\">1</span>, n=self.C_max_length, k=<span class=\"hljs-number\">1</span>))\r\n\r\n        <span class=\"hljs-comment\"># The product</span>\r\n        self.product = self.__multiply()\r\n\r\n    <span class=\"hljs-comment\"># Discrete fourier transform of A and B</span>\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__DFT</span>(<span class=\"hljs-params\">self, which</span>):\r\n        <span class=\"hljs-keyword\">if</span> which == <span class=\"hljs-string\">&quot;A&quot;</span>:\r\n            dft = [[x] <span class=\"hljs-keyword\">for</span> x <span class=\"hljs-keyword\">in</span> self.polyA]\r\n        <span class=\"hljs-keyword\">else</span>:\r\n            dft = [[x] <span class=\"hljs-keyword\">for</span> x <span class=\"hljs-keyword\">in</span> self.polyB]\r\n        <span class=\"hljs-comment\"># Corner case</span>\r\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(dft) &lt;= <span class=\"hljs-number\">1</span>:\r\n            <span class=\"hljs-keyword\">return</span> dft[<span class=\"hljs-number\">0</span>]\r\n        <span class=\"hljs-comment\">#</span>\r\n        next_ncol = self.C_max_length // <span class=\"hljs-number\">2</span>\r\n        <span class=\"hljs-keyword\">while</span> next_ncol &gt; <span class=\"hljs-number\">0</span>:\r\n            new_dft = [[] <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(next_ncol)]\r\n            root = self.root ** next_ncol\r\n\r\n            <span class=\"hljs-comment\"># First half of next step</span>\r\n            current_root = <span class=\"hljs-number\">1</span>\r\n            <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(self.C_max_length // (next_ncol * <span class=\"hljs-number\">2</span>)):\r\n                <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(next_ncol):\r\n                    new_dft[i].append(dft[i][j] + current_root * dft[i + next_ncol][j])\r\n                current_root *= root\r\n            <span class=\"hljs-comment\"># Second half of next step</span>\r\n            current_root = <span class=\"hljs-number\">1</span>\r\n            <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(self.C_max_length // (next_ncol * <span class=\"hljs-number\">2</span>)):\r\n                <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(next_ncol):\r\n                    new_dft[i].append(dft[i][j] - current_root * dft[i + next_ncol][j])\r\n                current_root *= root\r\n            <span class=\"hljs-comment\"># Update</span>\r\n            dft = new_dft\r\n            next_ncol = next_ncol // <span class=\"hljs-number\">2</span>\r\n        <span class=\"hljs-keyword\">return</span> dft[<span class=\"hljs-number\">0</span>]\r\n\r\n    <span class=\"hljs-comment\"># multiply the DFTs of  A and B and find A*B</span>\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__multiply</span>(<span class=\"hljs-params\">self</span>):\r\n        dftA = self.__DFT(<span class=\"hljs-string\">&quot;A&quot;</span>)\r\n        dftB = self.__DFT(<span class=\"hljs-string\">&quot;B&quot;</span>)\r\n        inverseC = [[dftA[i] * dftB[i] <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(self.C_max_length)]]\r\n        <span class=\"hljs-keyword\">del</span> dftA\r\n        <span class=\"hljs-keyword\">del</span> dftB\r\n\r\n        <span class=\"hljs-comment\"># Corner Case</span>\r\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(inverseC[<span class=\"hljs-number\">0</span>]) &lt;= <span class=\"hljs-number\">1</span>:\r\n            <span class=\"hljs-keyword\">return</span> inverseC[<span class=\"hljs-number\">0</span>]\r\n        <span class=\"hljs-comment\"># Inverse DFT</span>\r\n        next_ncol = <span class=\"hljs-number\">2</span>\r\n        <span class=\"hljs-keyword\">while</span> next_ncol &lt;= self.C_max_length:\r\n            new_inverseC = [[] <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(next_ncol)]\r\n            root = self.root ** (next_ncol // <span class=\"hljs-number\">2</span>)\r\n            current_root = <span class=\"hljs-number\">1</span>\r\n            <span class=\"hljs-comment\"># First half of next step</span>\r\n            <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(self.C_max_length // next_ncol):\r\n                <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(next_ncol // <span class=\"hljs-number\">2</span>):\r\n                    <span class=\"hljs-comment\"># Even positions</span>\r\n                    new_inverseC[i].append(\r\n                        (\r\n                            inverseC[i][j]\r\n                            + inverseC[i][j + self.C_max_length // next_ncol]\r\n                        )\r\n                        / <span class=\"hljs-number\">2</span>\r\n                    )\r\n                    <span class=\"hljs-comment\"># Odd positions</span>\r\n                    new_inverseC[i + next_ncol // <span class=\"hljs-number\">2</span>].append(\r\n                        (\r\n                            inverseC[i][j]\r\n                            - inverseC[i][j + self.C_max_length // next_ncol]\r\n                        )\r\n                        / (<span class=\"hljs-number\">2</span> * current_root)\r\n                    )\r\n                current_root *= root\r\n            <span class=\"hljs-comment\"># Update</span>\r\n            inverseC = new_inverseC\r\n            next_ncol *= <span class=\"hljs-number\">2</span>\r\n        <span class=\"hljs-comment\"># Unpack</span>\r\n        inverseC = [<span class=\"hljs-built_in\">round</span>(x[<span class=\"hljs-number\">0</span>].real, <span class=\"hljs-number\">8</span>) + <span class=\"hljs-built_in\">round</span>(x[<span class=\"hljs-number\">0</span>].imag, <span class=\"hljs-number\">8</span>) * <span class=\"hljs-number\">1j</span> <span class=\"hljs-keyword\">for</span> x <span class=\"hljs-keyword\">in</span> inverseC]\r\n\r\n        <span class=\"hljs-comment\"># Remove leading 0&#x27;s</span>\r\n        <span class=\"hljs-keyword\">while</span> inverseC[-<span class=\"hljs-number\">1</span>] == <span class=\"hljs-number\">0</span>:\r\n            inverseC.pop()\r\n        <span class=\"hljs-keyword\">return</span> inverseC\r\n\r\n    <span class=\"hljs-comment\"># Overwrite __str__ for print(); Shows A, B and A*B</span>\r\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__str__</span>(<span class=\"hljs-params\">self</span>):\r\n        A = <span class=\"hljs-string\">&quot;A = &quot;</span> + <span class=\"hljs-string\">&quot; + &quot;</span>.join(\r\n            <span class=\"hljs-string\">f&quot;<span class=\"hljs-subst\">{coef}</span>*x^<span class=\"hljs-subst\">{i}</span>&quot;</span> <span class=\"hljs-keyword\">for</span> coef, i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(self.polyA[: self.len_A])\r\n        )\r\n        B = <span class=\"hljs-string\">&quot;B = &quot;</span> + <span class=\"hljs-string\">&quot; + &quot;</span>.join(\r\n            <span class=\"hljs-string\">f&quot;<span class=\"hljs-subst\">{coef}</span>*x^<span class=\"hljs-subst\">{i}</span>&quot;</span> <span class=\"hljs-keyword\">for</span> coef, i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(self.polyB[: self.len_B])\r\n        )\r\n        C = <span class=\"hljs-string\">&quot;A*B = &quot;</span> + <span class=\"hljs-string\">&quot; + &quot;</span>.join(\r\n            <span class=\"hljs-string\">f&quot;<span class=\"hljs-subst\">{coef}</span>*x^<span class=\"hljs-subst\">{i}</span>&quot;</span> <span class=\"hljs-keyword\">for</span> coef, i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(self.product)\r\n        )\r\n\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;\\n&quot;</span>.join((A, B, C))\r\n\r\n\r\n<span class=\"hljs-comment\"># Unit tests</span>\r\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\r\n    <span class=\"hljs-keyword\">import</span> doctest\r\n\r\n    doctest.testmod()\r\n"
    }
  },
  "contributors": [
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Kiril Bangachev",
      "email": "51961981+KirilBangachev@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}
