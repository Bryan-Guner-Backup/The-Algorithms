{
  "slug": "bailey-borwein-plouffe",
  "name": "Bailey Borwein Plouffe",
  "categories": ["math"],
  "body": {},
  "implementations": {
    "python": {
      "dir": "maths/bailey_borwein_plouffe.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/maths/bailey_borwein_plouffe.py",
      "code": "<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">bailey_borwein_plouffe</span>(<span class=\"hljs-params\">digit_position: <span class=\"hljs-built_in\">int</span>, precision: <span class=\"hljs-built_in\">int</span> = <span class=\"hljs-number\">1000</span></span>) -&gt; <span class=\"hljs-built_in\">str</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Implement a popular pi-digit-extraction algorithm known as the\n    Bailey-Borwein-Plouffe (BBP) formula to calculate the nth hex digit of pi.\n    Wikipedia page:\n    https://en.wikipedia.org/wiki/Bailey%E2%80%93Borwein%E2%80%93Plouffe_formula\n    @param digit_position: a positive integer representing the position of the digit to\n    extract.\n    The digit immediately after the decimal point is located at position 1.\n    @param precision: number of terms in the second summation to calculate.\n    A higher number reduces the chance of an error but increases the runtime.\n    @return: a hexadecimal digit representing the digit at the nth position\n    in pi&#x27;s decimal expansion.\n\n    &gt;&gt;&gt; &quot;&quot;.join(bailey_borwein_plouffe(i) for i in range(1, 11))\n    &#x27;243f6a8885&#x27;\n    &gt;&gt;&gt; bailey_borwein_plouffe(5, 10000)\n    &#x27;6&#x27;\n    &gt;&gt;&gt; bailey_borwein_plouffe(-10)\n    Traceback (most recent call last):\n      ...\n    ValueError: Digit position must be a positive integer\n    &gt;&gt;&gt; bailey_borwein_plouffe(0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Digit position must be a positive integer\n    &gt;&gt;&gt; bailey_borwein_plouffe(1.7)\n    Traceback (most recent call last):\n      ...\n    ValueError: Digit position must be a positive integer\n    &gt;&gt;&gt; bailey_borwein_plouffe(2, -10)\n    Traceback (most recent call last):\n      ...\n    ValueError: Precision must be a nonnegative integer\n    &gt;&gt;&gt; bailey_borwein_plouffe(2, 1.6)\n    Traceback (most recent call last):\n      ...\n    ValueError: Precision must be a nonnegative integer\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">not</span> <span class=\"hljs-built_in\">isinstance</span>(digit_position, <span class=\"hljs-built_in\">int</span>)) <span class=\"hljs-keyword\">or</span> (digit_position &lt;= <span class=\"hljs-number\">0</span>):\n        <span class=\"hljs-keyword\">raise</span> ValueError(<span class=\"hljs-string\">&quot;Digit position must be a positive integer&quot;</span>)\n    <span class=\"hljs-keyword\">elif</span> (<span class=\"hljs-keyword\">not</span> <span class=\"hljs-built_in\">isinstance</span>(precision, <span class=\"hljs-built_in\">int</span>)) <span class=\"hljs-keyword\">or</span> (precision &lt; <span class=\"hljs-number\">0</span>):\n        <span class=\"hljs-keyword\">raise</span> ValueError(<span class=\"hljs-string\">&quot;Precision must be a nonnegative integer&quot;</span>)\n\n    <span class=\"hljs-comment\"># compute an approximation of (16 ** (n - 1)) * pi whose fractional part is mostly</span>\n    <span class=\"hljs-comment\"># accurate</span>\n    sum_result = (\n        <span class=\"hljs-number\">4</span> * _subsum(digit_position, <span class=\"hljs-number\">1</span>, precision)\n        - <span class=\"hljs-number\">2</span> * _subsum(digit_position, <span class=\"hljs-number\">4</span>, precision)\n        - _subsum(digit_position, <span class=\"hljs-number\">5</span>, precision)\n        - _subsum(digit_position, <span class=\"hljs-number\">6</span>, precision)\n    )\n\n    <span class=\"hljs-comment\"># return the first hex digit of the fractional part of the result</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">hex</span>(<span class=\"hljs-built_in\">int</span>((sum_result % <span class=\"hljs-number\">1</span>) * <span class=\"hljs-number\">16</span>))[<span class=\"hljs-number\">2</span>:]\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_subsum</span>(<span class=\"hljs-params\">\n    digit_pos_to_extract: <span class=\"hljs-built_in\">int</span>, denominator_addend: <span class=\"hljs-built_in\">int</span>, precision: <span class=\"hljs-built_in\">int</span>\n</span>) -&gt; <span class=\"hljs-built_in\">float</span>:\n    <span class=\"hljs-comment\"># only care about first digit of fractional part; don&#x27;t need decimal</span>\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Private helper function to implement the summation\n    functionality.\n    @param digit_pos_to_extract: digit position to extract\n    @param denominator_addend: added to denominator of fractions in the formula\n    @param precision: same as precision in main function\n    @return: floating-point number whose integer part is not important\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-built_in\">sum</span> = <span class=\"hljs-number\">0.0</span>\n    <span class=\"hljs-keyword\">for</span> sum_index <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(digit_pos_to_extract + precision):\n        denominator = <span class=\"hljs-number\">8</span> * sum_index + denominator_addend\n        <span class=\"hljs-keyword\">if</span> sum_index &lt; digit_pos_to_extract:\n            <span class=\"hljs-comment\"># if the exponential term is an integer and we mod it by the denominator</span>\n            <span class=\"hljs-comment\"># before dividing, only the integer part of the sum will change;</span>\n            <span class=\"hljs-comment\"># the fractional part will not</span>\n            exponential_term = <span class=\"hljs-built_in\">pow</span>(\n                <span class=\"hljs-number\">16</span>, digit_pos_to_extract - <span class=\"hljs-number\">1</span> - sum_index, denominator\n            )\n        <span class=\"hljs-keyword\">else</span>:\n            exponential_term = <span class=\"hljs-built_in\">pow</span>(<span class=\"hljs-number\">16</span>, digit_pos_to_extract - <span class=\"hljs-number\">1</span> - sum_index)\n        <span class=\"hljs-built_in\">sum</span> += exponential_term / denominator\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">sum</span>\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    <span class=\"hljs-keyword\">import</span> doctest\n\n    doctest.testmod()\n"
    }
  },
  "contributors": [
    {
      "name": "Elisha Hollander",
      "email": "just4now666666@gmail.com",
      "commits": 1
    },
    {
      "name": "Kenneth P",
      "email": "41343159+ken437@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 3
    }
  ],
  "explanationUrl": {}
}
